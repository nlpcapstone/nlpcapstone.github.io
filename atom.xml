<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/" xmlns:indexing="urn:atom-extension:indexing" indexing:index="no"><access:restriction xmlns:access="http://www.bloglines.com/about/specs/fac-1.0" relationship="deny"/>
  <title>NLP Capstone Spring 2018</title>
  <updated>2018-05-15T04:00:31Z</updated>
  <generator uri="http://intertwingly.net/code/venus/">Venus</generator>
  <author>
    <name>Nelson Liu</name>
    <email>nfliu[at]cs.washington.edu</email>
  </author>
  <id>https://nlpcapstone.github.io/atom.xml</id>
  <link href="https://nlpcapstone.github.io/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://nlpcapstone.github.io/" rel="alternate"/>

  <entry xml:lang="en">
    <id>http://mathstoc.wordpress.com/?p=335</id>
    <link href="https://mathstoc.wordpress.com/2018/05/10/nlp-capstone-post-7-tsl-pipeline/" rel="alternate" type="text/html"/>
    <title>NLP Capstone Post #7: TSL Pipeline</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">  Modeling issues As seen in our results last week, the RNN architecture we have been training has not been able to produce any coherent series of tokens based on the music data provided in the clean Lakh dataset. To analyze the poor results of this model, we have considered various features of the quality … <a class="more-link" href="https://mathstoc.wordpress.com/2018/05/10/nlp-capstone-post-7-tsl-pipeline/">Continue reading <span class="screen-reader-text">NLP Capstone Post #7: TSL Pipeline</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p> </p>
<h2><span style="font-weight: 400;">Modeling issues</span></h2>
<p><span style="font-weight: 400;">As seen in our results last week, the RNN architecture we have been training has not been able to produce any coherent series of tokens based on the music data provided in the clean Lakh dataset. To analyze the poor results of this model, we have considered various features of the quality of the data. To simplify the issue of timing the lyric tokens, this model attempts to predict a lyric token at every timestep. Between each token we have summed all the musical data, producing a piano roll that looks approximately like the following image.</span></p>
<p><img alt="Screen Shot 2018-05-09 at 4.31.53 PM" class="  wp-image-331 aligncenter" height="303" src="https://mathstoc.files.wordpress.com/2018/05/screen-shot-2018-05-09-at-4-31-53-pm.png?w=501&amp;h=303" width="501"/></p>
<p><span style="font-weight: 400;">In the event that two lyrics occur at exactly the same time step, we end up with a gap in the notes, here highlighted in red.</span></p>
<p><img alt="Screen Shot 2018-05-09 at 4.31.53 PM" class="  wp-image-334 aligncenter" height="302" src="https://mathstoc.files.wordpress.com/2018/05/screen-shot-2018-05-09-at-4-31-53-pm1.png?w=500&amp;h=302" width="500"/></p>
<p><span style="font-weight: 400;">At first we expected this problem to occur in only a small number of cases, but it is often the result of the newline character appearing in a message simultaneously with the first lyric of the next sentence. This processing poses several problems to the task of learning the lyrical content based on the structure of the music. First, the large number of musical gaps may be confounding the model due to the large variety in lyrics that will be seen at those time steps. Additionally, we lose all information about the song timing since all regions without lyrics are compressed into a single time step. In theory, gaps in lyrics could hint to the model that the next section should start a new verse or chorus.</span></p>
<h2><span style="font-weight: 400;">The TSL Pipeline</span></h2>
<p><span style="font-weight: 400;">As suggested in the previous blogpost, we would like to be able to augment the results of the musical model with a higher quality lyrical dataset. The Kaggle lyrics dataset has shown promising results in previous blogposts at the quality of the lyric sequences it has been able to produce.</span></p>
<p><span style="font-weight: 400;">The TSL Pipeline is a combination of three models: Timing, Seed, and Lyrics. The architecture may look something like the following diagram:</span></p>
<p><img alt="Training" class="  wp-image-333 aligncenter" height="221" src="https://mathstoc.files.wordpress.com/2018/05/training.png?w=531&amp;h=221" width="531"/></p>
<p><span style="font-weight: 400;">During training, each pianoroll will be separated into data representing the timing, notes and lyrics. These get passed into respective models to learn timing and “seed” information. Additional lyrics information from the Kaggle dataset is used to train a lyrical model.</span></p>
<p><img alt="Evaluation" class="  wp-image-332 aligncenter" height="220" src="https://mathstoc.files.wordpress.com/2018/05/evaluation.png?w=538&amp;h=220" width="538"/></p>
<p><span style="font-weight: 400;">At evaluation time, the lyrics from the original pianoroll are not passed into the Seed model. Instead, the Seed model attempts to predict some seed based on the musical content, and will pass its result into the lyrics model. The combination of these lyrics and timing information constitute the complete description of our karaoke output.</span></p>
<h2><span style="font-weight: 400;">Timing Model</span></h2>
<p><span style="font-weight: 400;">In all previous posts we ignored the issue of lyrics timing in the interest of creating a reasonable lyrical model. Our current timing model is similar to our previous model attempt, but the data is generated differently. Instead of computing a pianoroll sample at each lyrical timestep, we us a constant sampling frequency of 10 timesteps per second. We then annotate each timestep with a 1 or 0 based on if a lyric was annotated at that step. The model will then attempt to predict for each step of a given pianoroll the probability there should be a lyric at that time.</span></p>
<h2><span style="font-weight: 400;">Seed Model</span></h2>
<p><span style="font-weight: 400;">The seed model will be a simplified version of the poorly performing model from before. Instead of predicting all lyrics, it will attempt to predict a small subset of the initial lyrics. This would also allow us to create a dataset with more training examples by splitting each song into smaller samples.</span></p>
<h2><span style="font-weight: 400;">Lyrics Model</span></h2>
<p><span style="font-weight: 400;">The lyrics model will be similar to the one described in the second blog post, which is a character level RNN for generating lyrics. This will take the first few words predicted by the seed model and generate the remainder of the lyrics. Since it’s trained on the large Kaggle dataset the quality seems to be much higher than what our MIDI training has produced.</span></p>
<h2>Results</h2>
<p>As of this blog post, we are still testing various hyperparameters and waiting for models to converge.  Additional results will follow once we can examine the various output.</p></div>
    </content>
    <updated>2018-05-10T06:56:01Z</updated>
    <category term="NLP Capstone"/>
    <author>
      <name>Nicholas Ruhland</name>
    </author>
    <source>
      <id>https://mathstoc.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://mathstoc.wordpress.com/category/nlp-capstone/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://mathstoc.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://mathstoc.wordpress.com/osd.xml" rel="search" title="Mathematical Distractions" type="application/opensearchdescription+xml"/>
      <link href="https://mathstoc.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A recreational (occasionally research) blog on topics in maths or computer science - by Kuikui</subtitle>
      <title>NLP Capstone – Mathematical Distractions</title>
      <updated>2018-05-15T04:00:30Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/2ac19f7510f9</id>
    <link href="https://medium.com/nlp-capstone-blog/advanced-model-attempt-1-continued-2ac19f7510f9?source=rss----9ba3897b6688---4" rel="alternate" type="text/html"/>
    <title>Advanced Model Attempt #1 (Continued)</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>This week we continued work on the advanced version of the model which incorporates the SummaRuNNer architecture from (Nallapati et al.) and adds in a character level RNN for parsing UMLS terms. The models are complete but we ran into several challenges along the way, namely constructing our final training dataset from Semantic Scholar and UMLS terms. Without the dataset, we have not been able to train our model. In this blog post, we dissect our current challenges and our plans looking forward.</p><h4>Building the Model</h4><p>The original SummaRuNNer model fit our requirements pretty well. However, we ran into several challenges when implementing the model. First, there were no existing implementations of the architecture, so we had to implement the model from scratch. Furthermore, the time we spent building the model detracted from time that we could have spent working on gathering the data. The model used by Nallapati et al. also did not condition on a particular term in the paper. Our approach requires that we somehow incorporate the term so we spent additional time figuring out a character level RNN which encodes the term and includes it in the many affine transformations described in the SummaRuNNer paper.</p><p>Moreover, we had to consider how to optimize the model when it came to large amounts of data. One of the approaches we worked on was batching, essentially evaluating many sentences at once. This allowed us to speed up training by a significant amount. Finally, we spent time integrating our model into the existing architecture. Ultimately, the model was difficult, but completed.</p><h4>Collecting the Data</h4><p>There are no current datasets that we can use to train our model. To quickly recap the requirements for the data, each training example must comprise of one document, one entity or technical term, and a target representing the ideal summary of the document. In order to build this dataset, we had to individually collect each of these aspects and combine them.</p><p>In order to gather technical terms, we used the UMLS dataset, which contains over 150,000 medical terms. Obtaining the license to download UMLS and the actual process of downloading the data through the UMLS specialized data downloader took several days. Parsing the data was fairly straightforward however.</p><p>In order to gather documents, we are using the AI2 Semantic Scholar dataset, which contains over 7 million research papers. While the downloading process for Semantic Scholar was incredibly slow, we realized that we couldn’t simply download all the documents because some of them were not medical papers. Handling Computer Science papers becomes an issue because our entities are medical terms and we do not expect a computer science paper to have any relation to medical terms.</p><p>This brings us to the process of combining Semantic Scholar documents with UMLS terms. We use a distant supervision method which essentially applies a greedy approach to extract a group of sentences from each document with the highest ROUGE score while using the UMLS definitions as reference summaries. This is precisely where we are currently struggling. Computing ROUGE takes a very long time, considering the fact that we compute ROUGE as many times as there are sentences in each document. Though we filter out document-term pairs based on whether the term appears in the document, it seems that the ROUGE metric may not yield the best target sentences for us because our reference summaries tend to be fairly short while our documents tend to be fairly long. Currently, we have all the scripts running for this data collection process but aim to develop a better heuristic to collect data.</p><h4>Next Steps</h4><p>At this point, we have not been able to test our data because we are still building the dataset. In order to speed up this process, our immediate goal will be to develop a faster and more accurate heuristic to gather target sentences from each document. We will also explore filtering out the Semantic Scholar papers to only retain medical papers, which are more likely to correlate to the terms in UMLS. Once we build our dataset, we can test our completed models, tune hyper-parameters, and potentially utilize attention mechanisms while constructing the document level representation used by SummaRuNNer.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=2ac19f7510f9" width="1"/><hr/><p><a href="https://medium.com/nlp-capstone-blog/advanced-model-attempt-1-continued-2ac19f7510f9">Advanced Model Attempt #1 (Continued)</a> was originally published in <a href="https://medium.com/nlp-capstone-blog">NLP Capstone Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></div>
    </content>
    <updated>2018-05-10T06:40:34Z</updated>
    <category term="machine-learning"/>
    <author>
      <name>Karishma Mandyam</name>
    </author>
    <source>
      <id>https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4</id>
      <logo>https://cdn-images-1.medium.com/proxy/1*TGH72Nnw24QL3iV9IOm4VA.png</logo>
      <link href="https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/nlp-capstone-blog" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>A Journey Through CSE 481N, the Natural Language Processing Capstone Course at the University of Washington - Medium</subtitle>
      <title>NLP Capstone Blog - Medium</title>
      <updated>2018-05-15T04:00:25Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://deeplearningturingtest.wordpress.com/?p=23</id>
    <link href="https://deeplearningturingtest.wordpress.com/2018/05/09/advanced-model-attempt-1-part-2/" rel="alternate" type="text/html"/>
    <title>Advanced Model Attempt 1 (Part 2)</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">This week I completely finished the model end-to-end and programmed the rules of the dialogue/game. The input to the model is created as follows: the user response is broken up into individual words and converted into a matrix of word embeddings. That matrix is run through a CNN before being fed into the LSTM and … <a class="more-link" href="https://deeplearningturingtest.wordpress.com/2018/05/09/advanced-model-attempt-1-part-2/">Continue reading <span class="screen-reader-text">Advanced Model Attempt 1 (Part 2)</span> <span class="meta-nav">→</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>This week I completely finished the model end-to-end and programmed the rules of the dialogue/game. The input to the model is created as follows: the user response is broken up into individual words and converted into a matrix of word embeddings. That matrix is run through a CNN before being fed into the LSTM and finally the policy networks to compute the Q values for user actions (questions to the user) and hypothesis actions (updates to the database). The model I created closely follows the one in this paper: <a href="https://arxiv.org/abs/1606.02560" rel="nofollow">https://arxiv.org/abs/1606.02560</a></p>
<p>I was able to run the simulation on my computer and debug a few issues with the model before starting the actual training session. Furthermore, I moved the model to Azure, set up the SQL database on the remote computer, and am currently running the simulation on tensorflow-gpu.</p>
<p>The initial results are not too great but somewhat promising. The model assigns +30 reward for winning, -30 for losing, -5 for bad guesses and +1 if it correctly understands the user response and performs the right action on the database. My model started out with an average of -30 reward for an entire game (it almost never took the same action that the user said and then abruptly lost) and after about 100,000 time steps that average has decreased to -23. This tells me the model is eventually learning how to understand the user responses but the convergence is still a lot slower than I expected.</p>
<p>As a side note, while it seems silly to try classifying user responses into buckets like ‘Yes’, ‘No’, ‘Unknown’ instead of training a separate classifier, the goal is to build a model that can be generalized to more complex dialogue types where there are more nuanced actions that heavily depend on dialogue state, not just the current user response.</p>
<p>The main difference between my model and the model in the paper (barring any bugs I am unaware of) is how the user response is represented. In both models, the model tries to combine NLU and dialog state tracking into one end-to-end model and the user response sentence representation is crucial in determining the dialogue state at any given time step. The paper creates a very short bag of bigrams feature vector (of about 30 features) from the sentence whereas I create glove vectors (embedding dimension = 50) for each word and run them through a CNN to get an output of 250-300 features.</p>
<p>The paper made it sound like they got the model to converge and play the game well after about 120000 time steps. To play the game well, the model needs to correctly understand what action should be done on the database based on the user response. My guess is their model converges much faster and can learn to make the right action much faster than mine because of their simpler state representation. Once the model learns how to correctly interpret the user response, it becomes much easier to learn how to win from any given dialogue state. This allows the model to generalize to people it hasn’t seen because the model only learns what actions to take based on the dialogue state, not on the attributes of any given person.</p>
<p>My goal for next week is to try tuning my model to converge faster. My main plan will be to shorten and simplify the state representation to be more like the paper’s (although it will still be different since the paper used utterance embeddings for speech, not word embeddings). If the model somehow works well after tuning, I will look into trying to train the model on more complex user responses where the set of actions to take are more qualitative than yes and no.</p></div>
    </content>
    <updated>2018-05-09T06:58:16Z</updated>
    <category term="Uncategorized"/>
    <author>
      <name>ananthgo</name>
    </author>
    <source>
      <id>https://deeplearningturingtest.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://deeplearningturingtest.wordpress.com/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://deeplearningturingtest.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://deeplearningturingtest.wordpress.com/osd.xml" rel="search" title="NLP Capstone Project Updates - Ananth" type="application/opensearchdescription+xml"/>
      <link href="https://deeplearningturingtest.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <title>NLP Capstone Project Updates – Ananth</title>
      <updated>2018-05-15T04:00:27Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-9203775015655831448.post-6866691098285474093</id>
    <link href="https://teamoverfit.blogspot.com/2018/05/7-milestone-advanced-model-attempt-1.html" rel="alternate" type="text/html"/>
    <title>#7 Milestone: Advanced model attempt #1 (continued)</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h2 style="height: 0px;"><span>Team Overfit</span></h2><h3><span><br/></span></h3><h3><span>Project repo: <span style="font-size: 18.72px;"><a href="https://github.com/pinyiw/nlpcapstone-teamoverfit">https://github.com/pinyiw/nlpcapstone-teamoverfit</a></span></span></h3><h4><span>Team members: Dawei Shen, Pinyi Wang, Xukai Liu</span></h4><div style="text-align: start; text-indent: 0px;"><div style="margin: 0px;"><div><span><b>Blog Post: #7: 05/09/2018</b></span></div><div><span><span><b><br/></b></span></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Social Media Predicts Stock Price (StartUp Mode)</span><br/><br/><span><span style="white-space: pre;"><b>Try Out Logistic Regression To Tune LSTM</b></span></span><br/><ul><li><span><span style="white-space: pre;"><b><span id="docs-internal-guid-bd404b7a-43cb-ecd9-d5e4-fdaf1add2bb5" style="font-weight: normal;"><span>From our previous model, which we classify the stock price movement as UP/DOWN/STAY, we noticed that during training often the loss will converge in less than 5 epochs and the predictions are either all UPs or all STAYs depending on the range of percent difference we classified as STAY. It seems like the model wasn’t able to learn much from the input data.</span></span></b></span></span></li><li><span><span style="white-space: pre;"><b><span style="font-weight: normal;"><span><span id="docs-internal-guid-bd404b7a-43cc-42d1-70ab-45794e67af61"><span style="vertical-align: baseline;">Then, we tried to use logistic regression by making our RNN only has one output node and remove the softmax function. We also changed the loss function from Cross-Entropy to mean squared loss. This helps to predict the percentage of change of the stock price directly.</span></span></span></span></b></span></span></li><li><span><span style="white-space: pre;"><b><span style="font-weight: normal;"><span><span style="vertical-align: baseline;"><span id="docs-internal-guid-bd404b7a-43cc-6947-13f3-a833249311ac"><span style="vertical-align: baseline;">With the new training method, the model can now predict a specific stock price for a day given input data. Then, according to the stock price predicted, we can further categorize the prediction into UP/DOWN/STAY and use our previous evaluation function to determine the accuracy of our model.</span></span></span></span></span></b></span></span></li></ul><div><span><span style="white-space: pre-wrap;"><b>Select and Add Competitors Stock Price to Tune LSTM</b></span></span></div><div><ul><li><span><span style="white-space: pre-wrap;"><span id="docs-internal-guid-bd404b7a-43cd-277f-263a-f85ae0ec0c14"><span style="vertical-align: baseline;">For company Apple, we selected company Samsung’s and Huawei’s stock prices as part of input data to train the model, because this two big company also produce mobile phones and are the biggest competitors for Apple in the industry.</span></span></span></span></li><li><span><span style="white-space: pre-wrap;"><span style="vertical-align: baseline;"><span id="docs-internal-guid-bd404b7a-43cd-46f5-47b8-55814d42e5b3"><span style="vertical-align: baseline;">For company Tesla, we selected company Toyota for the similar reason as for Apple.</span></span></span></span></span></li></ul><div><span><span style="white-space: pre-wrap;"><b>Results</b></span></span></div></div><div><ul><li><span><span style="white-space: pre-wrap;"><span id="docs-internal-guid-bd404b7a-43cd-a926-74ae-e30f944bf03e"><span style="vertical-align: baseline;">After we have improved the model and the training process, it no longer generates the same classification for all input. It now does try to predict the stock price percent difference and has reasonable results.</span></span></span></span></li><li><span><span style="white-space: pre-wrap;"><span style="vertical-align: baseline;"><span id="docs-internal-guid-bd404b7a-43cd-bab2-93f6-880e4aaa0b8c"><span style="vertical-align: baseline;">The prediction accuracy for Apple will be around </span><span style="font-weight: 700; vertical-align: baseline;">55.5</span><span style="vertical-align: baseline;">% if we choose </span><span style="font-style: italic; vertical-align: baseline;">‘+/-0.5% change of the stock price</span><span style="vertical-align: baseline;"> as </span><span style="font-style: italic; vertical-align: baseline;">‘STAY’.</span></span></span></span></span></li><li><span><span style="white-space: pre-wrap;"><span style="vertical-align: baseline;"><span style="font-style: italic; vertical-align: baseline;"><span id="docs-internal-guid-bd404b7a-43cd-d22c-ec0c-0e76e203c53a"><span style="font-style: normal; vertical-align: baseline;">The prediction accuracy for Apple will be above </span><span style="font-style: normal; font-weight: 700; vertical-align: baseline;">44.4</span><span style="font-style: normal; vertical-align: baseline;">% if we choose </span><span style="vertical-align: baseline;">‘+/-1.0% change of the stock price’</span><span style="font-style: normal; vertical-align: baseline;"> as </span><span style="vertical-align: baseline;">‘STAY’.</span></span></span></span></span></span></li></ul><div><span><span style="white-space: pre-wrap;"><b>What to Investigate for the Next Week</b></span></span></div></div><div><ul><li><span><span style="white-space: pre-wrap;">Try to use CNN as model.</span></span></li><li><span><span style="white-space: pre-wrap;">Instead of using Tweets, try using financial news as input.</span></span></li><li><span><span style="white-space: pre-wrap;">Try out different embedding methods.</span></span></li><li><span><span style="white-space: pre-wrap;"><span id="docs-internal-guid-bd404b7a-43ce-cc90-1d5a-b707d0e7eb84"><span style="vertical-align: baseline;">Apply F1 Scores. For the evaluation, we would like to know:</span></span></span></span></li><ul><li><span><span style="white-space: pre-wrap;"><span style="vertical-align: baseline;">The rate of stocks are marked ‘UP’/’DOWN’/’STAY’ that are predicted correctly as ‘UP’/’DOWN’/’STAY’ separately.</span></span></span></li><li><span><span style="white-space: pre-wrap;"><span style="vertical-align: baseline;"><span id="docs-internal-guid-bd404b7a-43ce-fb74-a644-3c307522369d"><span style="vertical-align: baseline;">The rate of stocks are marked ‘UP’/’DOWN’/’STAY’ that are predicted wrongly as ‘UP’/’DOWN’’STAY’</span></span></span></span></span></li></ul></ul></div></div></div></div></div>
    </summary>
    <updated>2018-05-09T06:54:00Z</updated>
    <author>
      <name>Team Overfit</name>
      <email>noreply@blogger.com</email>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-9203775015655831448</id>
      <author>
        <name>Team Overfit</name>
        <email>noreply@blogger.com</email>
      </author>
      <link href="https://teamoverfit.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="https://teamoverfit.blogspot.com/feeds/posts/default?alt=rss" rel="self" type="application/rss+xml"/>
      <title>NLP Capstone</title>
      <updated>2018-05-15T04:00:30Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/a2d837ecf66b</id>
    <link href="https://medium.com/@halden.lin/nlp-capstone-07-formalizing-a2d837ecf66b?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone | 07: Formalizing</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><em>previous posts: </em><a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5"><em>01</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5"><em>02</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3"><em>03</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7"><em>04</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a"><em>05</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0"><em>06</em></a></p><p>A couple of developments since I last posted:</p><ol><li>I’m now more formally receiving guidance from Kanit (Ham) Wongsuphasawat and Tongshuang (Sherry) Wu of the Interactive Data Lab. Special thanks to them for helping me thus far!</li><li><a href="https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0">Last week</a> I was uncertain as to the future direction of this project. After much deliberation and several conversations, I’ve decided to remain on the tool-based approach originally conceived. There are a couple reasons for this. First, the user study I proposed has, at least from an NLP perspective, limited novelty. What’s more, learning from the study by modifying the underlying model would require time that would likely fall outside of the quarter. Second, carrying out this study would involve significant logistical work (again, a time constraint). Finally, in beginning to formalize this visualization tool, I’ve become more excited in its potential as a useful part of a researcher’s debugging pipeline. In any case, any model modifications I may make as part of the user study would difficult without a similar tool.</li><li>As mentioned, I’ve been formalizing this tool in a React application, iterating on the exploration I’ve done with prototypes in the weeks previous. The rest of this post will describe my work here.</li></ol><h4>Starting with Text</h4><p>First things first: text brushing is critical in understanding the attention each output token, or a series of output tokens, pays to the source text. In the gif below, the left side holds the source text (along with a mini-map to prevent the need of scrolling to understand the overall distribution of attention), while the right holds the summary. Selection and brushing have been implemented, as in the prototypes of last week, albeit cleaned up.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/999/1*LKOEMB1cwvp2qXRy58_-4w.gif"/>Cleaned up selection and brushing, in addition to a minimap for long input sequences.</figure><h4><strong>Challenges with Text (Future Work):</strong></h4><ol><li>Sentence / paragraph level structure is lost via tokenizing. This is an artifact of the tokenization process performed prior to feeding text into models.</li><li>Lowercase and always-on spacing between tokens makes text difficult to read. For now, I’ve been dealing this with a few hand-coded rules. For example, removing spaces before punctuation, and capitalizing the first word after end of sentence punctuation.</li></ol><p>I’ll need to keep brainstorming to find methods for addressing these issues.</p><h4>How do we enable identification of patterns?</h4><p>While selection and brushing over the text is valuable in allowing users to understand attention for specific words or phrases, it falls short in enabling big-picture identification of patterns. Without brushing over each token and / or sentence (and memorizing coverage along the way), the closest users may get is the aggregate view (when nothing is selected) in which <strong>what</strong> is being attended to is apparent, but not <strong>how.</strong> That is to say, it is not apparent which tokens / phrases in the summary attend to which tokens / phrases in the source text. In particular, below is a growing list of goals for this visualization.</p><ol><li><strong>Enable identification of coverage</strong>. For words / phrases / sentences, where is the attention being paid, and by what?</li><li><strong>Enable identification of missing coverage</strong>. What is being unattended to that should be?</li><li><strong>Enable identification of extraction vs abstraction</strong>. Where is copying occuring? Where is true abstraction occuring?</li></ol><p>If this tool can accomplish these items, I believe it will be a good start in proving its value.</p><p>With this in mind, we need some sort of visualization to accompany the two blocks of text. As previously mentioned, heat-maps may not be the best solution.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Kd4lr3ZZmOZ6ffMdp82PJg.gif"/>Interactive heat-map, as prototyped previously.</figure><p>Lag is apparent (likely a result of the large number of elements drawn), and even ignoring this, the tiles become extremely small as the input / output sequences grow, making it difficult to pick out even high attention weights. More visual weight is needed for significant attention weights, which is difficult to accomplish as x and y space is already taken by the input / output token position.</p><p><strong>So where else can we look?</strong></p><h4>Flowmaps</h4><p>Looking back at my project proposal, I saw this visualization made by Rikters et al. (2017).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*uP_-gGiPkv6YMFYz."/>An example of a flow-map from machine translation [Rikters et al. 2017].</figure><p>I thought this might be worth exploring, so I attempted to create something similar.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*SxZUaHFYssV5JtXo."/>A flowmap displaying all edges is problematic. This doesn’t scale either.</figure><p>Unsurprisingly, there are far too many edges to display without significant overlap and occlusion. Summarization rears its head again as a challenge with its large input sequences.</p><p><strong>How do we remedy this?</strong></p><p>One observation is that high attention weights are fairly sparse (as evident by the aggregate on the source text above). What if we filtered out these insignificant weights? A naive approach is to take the top <em>k </em>percent of weights and display only those.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*I4jiiM98R88ZfMKz."/>A flowmap showing only the top 1% of weights.</figure><p>The above example is displaying only the top 1% of attention weights. Edges have both their width and opacity scaled by their weight within this 1% domain. Significant (wide) weights are clearly identifiable. Thinner lines, faint (or nearly invisible) lines can also be seen, indicating that the much more significant weights have been preserved. Four distinct ‘rays’ can be seen, seemingly corresponding to the four sentence of the summary.</p><p>Selection and brushing seemed like intuitive follow-ups for interaction to enable more detailed / accurate pattern identification.</p><p><strong>Selection</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*U8_42zGX24nN8iB7Wo-zPw.gif"/>Selection over the flowmap, both over the output nodes as well as the output text.</figure><p>Selection allows users to orient themselves in the flowmap, picking out which edges correspond to which input / output tokens.</p><p><strong>Brushing</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*1t7BRJX9g2k80B67IFQ4lw.gif"/>Brushing over the flowmap allows for windowed pattern identification.</figure><p>Brushing enables accurate pattern identification. In the example above, brushing over the distinct rays allows us to see the almost entirely extractive nature of the summary — there is a clear 1:1 mapping from input to output that is implied by the clean structure of the rays, and confirmed upon inspecting the corresponding input / output tokens for these rays.</p><h4><strong>Challenges with Flowmaps (Future Work):</strong></h4><ol><li><strong>Selecting a top k% is not ideal — it does not generalize well.</strong> In the pathological case, where attention is evenly distributed for all tokens, we lose a lot of valuable information. A potential band-aid to this is to allow users to select the percentage of weights displayed, but this may be dangerous as high percentages can crash the browser. Perhaps a more elegant solution would be to perform clustering on the weights. I’ll need to do more research here.</li><li><strong>Overlapping paths can make reading the flowmap difficult.</strong> The example shown above is fairly clean, direction flows, for the most part, in a single direction. You could imagine, however that if a summary is extremely abstractive, pulling from all over the source, there might be significant overlap in edges, decreasing legibility. A potential solution to this is edge bundling, where edges going in similar directions are pulled together to preserve pattern recognition.</li></ol><p>A good starting point for exploration here is the paper <a href="http://vis.stanford.edu/files/2011-DividedEdgeBundling-InfoVis.pdf"><em>Divided Edge Bundling for Directional Network Data</em></a> by Selassie, Heller, &amp; Heer (2011). In this, the authors describe a method for bundling, divided edge bundling, that holds characteristics I believe are important for my own visualization.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Ma6OlxvATqGNHbyu."/>Different techniques applied to a network of GitHub contributions along the west coast of the United States [Selassie, Heller, &amp; Heer 2011].</figure><p>In the coming weeks I hope to dive into these techniques and explore their impact on the flowmap I’ve developed thus far.</p><h4>In Summary</h4><p>Still a lot of work to do! Here are my goals for the next week.</p><ol><li>Improve flowmap visualization.</li><li>Find examples that cover the problem space (e.g. low coverage, abstraction, extraction).</li><li>Keep brainstorming.</li><li>Optimize code.</li></ol><p>Things are getting interesting!</p><h4>References</h4><ol><li><a href="https://ufal.mff.cuni.cz/pbml/109/art-rikters-fishel-bojar.pdf">Rikters, Matīss, Mark Fishel, and Ondřej Bojar. “Visualizing neural machine translation attention and confidence.” <em>The Prague Bulletin of Mathematical Linguistics</em> 109.1 (2017): 39–50.</a></li><li><a href="http://vis.stanford.edu/files/2011-DividedEdgeBundling-InfoVis.pdf">Selassie, David et al. “Divided Edge Bundling for Directional Network Data.” <em>IEEE Transactions on Visualization and Computer Graphics</em> 17 (2011): 2354–2363.</a></li></ol><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a2d837ecf66b" width="1"/></div>
    </content>
    <updated>2018-05-09T06:48:30Z</updated>
    <category term="machine-learning"/>
    <category term="computer-science"/>
    <category term="nlp"/>
    <category term="data-visualization"/>
    <category term="visualization"/>
    <author>
      <name>Halden Lin</name>
    </author>
    <source>
      <id>https://medium.com/@halden.lin?source=rss-2759d54493c0------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*Hzu2ZqgloT0I1F6Kwg8OPA.jpeg</logo>
      <link href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@halden.lin" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Halden Lin on Medium</subtitle>
      <title>Stories by Halden Lin on Medium</title>
      <updated>2018-05-15T04:00:29Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/d9145c25606a</id>
    <link href="https://medium.com/@be.li.nda/nlp-capstone-blog-7-advanced-model-i-part-2-d9145c25606a?source=rss-fad49d942bf3------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone Blog #7: Advanced Model I Part 2</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>Note for all of the analysis below, I’m focusing on performance on the positive/negative sentiments. Performance on “no sentiment” seems to naturally better due to “no sentiment” being the majority class in the data.</p><h3>Datasets</h3><p>This week I created a few more datasets to experiment with in an attempt to improve my models’ performance on the developments set. I used a combination of two approaches to create the datasets:</p><ol><li>Adding new weakly labelled “no sentiment” examples to the training data. To do this, we took the existing documents in the training data, found all the un-labelled entities in the document, and labelled pairs of these entities as “no sentiment.” We thought it would be a reasonable assumption to make in assuming all un-labelled entities are “no sentiment,” because usually documents are focused on interactions/sentiments between a particular set of entity pairs, which the annotators would consider important enough to label. Thus, usually the rest of the peripheral entity pairs should not express or be the target of any significant sentiment. Of course, this is not always the case. I took a look into examples generated through this approach, and there are quite a few inaccurate labels. Some of the inaccuracies came from bad co-reference resolution from the initial dataset, which propagated and created inaccuracies on this new dataset. For example, if a mention of the original holder entity wasn’t found the first time around, it might have been labelled as a new entity in the new dataset, and thus an inaccurately labelled “no sentiment” pair is added between that mention of the holder and the target entity. Other times, the assumption was simply incorrect: peripheral entities still expressed positive/negative sentiment towards other entities, or were the recipients of positive/negative sentiment.</li><li>Adding samples from “dev_tune.” As I explained in the previous blog post, <a href="https://homes.cs.washington.edu/~eunsol/papers/acl2016.pdf">Choi et al.</a> had split the development set into two subsets: “eval” and “tune.” I used samples from “tune” to train and used “eval” for all the rest of the functions of a development set. Since “dev_tune” should follow to a similar distribution as my development and test data, this could help performance, by bringing the distribution of the training dataset closer to the distribution of the development and test datasets. For some of datasets I created, I also tried oversampling this set to try and get even closer to the distribution of my development/test set.</li></ol><p>In total I generated 6 datasets:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/587/1*-Oaiiq1AEgT2lu9g9UUiJg.png"/></figure><p>The F1 scores of the baseline model on these datasets look as follows:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/690/1*G6FwBUjDx3bI9-ULwvDiCw.png"/>F1 scores of baseline on each dataset.</figure><p>Note that when I added “dev_tune” samples, F1 scores seems to decrease slightly, whereas when I added the weakly generated “no sentiment” training data, F1 scores actually seems to increase slightly. I looked into this and I noticed that adding “dev_tune” samples seems to <em>improve recall</em> and <em>decrease precision</em> on pos/neg data, whereas adding weakly labelled “no sentiment” samples <em>improves precision</em> and <em>decreases recall</em> on pos/neg data. Since the original dataset already had higher recall than precision, adding dev_tune exacerbated the difference between precision/recall whereas adding weakly labelled data made the two metrics more similar. Thus the results make sense as F1 scores tend prefer when precision/recall are closer. See examples below:</p><h4><strong>Scores on Dataset 1 (Original)</strong></h4><p>Note recall is higher than precision on positive and negative sentiments.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/532/1*ADWr0nmp6dSL2Y6GkIE_eA.png"/></figure><h4>Scores on Dataset 4 (+ Weakly Generated Training Data)</h4><p>Note precision and recall are closer, resulting in higher overall F1 score.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/532/1*9VTXI1ZBfD8yvzd9utVZKw.png"/></figure><h4>Scores on Dataset 3 (+ Dev_tune Samples)</h4><p>Note precision and recall are farther, resulting in lower overall F1 score.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/532/1*iKtmGfzu9WP4YbqX5cF_5Q.png"/></figure><h3>Advanced Model</h3><p>I also made a few changes to the advanced model. First, since all my datasets had imbalanced classes, I tried using class weights to mitigate the effect. Specifically, if there were 10x more “no sentiment” examples than “positive sentiment” examples, then “no sentiment” would be weighted by 0.1.</p><p>I also simplified the advanced model’s architecture a little to try and reduce the number of parameters the model needs to learn. Previously, after I encoded the tokens with the biLSTM, I extracted spans representing holder/target entities and fed them through two separated FFNNs. This time, I simply concatenated the holder/target span representations and fed them through a single FFNN which predicted their sentiment.</p><p>The F1 scores of this model on the datasets 1 (original), 4 and 6 (datasets that baseline performed best on) are reported below:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/697/1*sNaYsByqW5kdX7H_NKMa3w.png"/>F1 scores of baseline vs. advanced model on datasets 1, 4, and 6.</figure><p>While there is some slight improvement in F1 scores (especially on dataset 4), unfortunately, none of these results approach the state of the art reported by the previous Choi et al. paper. For next time, I plan to do more focused error analysis to isolate the issue. I may also take Yejin and Ari’s advice in experimenting with encoding transitivity and other relations within the model through various means (which hopefully I’ll have the time to do).</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d9145c25606a" width="1"/></div>
    </content>
    <updated>2018-05-09T06:45:30Z</updated>
    <category term="machine-learning"/>
    <category term="naturallanguageprocessing"/>
    <category term="deep-learning"/>
    <author>
      <name>Belinda Zou Li</name>
    </author>
    <source>
      <id>https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/0*A16vZtRWBzxYPlmn.</logo>
      <link href="https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@be.li.nda" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Belinda Zou Li on Medium</subtitle>
      <title>Stories by Belinda Zou Li on Medium</title>
      <updated>2018-05-15T04:00:24Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/d7a06e892cdd</id>
    <link href="https://medium.com/@viterbi.or.not/advanced-model-1-part-2-d7a06e892cdd?source=rss-c522ef075bb3------2" rel="alternate" type="text/html"/>
    <title>Advanced Model #1, Part 2</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>Welcome back to Advanced Model #1 and thanks for sticking with us! This week, we’ve gotten some promising results in our first advanced model attempt and made a lot of progress with the incorporation of a second data source, although there is still work to be done toward fully integrating the chatlog data into a single model. In this post, we’ll go over what we’ve done since last week and give some numbers as well as example summaries from this model, then start laying out what we would like to achieve for Advanced Model #2.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*AsUzi76WPSKaMji6."/>Our project roadmap and where we are at now, highlighted in orange</figure><h4><strong>Preprocessing</strong></h4><p>We decided to use preprocessing instead of features for some of the attributes of our data after discovering that our feature sets failed to focus solely on the conversation in some data types and instead gave false importance to format-specific patterns such as quoted text in emails. We eventually settled on the following distinction:</p><ul><li>Attributes of the data that existed at the conversation-level should be features: that is, anything universally applicable to textual conversations in general was implemented as a feature for the model</li><li>Attributes of the data at the data source-level should be preprocessed. This allowed us to share features across different data types (for example, using tf-idf across both emails and chatlogs) while minimizing the number of “dead” features (for example, simply assigning a constant value to a feature for detecting email signatures when vectorizing the chatlog data).</li></ul><p>The preprocessing we decided to do falls under the following categories:</p><p><strong>Identifying format-specific content:</strong> Quirks of the data format can sometimes present problems for our model, for example, we noticed separator lines composed of all dashes or symbols as well as email signatures (left example below) were making it into the summaries.</p><p><strong>Removing quoted email text:</strong> The email dataset contains quoted text of previous emails in the thread when there is an email reply, causing duplication of sentences in the summaries because the model seems to want to include the important sentence as much as possible. An example of a generated summary with the problem is in the right example below.</p><p>After initially parsing the data, we do this preprocessing step to identify such sentences using simple regular expression rules and remove them before computing feature vectors.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*vUpBdbFjg5Exfd-8."/>An email signature (left) and quoted text (right) in generated summaries before adding preprocessing</figure><h4><strong>Adding the Chatlog Dataset — New Pipeline</strong></h4><p>One of our major goals for the advanced model was to incorporate the chatlog dataset we identified early on in the project. Of course, having the capability to automatically generate summaries for chat conversations expands the usefulness and possible applications of our model: although email threads are incredibly common in today’s world, chat communication is also experiencing an incredible rise in popularity. Furthermore, as chat communications tend toward a large number of participants and a model of very frequent responses, our analysis is that chat data summaries have the potential to be even more useful than their email counterparts.</p><p>However, our goal with incorporating the chatlog data is ultimately to combine it with the email data in order to be able to train our model on both data types at once. To do this, we saw the need to create a common list of features that can be applied to any data input, allowing the model to train on both sources of data indiscriminately. As the Sood et. al. paper suggests, training on both sets of data has the potential to improve the resulting summaries of the model for each type of data separately, although the paper in question does not specify their results beyond the notion that they were promising in a preliminary examination.</p><p>The end goal for our system is illustrated below:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*YodqfIjCDfX5xJLfNG_JFQ.png"/>Pipeline for integrating different datasets with a common feature set into our model</figure><p>The blended colors represent the notion of common features, achieved through separate pre-processing and vectorizing of each data source but used in a single shared model.</p><p>To achieve this, we needed to do a major restructuring of our codebase, and it is unfortunately the case that a huge portion of our time this week was spent improving old code to make it more modular and compatible with these new requirements. What was once a single script to parse, process, vectorize, and train on a single dataset had to be broken apart into different modules for each of those tasks that could implement a common interface. In addition, with the growing number of options and tasks that had to be supported, we discovered it was necessary to entirely separate the concerns of processing text and handling configuration: to that end, we created a new, much more robust command-line interface and broke all other components into individual directories with as much code factoring as possible.</p><p>As a result of our design process and refactor, we currently have almost all of the infrastructure necessary for incorporating the chatlog data and training our model on all of the available data before evaluating on a single source. As we mentioned above, however, there were several challenges with parsing the chatlog data, namely the messy nature of the chats and the number of possible edge cases present in such a large dataset. Therefore, we are still in the process of finishing the parser component, but once it is complete we should be able to use both types of data in Advanced Model #2 and report on the impact that it makes. See our progress so far with this pipeline structure on our <a href="https://github.com/viterbi-or-not-to-be/viterbi-or-not-to-be/tree/master/conversation">GitHub repository</a>!</p><h4><strong>Results</strong></h4><p>Through the addition of the preprocessing step, we have greatly improved our ROUGE scores and become competitive with the advanced model in the Sood et. al. paper. Here are the results of our advanced models, using all of the features we have discussed so far and with the preprocessing step:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iDsZaXOhuHshbaFWXFlPvQ.png"/>Results of the three advanced model types</figure><p>These results are significantly better than our baseline, and we believe our model is generally pretty good at picking up on which sentences are important to keep! To more directly see the impact of preprocessing, we compared the results of the Naive Bayes model with and without preprocessing:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BBrr-Z2ilFTbK8xi-t2SPg.png"/>Comparison between our advanced model with preprocessing and without preprocessing</figure><p>The model without preprocessing does decently, but the preprocessing definitely contributes significantly to our advanced model performance. To show our progress since the baseline model, this compares the results of the Naive Bayes baseline models with those of our current Naive Bayes model:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*M_zctk4dPmVbmVHeHmRYYQ.png"/>Comparison between our advanced model and our baselines</figure><p>Both ROUGE-1 and ROUGE-2 have stepped up by several percentage points, but the most significant increase is seen in the ROUGE-L improvement. Finally, our model compared with the model in the Sood et. al. paper:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Ty7sqP2swRfdf1UGw7wb_g.png"/>Comparison between our advanced model and the Sood et. al. model</figure><p>As you can see, our ROUGE-L score is slightly lower but our ROUGE-1 and ROUGE-2 scores are higher! We’ve previously discussed the drawbacks of ROUGE―there is no definitively better type of ROUGE metric and ROUGE in general is not necessarily a reliable indicator of how good the generated summaries really are, so we are wary about quantifying our model’s performance in comparison to the Sood et. al. model’s performance based just on ROUGE scores. However, we haven’t been able to find any examples of the summaries generated by their model so this is all we have to go off of for now.</p><h4><strong>Example Summary and Analysis</strong></h4><p>Because ROUGE provides relatively unreliable metrics for evaluation of our model’s summaries, we have also turned to human evaluation. One of the summaries that our model was able to generate based off an input email thread, using all of the preprocessing and extra features that we have built, is reproduced below in its original condition except for display-motivated truncation:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*BMVwYccbvULdQcwp."/>Comparison between human annotated reference summary (left) and summary generated by our advanced model (right)</figure><p>This summary is fairly representative of the summaries that are being generated, and compared to the results we saw from our baseline models it is clearly doing better in terms of human evaluation. The sentences highlighted in green are those that are shared between the reference annotation and our system’s generated summary — interestingly, all but one of the sentences in the reference summary were successfully captured by our system. Therefore, reading through the summary generated by our system gives a strong impression of the topics that were discussed in the thread, and seemingly gives a human reader all the information that is needed.</p><p>However, there are certainly aspects of the current summaries produced by the model that are lacking. In the summary given above, all 6 sentences that were truncated for display purposes at the ellipsis and the four additional non-green sentences displayed were not included in the reference summary. This summary comes from a thread with only 31 sentences after preprocessing, meaning that while our model successfully captured all of the sentences marked as important by a human, it did so at the cost of incorporating an enormous percentage of unnecessary extra text that serves to make the summary less of a “summary” while adding relatively little content. To address this, we will need to figure out how to reward the model for producing more concise summaries, or to incorporate a “compression factor” that allows producing a summary with the k most relevant sentences for some value of the hyperparameter k. Another issue is highlighted in red above — while we added preprocessing to remove email signatures based on a set of heuristics, to avoid deleting important content we made the preprocessor act conservatively when uncertain, and as a result some signatures like in the example above made their way into the summaries. Although other features would ideally prevent these signatures from appearing in many cases, we will need to improve our preprocessing heuristics in order to target these kinds of medium-specific text examples before moving on to incorporate additional types of data.</p><h4><strong>Next Steps</strong></h4><p>To entirely finish Advanced Model #1, we would like to complete the process of incorporating chatlog data and then transition into work on Advanced Model #2 by continuing to explore and add conversation-specific features. We also want to address the excessive lengthiness problem we found in the generated summaries by doing something to limit the number of sentences the model is allowed to select for the extractive summary.</p><p>Beyond these immediate steps, we would love to be able to take a stab at abstractive summarization! It’s a really challenging but rewarding conversation summarization problem that we will need to put some more thought into to attempt. We’ve preliminarily determined that we can make an attempt using the extractive output from our current model along with some other contextual metadata from the conversation data (for example, authors of the chosen sentences), to get a start on an abstractive summary. In general, we think this will require more modeling of entity relationships and text generation.</p><p>Overall, we’re excited with what our model has been able to do so far and optimistic about what we’ll be able to achieve with Advanced Model #2, so stay tuned!</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d7a06e892cdd" width="1"/></div>
    </content>
    <updated>2018-05-09T06:33:15Z</updated>
    <category term="nlp"/>
    <author>
      <name>Viterbi Or Not To Be</name>
    </author>
    <source>
      <id>https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*wiisg40Bu4z11RTWJ66mnA.png</logo>
      <link href="https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@viterbi.or.not" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Viterbi Or Not To Be on Medium</subtitle>
      <title>Stories by Viterbi Or Not To Be on Medium</title>
      <updated>2018-05-15T04:00:27Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-US">
    <id>http://cse481n-capstone.azurewebsites.net/?p=82</id>
    <link href="http://cse481n-capstone.azurewebsites.net/2018/05/08/advanced-attempt-ii/" rel="alternate" type="text/html"/>
    <title>Advanced Attempt II</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Data Collection Since our last blog post we have settled on using Dice Index with a cutoff of .5 for including post sentences in our dataset. This final dataset was generated by running similarity between 24574 “hateful” sentences (r/MeanJokes posts and sentences from the general set that were matched by the hate lexicon described previously) … <a class="more-link" href="http://cse481n-capstone.azurewebsites.net/2018/05/08/advanced-attempt-ii/">Continue reading<span class="screen-reader-text"> "Advanced Attempt II"</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h3>Data Collection</h3>
<p><span style="font-weight: 400;">Since our last blog post we have settled on using Dice Index with a cutoff of .5 for including post sentences in our dataset. This final dataset was generated by running similarity between 24574 “hateful” sentences (r/MeanJokes posts and sentences from the general set that were matched by the hate lexicon described previously) and 8,662,875 general Reddit sentences that were from subreddits that were not black-listed. With a .5 cutoff only 2308 of the “hateful” sentences were matched with general reddit posts other than themselves. There were 16940 such general posts. This gives us a total dataset of ~19k potentially interesting sentences to use for the pilot program. </span></p>
<p><span style="font-weight: 400;">An interesting observation from running this is just how sparse the data truly is. Reddit is very diverse and its various communities use very different language from each other. Only .2% of all posts were within .5 Dice Index of the “hateful” posts. With .7 Dice Index it was .01% with only 1000 matched sentences. However, this is just from one month of Reddit data. If we need to increase the cutoff or just get more examples in the future, there are many more dumps we could use to get us enough data to feed our neural net models. </span></p>
<p><span style="font-weight: 400;">What follows are some examples from the dataset and how our current best model performs on them.</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Matched by hate lexicon, presumably from a support subreddit: “My wife was raped My wife tonight was raped, she doesn’t want to go to the police.” labeled hate with 88% certainty</span>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Similar post: “I don’t want to go. My wife is being guilted into going.” labeled none with 78% certainty</span></li>
</ul>
</li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Matched by hate lexicon: “It really fucks with me and makes me feel like a slave.” labeled none with 62% certainty</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Matched by hate lexicon: “Saying the word ”gentleman” is not sexist is like saying the word ”nigger” is not racist.” labeled hate with 95% certainty</span>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Similar post: “Saying a word such as Nigger isn’t racist. It’s only racist when aimed at a person.” labeled hate with 94% certainty</span></li>
</ul>
</li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Matched by hate lexicon: “I denied it, would say “I can’t believe that pathetic faggot would make something like that up”.” labeled hate with 99% certainty (model doesn’t understand what quotes are)</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">From r/MeanJokes: “What do you call a 5 year old with no friends? A sandy hook survivor.” labeled none with 83% accuracy (model doesn’t know current events)</span></li>
</ul>
<p><span style="font-weight: 400;">Here are some more examples of issues:</span></p>
<p><span style="font-weight: 400;">We did use December after all:</span></p>
<p><img alt="" class="alignnone size-full wp-image-85" height="835" src="http://cse481n-capstone.azurewebsites.net/wp-content/uploads/2018/05/b4-p1.png" width="1033"/></p>
<p><span style="font-weight: 400;">People like to repost mean jokes with variations:</span></p>
<p><img alt="" class="alignnone size-full wp-image-86" height="127" src="http://cse481n-capstone.azurewebsites.net/wp-content/uploads/2018/05/b4-p2.png" width="974"/></p>
<p> </p>
<h3>Advanced Model Attempt 2:</h3>
<p><span style="font-weight: 400;">Last week we explored a new model that uses CNN as encoder, however, we had little luck on making it work better. This week we tried to take contextual information into account using ELMo provided by Allennlp.</span></p>
<p><span style="font-weight: 400;">In short, ELMo enables us to adjust our word/character embedding based on words/characters nearing it. Comparing to the pure Glove embedding we used before, ELMo enables us to take context into consideration which is meaningful as illustrated in our results.</span></p>
<p><span style="font-weight: 400;">During our experiments, we used the </span><a href="http://allennlp.org/elmo"><span style="font-weight: 400;">pretrained ELMo embeddings</span></a><span style="font-weight: 400;"> (1-layer) provided by Allennlp. The ELMo embeddings and glove embeddings were concatenated before being passed through an NN seq2vec encoder.</span></p>
<ul>
<li><span style="font-weight: 400;">Setup 1: gru + 1 layer feed forward with 50 dimension glove embedding, trained and evaluated on twitter_waseem dataset</span></li>
</ul>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Without ELMo</span></td>
<td><span style="font-weight: 400;">With ELMo</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.7940</span></td>
<td><span style="font-weight: 400;">0.7982</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8022</span></td>
<td><span style="font-weight: 400;">0.7979</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7876</span></td>
<td><span style="font-weight: 400;">0.7986</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8235</span></td>
<td><span style="font-weight: 400;">0.8228</span></td>
</tr>
</tbody>
</table>
<ul>
<li><span style="font-weight: 400;">Setup 2: gru + 1 layer feed forward with 50 dimension glove embedding, trained on combined dataset, evaluated on twitter dataset</span><br/>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Without ELMo</span></td>
<td><span style="font-weight: 400;">With ELMo</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.7788</span></td>
<td><span style="font-weight: 400;">0.8047</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.7979</span></td>
<td><span style="font-weight: 400;">0.8029</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7672</span></td>
<td><span style="font-weight: 400;">0.8065</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8152</span></td>
<td><span style="font-weight: 400;">0.8276</span></td>
</tr>
</tbody>
</table>
</li>
<li><span style="font-weight: 400;">Setup 3: gru + 1 layer feed forward with 200 dimension glove embedding, trained and evaluated on twitter_waseem dataset</span><br/>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Without ELMo</span></td>
<td><span style="font-weight: 400;">With ELMo</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.7915</span></td>
<td><span style="font-weight: 400;">0.8027</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.7908</span></td>
<td><span style="font-weight: 400;">0.8067</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7923</span></td>
<td><span style="font-weight: 400;">0.7993</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8166</span></td>
<td><span style="font-weight: 400;">0.8290</span></td>
</tr>
</tbody>
</table>
</li>
<li><span style="font-weight: 400;">Setup 4: gru + 1 layer feed forward with 200 dimension glove embedding, trained on combined dataset and evaluated on twitter dataset</span><br/>
<table>
<tbody>
<tr>
<td/>
<td>Without ELMo</td>
<td>With ELMo</td>
</tr>
<tr>
<td>F1</td>
<td>0.7953</td>
<td>0.7813</td>
</tr>
<tr>
<td>Precision</td>
<td>0.7997</td>
<td>0.8044</td>
</tr>
<tr>
<td>Recall</td>
<td>0.7914</td>
<td>0.7681</td>
</tr>
<tr>
<td>Accuracy</td>
<td>0.8228</td>
<td>0.8187</td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;">From the aboving statistics, we can see that ELMo does help us on getting a better result. It seems with ELMo, our model has a noticeable </span><span style="font-weight: 400;">improvement on Recall </span><span style="font-weight: 400;">when training on combined dataset. And precision and accuracy remains about the same with a little bit fluctuation.</span></p>
<p><span style="font-weight: 400;">We think with context taken into consideration, our model now is better at telling sentences that intend to be hateful but with few or no clearly hateful words or phrases. We will talk more about it in the following part.</span></p>
<p><span style="font-weight: 400;">Next we will do some error analysis on our new models:</span></p>
<p><span style="font-weight: 400;">First, we will check how ELMo helps on correcting mistakes we had in our models without ELMo:</span></p>
<p><span style="font-weight: 400;">Recall these examples from our baseline model blog posts:</span></p>
<p><span style="font-weight: 400;">False Negatives:</span></p>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">@RichardDawkins @AbuelitoSerge Really, Muslims understand this. They just want to be able to use the name “racism” to shut us up.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">@RTUKnews An Islamist human rights group? LOL. Now there is a contradiction in terms.</span></li>
</ol>
<p> </p></li>
</ul>
<p><span style="font-weight: 400;">False Positives:</span></p>
<p><span style="font-weight: 400;">3. @Strubbestition Name one thing that is not an opinion but is still sexist. I will wait.</span></p>
<p><span style="font-weight: 400;">4. @Bipartisanism @AllooCharas Terrorism involves a political or religious objective to the terror. Most mass murderers have personal objectives</span></p>
<p><span style="font-weight: 400;">In our new model with ELMo, we now correctly classifies 1 and 2. However, We still think 3 and 4 to be hateful while they aren’t.</span></p>
<table>
<tbody>
<tr>
<td/>
<td>Hate prob</td>
<td>None prob</td>
<td>Correct?</td>
</tr>
<tr>
<td>1</td>
<td>0.8673</td>
<td>0.1327</td>
<td>yes</td>
</tr>
<tr>
<td>2</td>
<td>0.8408</td>
<td>0.1592</td>
<td>yes</td>
</tr>
<tr>
<td>3</td>
<td>0.6350</td>
<td>0.3650</td>
<td>no</td>
</tr>
<tr>
<td>4</td>
<td>0.7003</td>
<td>0.2997</td>
<td>no</td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;">From the aboving results, we can see that with ELMo, our model does a better job on classifying things that means bad while has nothing really bad. From the class probabilities, we can tell our model is pretty confident about its prediction.</span></p>
<p><span style="font-weight: 400;">Since we still misclassified those two non-hateful sentences, this may introduce a concern that our model may have a tendency to predict everything as hateful. However, we didn’t observe a noticeable drop in precision or accuracy as they remains about the same. We think it is safe to conclude that by using ELMo embeddings, our model makes some improvements.</span></p>
<p><span style="font-weight: 400;">Next we will did some error analysis on our new model. However, after reading through the error sentence files, we discovered a lot of them looks like to the noise of the original dataset. For example, “islam must be outlawed.” is labeled as none as gold label in original dataset and actually our model did a great job on classifying it as hateful.</span></p>
<p><span style="font-weight: 400;">Finally, we also tried ELMo on our preliminary CNN model:</span></p>
<p><span style="font-weight: 400;">With the same setting as previous, we do observe some improvement on our CNN model, however, comparing to other gru models we have, CNN one shows no improvement but the training time is way much longer.</span></p>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Without ELMo</span></td>
<td><span style="font-weight: 400;">With ELMo</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.7745</span></td>
<td><span style="font-weight: 400;">0.7987</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.7616</span></td>
<td><span style="font-weight: 400;">0.8014</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7879</span></td>
<td><span style="font-weight: 400;">0.7963</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8084</span></td>
<td><span style="font-weight: 400;">0.8248</span></td>
</tr>
</tbody>
</table>
<h3>Next Step:</h3>
<p><span style="font-weight: 400;">Our next steps for Data Collection are going to be to get the posts formatted for Mechanical Turk and begin the process of getting our Reddit data labeled.</span></p>
<p>For Modeling, we want to try and incorporate attention into our model and see if that improves our model’s performance.</p>
<h6 style="text-align: left;"><em><strong><span style="color: #000000;">We have a running demo available on our blog in the RUNNING DEMO section of the sidebar.</span></strong></em></h6></div>
    </content>
    <updated>2018-05-09T06:07:12Z</updated>
    <category term="Uncategorized"/>
    <author>
      <name>Team Watch Your Language!</name>
    </author>
    <source>
      <id>http://cse481n-capstone.azurewebsites.net</id>
      <link href="http://cse481n-capstone.azurewebsites.net/feed/" rel="self" type="application/rss+xml"/>
      <link href="http://cse481n-capstone.azurewebsites.net" rel="alternate" type="text/html"/>
      <subtitle>Spring2018 CSE481N Capstone</subtitle>
      <title>Team Watch Your Language!</title>
      <updated>2018-05-15T04:00:21Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/b3b687dd74ae</id>
    <link href="https://medium.com/@hongnin1/advanced-model-attempt-1-continued-b3b687dd74ae?source=rss-c450eb982161------2" rel="alternate" type="text/html"/>
    <title>Advanced model attempt #1 (continued)</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>To recap, this is our baseline approach:</p><p><a href="https://medium.com/@hongnin1/image-annotation-model-baseline-dataset-and-evaluation-framework-d1d1b2d1f34c">Image Annotation Model Baseline, Dataset and Evaluation Framework</a></p><p>Our previous model involves InceptionNet as our CNN encoder and we feed the image vector into LSTM to generate caption. This model we used was heavily based on <a href="https://github.com/tensorflow/models/tree/master/research/im2txt">this model</a>. However we have since then fixed several bugs, improved model’s training speed performance and reduced the training time significantly, at the same time we incorporated more models into our overall model to improve the accuracy.</p><p>First of all, we realized what hindered our training speed is the logging we are doing. We had previously logged every training batch onto TensorBot; our training speed increase by 60% once we started to only update logs on TensorBot every 20 batches.</p><p>In addition to the training speed, we added a single layer neuronetwork to calculate attention weights: We first project input image feature (output from VGG encoder) to the same dimension as the original dimension, then we projected previous hidden state to the same dimension as input feature. Then we added the feature projection and hidden state projection together. We used Relu function as activation function and lastly we reduced the output from Relu function to a one dimensional vector to generate output. In addition to this, we also take one step further on attention by also putting attention on different data points in a single batch, so that the model can learn more from a more important data point. After getting the context matrix from previous steps in attention, we also apply a Beta scale to the matrix, which means that we multiply the matrix by beta vector to get a new context matrix and then generate our final output.</p><p>Coding up our own attention network reduced our training error. In addition to adding attention NN to our model, we also coded a new VGG network for encoding our images, this also significantly improved our model’s accuracy. We have found resources for VGG <a href="http://www.vlfeat.org/matconvnet/pretrained/">here</a>.</p><p>Lastly, we also tried to keep track of the training process by keeping checkpoints during training. Our current rate is one checkpoint every ~50 minutes (800 batches). We are planning on keeping at most 50 checkpoints around to monitor the process in the past 2 days and detect any issue (like overfitting) early.</p><p>For the first couple of months, we have been studying the <a href="https://arxiv.org/pdf/1502.03044.pdf">paper</a> and our baseline model is heavily based on this model <a href="https://github.com/tensorflow/models/tree/master/research/im2txt">here</a>. Now that we have learned all the necessary tool we have coded up most of the model ourselves with some added touch that improved the model’s accuracy. Our git repository: <a href="https://gitlab.cs.washington.edu/sujiez/NLP-481">https://gitlab.cs.washington.edu/sujiez/NLP-481</a></p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b3b687dd74ae" width="1"/></div>
    </content>
    <updated>2018-05-09T03:10:45Z</updated>
    <category term="machine-learning"/>
    <author>
      <name>Ning Hong</name>
    </author>
    <source>
      <id>https://medium.com/@hongnin1?source=rss-c450eb982161------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/0*d6QC_ngideag3rTN.</logo>
      <link href="https://medium.com/@hongnin1?source=rss-c450eb982161------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@hongnin1" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Ning Hong on Medium</subtitle>
      <title>Stories by Ning Hong on Medium</title>
      <updated>2018-05-15T04:00:07Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/82274b3d7f68</id>
    <link href="https://medium.com/@ryanp97/evaluating-predicates-and-hyper-parameter-tuning-82274b3d7f68?source=rss-6378d85d3a9b------2" rel="alternate" type="text/html"/>
    <title>Evaluating Predicates and Hyper-Parameter Tuning</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>The past week, I have been working on stripping the predicates from the graphs to calculate precision and recall over as well as a handful of unsuccessful attempts at hyper-parameter tuning.</p><h4>Predicate Evaluation</h4><p>As mentioned in the last blog post, one of the ideas was to separate the predicates from the graphs and treat them as a bag of words in order to calculate the precision and recall scores over them separately. We can further separate the predicates into two categories: surface predicates and abstract predicates. Surface predicates usually consist of a lemma, a part-of-speech tag, and sense. For more information on surface and abstract predicates, you can read up more on their characteristics <a href="http://moin.delph-in.net/PredicateRfc">here</a>.</p><p>This allows us to get more fine-grained detail on what each model is struggling with. In particular, all the models so far have trouble with predicting surface predicates compared to abstract predicates. For reference, the F1 score differential between Abstract and Surface predicates is nearly 20 points better on the three models I’ve successfully trained so far.</p><pre>Abstract:<br/>    Baseline - Featureless:    <br/>        Precision   :  0.77<br/>        Recall      :  0.73<br/>        F1          :  0.75<br/>    Baseline - Features Removed:<br/>        Precision   :  0.79<br/>        Recall      :  0.75<br/>        F1          :  0.74<br/>    3 Layer, 600 Hidden, 500 Embed - Features Removed:<br/>        Precision   :  0.80<br/>        Recall      :  0.69<br/>        F1          :  0.74</pre><pre>Surface:<br/>    Baseline - Featureless:    <br/>        Precision   :  0.59<br/>        Recall      :  0.53<br/>        F1          :  0.56<br/>    Baseline - Features Removed:<br/>        Precision   :  0.59<br/>        Recall      :  0.50<br/>        F1          :  0.54<br/>    3 Layer, 600 Hidden, 500 Embed - Features Removed:<br/>        Precision   :  0.59<br/>        Recall      :  0.50<br/>        F1          :  0.54</pre><p>After looking into this a little more, there is a large difference in the size of the abstract predicate and surface predicate sets. In the development dataset, there are 7,235 possible surface predicates and only 42 possible abstract predicates to guess from. Furthermore, a small subset of abstract predicates appear much more often than the rest, so it is significantly easier to boost the precision and recall scores for abstract predicates than surface predicates. On the other hand, from eye-balling, surface predicates have a much more even distribution of appearing, so this in combination with the large number of possibilities is likely the cause for the significant difference between the precision and recall scores between abstract and surface predicates.</p><h4>Hyper-parameter Tuning</h4><p>As evidenced from the previous section, there was not a huge difference between the baseline model on fully-featured data and a beefier model on fully-featured data. One of the reasons for this is that the dropout rate was not changed between the two models. So it’s likely that the larger model was able to leverage it’s parameters without overfitting to the data. On top of that, it’s unclear whether or not adding a 3rd layer to the model is beneficial considering the training dataset is fairly small (~95,000 training examples). In this coming week, I plan on performing more error analysis as I continue to tune hyper-parameters. Ideally, I would like to get more information on what surface and abstract predicates the model is able to predict well and which predicates give it the most trouble.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=82274b3d7f68" width="1"/></div>
    </content>
    <updated>2018-05-08T23:41:05Z</updated>
    <category term="machine-learning"/>
    <author>
      <name>Ryan Pham</name>
    </author>
    <source>
      <id>https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*83KfTWByl5pPq7A8_E8ApA.gif</logo>
      <link href="https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@ryanp97" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Ryan Pham on Medium</subtitle>
      <title>Stories by Ryan Pham on Medium</title>
      <updated>2018-05-15T04:00:06Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-5600014144802012716.post-8581531123022969204</id>
    <link href="https://nlpcapstonesemparse.blogspot.com/2018/05/blog-7.html" rel="alternate" type="text/html"/>
    <title>Blog 7</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>I've read through a lot of the data, to understand the data set and view the different types of error </span><br/><span>cases. in general, most(⅔) of the data is just noise, meaning that a programmer won't be able to </span><br/><span>generate the target code from the utterance. </span></div><b id="docs-internal-guid-42510a76-41f6-9607-1678-1da3293c9502" style="font-weight: normal;"><br/></b><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Error breakdown(whats consistently wrong). Rule based fixes.</span></div><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Not understanding functions versus fields</span></div></li><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>return func_debug; or func_x = …</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Fix "Expression--&gt;Expression___(___)", </span></div></li></ul></ul><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Expresion -&gt;identifer</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>identifier-&gt;classfields variables</span></div><ul style="margin-bottom: 0pt; margin-top: 0pt;"><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>"Expression--&gt;Expression___.___Nt_33"</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>If parent has parenthesis then allow nt_33 to generate functions otherwise fields ok</span></div></li></ul></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Not able to initialize correctly</span></div></li><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>List y = new File</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>sriniclass_event = new StatisticGenerationEvent()</span></div></li></ul></ul><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt; text-indent: 36pt;"><span>"Expression--&gt;Expression___Nt_68___Expression",</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;"><span>            "Expression--&gt;Primary",</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;"><span>            "Primary--&gt;IdentifierNT",</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;"><span>            "IdentifierNT--&gt;sriniclass_event",</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;"><span>            "Nt_68--&gt;=",</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;"><span>            "Expression--&gt;new___Creator",</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;"><span>            "Creator--&gt;CreatedName___Nt_37",</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;"><span>            "CreatedName--&gt;IdentifierNT",</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;"><span>            "IdentifierNT--&gt;StatisticGenerationEvent",</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;"><span>            "Nt_37--&gt;ClassCreatorRest",</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;"><span>            "ClassCreatorRest--&gt;Arguments",</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;"><span>            "Arguments--&gt;(___ExpressionList___)"</span></div><b style="font-weight: normal;"><br/></b><br/><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Generics incorrect and missing generics</span></div></li></ul><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span><span class="Apple-tab-span" style="white-space: pre;"> </span></span><span><span class="Apple-tab-span" style="white-space: pre;"> </span></span><span>List&lt;List&gt;  Map&lt;Map, Map&gt;</span></div><span><span class="Apple-tab-span" style="white-space: pre;"> </span></span><span><span class="Apple-tab-span" style="white-space: pre;"> </span></span><span>List x</span><br/><span><br/></span><span>I want pivot now since adding all these rules doesn't seem interesting from a language perspective. I am considering finding a filtering heuristic to run on this dataset to get better quality utterances.</span></div>
    </summary>
    <updated>2018-05-08T22:55:00Z</updated>
    <author>
      <name>nlpcapstone</name>
      <email>noreply@blogger.com</email>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-5600014144802012716</id>
      <author>
        <name>nlpcapstone</name>
        <email>noreply@blogger.com</email>
      </author>
      <link href="https://nlpcapstonesemparse.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="https://nlpcapstonesemparse.blogspot.com/feeds/posts/default?alt=rss" rel="self" type="application/rss+xml"/>
      <title>NlpCapstone</title>
      <updated>2018-05-15T04:00:05Z</updated>
    </source>
  </entry>

  <entry>
    <id>http://sarahyu.weebly.com/cse-481n/advanced-model-attempt-1-part-21</id>
    <link href="http://sarahyu.weebly.com/cse-481n/advanced-model-attempt-1-part-21" rel="alternate" type="text/html"/>
    <title>Advanced Model Attempt #1 (Act 2 Scene 1)</title>
    <summary>This week, I had to do a little backtracking and restructuring, but all for the better! More Data! I have had a couple jobs still running that has allowed me to have more reddit data to work with overall, which is especially good news for the next advanced modelSubreddit ReOrg - A large portion of this week has been on identifying different subsets for the neurodivergent and neurotypical groups. In conversation with Maarten, we discussed that the subreddits in the current state are a bit to [...]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><div class="paragraph">This week, I had to do a little backtracking and restructuring, but all for the better! <ul><li>More Data! I have had a couple jobs still running that has allowed me to have more reddit data to work with overall, which is especially good news for the next advanced model</li><li>Subreddit ReOrg - A large portion of this week has been on identifying different subsets for the neurodivergent and neurotypical groups. In conversation with Maarten, we discussed that the subreddits in the current state are a bit too broad to address the hypotheses and may not produce a focused language model that makes sense. Currently, the neurodivergent group is a broad strokes grouping of all types of differences. With that in mind, I spent some time researching, following some Reddit rabbit holes, and learning about ICD 10 <font color="#515151">(International Statistical Classification of Diseases and Related Health Problems (ICD), a medical classification list by the World Health Organization (WHO)) to classify the subreddits and the mental illnesses they speak to. Among these topics, we specifically wanted to look at the the two 'Blocks' - Mood (affective) disorders and Neurotic, Stress-Related and Somatoform disorders. This would be defined as the new 28 subreddits constituting the neurodivergent set, and the 22 neurotypical subreddits are those that are general advice, community support, or discussions on mental health, broadly speaking. These were chosen from the initial ND set because while some of them discussed mental health and neurodiversity, they were open to more than just users dealing with mental health related issues. They had similar types of posts where people are more open and discussing in detail their personal lives, a kind of venting space. And choosing from this group rather than to look at more general reddit, was a decision made so that I could find the nuances rather than the more general difference seen in discussing psychology and not. Despite the significant reduction of subreddits (from 126 to 28 ND and 100 to 22 NT), the data collection I mentioned above has resulted in 5x the original vocabulary size and we now have a combined 1 million words in the newest set (being added to as we speak)</font></li></ul><br/>With that, I was able to run the previous vennclouds and idp models (and Act 2 Scene 2, before next week will hopefully include the Connotation Frames model results). For the vennclouds, I think we see some similarity from before of the "my/me/I" terms speaking in first person, but the NT posts has more discussion of a second person or a more general reference to an other or friends. It might also be useful to find a list of prepositional phrases to remove and to find something more interesting in the venn diagram middle portion. </div>  <div><div class="wsite-image wsite-image-border-none " style="padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;"> <a> <img alt="Picture" src="http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-05-09-at-2-32-31-am_orig.png" style="width: auto;"/> </a> <div style="display: block; font-size: 90%;"/> </div></div>  <div class="paragraph"><br/>I also ran the IDP model from before and found the following top categories:<br/><strong>ND</strong><br/><em>I/<span>my/</span></em><span><em>me/myself</em> - the personal discussion makes sense, but I'm a bit curious as to why it would be more prevalent than in the other discussion forums that are also predominantly venting spaces focused on the self seeking the community. </span><br/><em>anxiety/depression/OCD</em> - these are the subreddit categories we basically chose<br/><em>feel/feeling </em>- I was surprised to see a significantly higher mention of feeling in the ND categories despite the other subreddits still being communities discussing mental illness along with the larger public in discussing general problems <br/><br/><strong>NT</strong><br/><em>you / his/he/him / girls/she/her - </em>This is a bit surprising given that I had made a bit of a fuss around the female mentions being significantly higher in the ND categories. I'm interested to see what this shift might mean, but even more so, I think the discussion of another is an interesting contrast between the two that might be better suited for the connotation frames results that I hope to do in the next couple of days. <br/><em>https</em> - links are back! But more interestingly, while they were prevalent in the original NT group, which we hypothesized were due to the higher proportion of anecdotal advice in the ND categories, it seems that even in regards to discussions around mental illness, people bring in outside links and whatnot to advise, or uplift other users. <br/><br/>Next Steps: As I mentioned above, I'd like to run this same new and larger dataset with the connotation frames model. Beyond that, I'd like to spend the next two weeks working on either implementing a SAGE log-linear model to describe these language models, or a deep learning model. If possible, I hope to also get the graphical model going <br/><br/></div></div>
    </content>
    <updated>2018-05-08T07:00:00Z</updated>
    <category term="Uncategorized"/>
    <source>
      <id>http://sarahyu.weebly.com/cse-481n</id>
      <author>
        <name>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde</name>
      </author>
      <link href="http://sarahyu.weebly.com/cse-481n" rel="alternate" type="text/html"/>
      <link href="http://sarahyu.weebly.com/6/feed" rel="self" type="application/rss+xml"/>
      <subtitle>CSE 481N</subtitle>
      <title>Sarah yu - CSE 481N</title>
      <updated>2018-05-09T17:30:11Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/4626fe37cadb</id>
    <link href="https://medium.com/@viterbi.or.not/advanced-model-1-part-1-4626fe37cadb?source=rss-c522ef075bb3------2" rel="alternate" type="text/html"/>
    <title>Advanced Model #1, Part 1</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_Pn2CYQZkoIzZYLwVPV2MA.png"/></figure><p>Work on our advanced model is underway! To recap, we aim to upgrade our baseline model by including other forms of conversational data (chatlogs and meeting transcripts in addition to the email data we have been using) into our training and adding features that target characteristics specific to conversational text.</p><h4>Extensibility and Other Datasets</h4><p>To achieve this, we first worked on restructuring our baseline code to be extensible to allow addition of inputs from other datasets and to allow different methods of feature extraction based on the dataset. We’ve started splitting our baseline code into smaller parts (parser, feature extractor, model) and creating a structure for the new code segments and datasets. We’ve also parsed one additional data type (GNUe chatlogs) and begun the process of integrating the data into the structure. Unfortunately, we have not yet been able to produce summaries using this dataset — while we have the parser working, several of our features and evaluation scripts do not translate easily to the new formatting and we are still working on refactoring our codebase to handle it. As we complete our first advanced model, bringing these new data sources into the fold will be a top priority so that we can begin to compare the differences between the dataset and work toward our stretch goal of training on both datasets in order to improve performance on each.</p><h4>Preprocessing</h4><p>Looking at the generated summaries from our baseline model, we found a few mistakes that could be easily avoided using automated preprocessing. The summaries often included quoted replies, email signatures, and other insignificant lines that could be eliminated by looking at simple characteristics of the sentence (for example, a line or sentence ending in a comma usually indicates that it is a greeting or closing clause). We previously added a feature based on the sentence starting with a ‘&gt;’ character to eliminate sentences that were quotes from previous emails in the thread, which improved performance. We are now moving this to the preprocessing step. The preprocessing will occur during after parsing the dataset, but before feature extraction, and because it is highly specific to the types of data we are parsing it will have to be implemented separately for both email and chat data.</p><p>Another addition we have been looking into has been detection of email signatures. While we have not yet created a very successful system for this, we have some ideas on how to proceed as we finish our first advanced model. We have already tried adding a feature for a sentence’s proximity to the end of an email, but unfortunately it was not very successful in removing signatures. Therefore, we are hoping that preprocessing will fit the task better — for example, we might examine the email for the last contiguous block of non-empty lines, and remove them under the assumption that the email signature will always be at the end and will never be useful in a summary. But this comes with its own challenges, as some emails in the dataset (and in general use) do not have a signature, and thus the last contiguous block might be content or even the entire email in some cases. One idea we have to combat this would be application of a language model to the sentences in a contiguous chunk. If a language model (such as an n-gram model) were trained on the English language and exhibited a high perplexity when looking at a given sentence, it might be safe to say that it is not prose and is instead a collection of names, emails, or organization names as one might expect to see in a signature. Be sure to check back in our Part 2 blog post after we have implemented this preprocessing and reported on the results!</p><h4>Conversation-Specific Features</h4><p>We started our foray into conversation-specific features with the those listed in the complete features set (beyond the basic set in our baseline) in the Sood et. al. paper, before expanding upon this set with our own contributions that target email data specifically. So far, we’ve implemented the following features based on the paper —</p><p><strong>Is Question:</strong> Important issues and concerns are often expressed in the form of questions. To take advantage of this idea, this feature represents whether or not (1 or 0) the sentence is a question. When training using this feature, we found that</p><p><strong>Sentiment Score: </strong>Based on the idea that strong sentiments and opinions are important to a conversation, this feature captures the sentiment of a sentence. The score is determined by taking the difference between the positive and negative and score for each word in the sentence, then adding up the scores of all the words in the sentence and normalizing by the number of words in the sentence.</p><p>In addition to the features in the Sood et. al. paper, we came up with some more feature ideas based on our error analysis of the baseline model —</p><p><strong>Numbers:</strong> Even with the ‘Special Terms’ feature, our baseline model often missed lines containing numbers or statistics that we would want to preserve in a summary because they were short or eliminated by the importance of other features. In order to address this shortcoming, this feature uses a simple regular expression mechanism to determine the occurrences of numeric data in a sentence.</p><p><strong>URLs:</strong> The baseline model also often missed URLs, which are typically important information and usually contained in the summary annotations of the dataset. This feature would address this problem by using a regular expression to determine how many URLs are contained in the sentence.</p><h4>Results</h4><p>At first, we tested the features that were described in the Sood et. al. paper, evaluating them on the Naive Bayes model that we had found to be most generally successful in our previous baseline experimentation. As corroborated by the paper’s findings, we discovered that these features were somewhat impactful in improving the performance of our model, at least as far as ROUGE scores were concerned:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*X9KXUGGowXEptmVn3kv-jg.png"/>Results of the model with the conversation-specific features from Sood et. al. compared with the baseline</figure><p>Noticeably, the addition of these conversation features was strictly better for ROUGE evaluation. Both the question feature and sentiment feature were roughly equivalent, although we noticed that when we subjected the summaries to human evaluation it was easier to notice an improvement from the question feature. Many of the important sentences in the reference summaries seem to have been questions, perhaps because asking a question is such a common way to transition to a new topic in an email thread. As a result, we found that this feature helped populate our summaries with many of the questions from the reference summaries, establishing clear boundaries. Even if some of the sentences in our summaries were less impactful, having the questions made a big difference for a human reader because it was possible to get the general idea of the thread from the questions alone. As an example, this is one of our generated summaries, compared with a reference:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ONLBMtMpzebsdPUa1AzWBQ.png"/>Comparison of reference summary (left) to our generated summary (right) using the Is Question feature</figure><p>It is noticeable that the questions add a significant amount of relevance to our summary, although there is still work to be done as far as capturing the shorter, choppier, but still more important non-question sentences.</p><p>However, because another significant goal of our advanced model is to explore other conversation-specific features not addressed in the research paper, we did some additional exploration on our own to find features that could take our model’s performance beyond the results of Sood et. al., even if only for email data. So far, we have found two that improved our ROUGE metrics while also seeming to make more relevant summaries by detecting numbers and detecting URLs in a given sentence. Our results are as follows:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xiga8kKb3O5cYHYP2sDbTQ.png"/>Results of the model with our conversation-specific features compared with the baseline</figure><p>Using the numbers feature in particular, we found that our model was able to outperform the baseline considerably, although upon human examination we had trouble determining exactly why this had happened as the summaries did not capture that many numbers. However, as far as human examination went, we discovered that the URL feature made a clear impact, adding a considerable number of important URLs to our summaries that had originally been passed over by the model even though human annotators had marked them as being especially important.</p><p>Finally, we tried all of these new features together to see how they compared to the baseline:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*l7tr_T6H5jnqWRbSf7NeGA.png"/>Results of the model with the all of the additional features discussed compared with the baseline</figure><p>Ultimately, while these features were relatively few in number, their use of conversation-specific data clearly led to a great deal of performance increase for our model.</p><h4>Next Steps</h4><p>For Part 2 of our advanced model, we would like to finish restructuring and incorporating the other datasets into our model input. Because one of our stretch goals is to be able to find a way to incorporate multiple types of data into a single model, we are hoping to do this in a way that allows us to compute the same (or at least similar) features for each type of data.</p><p>Another goal is to implement the preprocessing steps described above as a part of dataset parsing. Significantly, there are some advanced preprocessing techniques described by the Sood et. al. paper that deal with chat data specifically, so we hope to incorporate those once the chat data is working correctly. Finally, we want to continue adding features — although it is certainly unlikely that all of the features we try will be as successful as the ones described above, we hope that this project will culminate in a thorough examination of the impacts that various features can make, so we will continue to explore in this regard as we finish up our first advanced model.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4626fe37cadb" width="1"/></div>
    </content>
    <updated>2018-05-03T06:56:41Z</updated>
    <category term="nlp"/>
    <author>
      <name>Viterbi Or Not To Be</name>
    </author>
    <source>
      <id>https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*wiisg40Bu4z11RTWJ66mnA.png</logo>
      <link href="https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@viterbi.or.not" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Viterbi Or Not To Be on Medium</subtitle>
      <title>Stories by Viterbi Or Not To Be on Medium</title>
      <updated>2018-05-15T04:00:26Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/d73810e0c390</id>
    <link href="https://medium.com/@be.li.nda/nlp-capstone-blog-6-overfitting-of-neural-baseline-and-advanced-model-d73810e0c390?source=rss-fad49d942bf3------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone Blog #6: Overfitting and Advanced Model I</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>This week, I continued working on correcting the apparent train/development performance discrepancy in baseline neural model through modifying the training data as well as model itself. I also attempted to construct a new advanced model. Unfortunately, the performance on the dev data, of both models, is still not as good as I’d like it to be.</p><h3>Dataset and Work on Baseline</h3><p>I’ve ran my baseline model on a total of 4 different datasets.</p><h4>Dataset A: Original</h4><p>I ran the baseline model using the original dataset provided by <a href="https://homes.cs.washington.edu/~eunsol/papers/acl2016.pdf">Choi et al., 2016</a>. Results are reported from previous blog posts, reposted below:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iPBZ5X-TctKEGWXub_8Klw.png"/>f1 scores across 20 epochs</figure><h4>Dataset B: Splitting train</h4><p>This dataset was created through splitting the original training dataset provided by <a href="https://homes.cs.washington.edu/~eunsol/papers/acl2016.pdf">Choi et al.</a> into an 80/10/10 train/dev/test ratio. The motivations behind this were stated in my previous blog post, but I basically wanted to see how my model would perform if the train/dev/test distributions were similar. Results are reported from previous blog posts, reposted below:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JYd_FY4ZYnUJj5Fnn-kLKg.png"/>f1 scores across 20 epochs</figure><h4>Dataset C: Training on weakly generated data</h4><p>This dataset used the dev/test of dataset A, but supplemented the original training set by generating weakly labeled ‘null’ examples to mimic the distribution of the development dataset. This was done by assuming all unlabeled entity pairs in the training set express no sentiment to each other.</p><p>As I had reported in my previous blog posts, the discrepancy in performance between the dev and train data is large on the original dataset (dataset A). I originally hypothesized this discrepancy as due to the difference in distribution between the training and development dataset, and this seemed to be supported by my results in dataset B. So I believed that by modifying my training dataset in this way, I would be able to improve performance. The results are plotted below:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ZrOouM_61fTPOUZWIE3zTg.png"/>f1 scores across 20 epochs</figure><p>Unfortunately, there is still a large discrepancy in performance, especially on positive and negative sentiment. This led me to wonder what would happened if I trained my model on data similar to the original development data. That is, rather than using splitting the development data off the training data as in dataset B, what would happen if I split the training data off the development data…</p><h4>Dataset D: 3rd Modification (Training on subset of dev data)</h4><p>Originally, <a href="https://homes.cs.washington.edu/~eunsol/papers/acl2016.pdf">Choi et al.</a> had split the development set into two subsets: “eval” (development data used for error analysis and ablations) and “tune” (development data used for tuning hyper-parameters). For each of the above datasets A-C, I had used “eval” as the development data and thrown away the “tune” set. However, I wondered what would happen if I used the “tune” set as my training set. The distribution of my training data and development data should be similar in this case. The results are as follows:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3ET0QKkUWLLhInHQuXOKxA.png"/>f1 scores across 100 epochs</figure><p>Note that there is still a large discrepancy, and performance on the new development data still barely, if ever, exceeds 0.2 for positive and negative labels. This is strongly indicative of overfitting. I have additionally plotted the losses for the train and development results, respectively, and on this plot overfitting is extremely apparent. Development loss does not even begin to decrease, suggesting that the baseline neural model is not learning what its intended to learn — perhaps it’s just memorizing particular configurations of text in the training set.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*KBxQ8qLMwxgU4AtPUuPjZQ.png"/>loss across 100 epochs</figure><h3>Dealing with the Overfitting</h3><p>To deal with the issue, the first thing I tried was applying some regularization. Unfortunately all it seemed to do was decrease/slow down improvement in performance on the train set, and leaving dev set performance unaffected.</p><p>(Results from running neural baseline model on dataset D.)</p><p>Dropout = 0.2: I added a dropout layer after the LSTM and set its dropout rate to 0.2.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*FT7361ZyaXIGgp4aXkf-nA.png"/></figure><p>I’m still not exactly sure as to what is causing the overfitting. Just looking at positive and negative sentiment performance, what’s really strange is the fact that the model’s dev performance was relatively high on dataset B where both train and dev were based on the training distribution, but not on dataset D where both train and dev were based on the development distribution. My guess is that perhaps since there’s relatively little positive and negative examples in the development set, the model had an easier time overfitting them for dataset D. Whereas for the training set, there was a plethora of positive and negative examples (and relatively little no sentiment examples), making it harder for the model to overfit the positives and negatives for dataset B.</p><p>Following Eunsol’s recommendation, I plan next time to experiment with strategically increase the size of the training data, and hopefully the model will demonstrate less overfitting.</p><h3>Advanced Model</h3><p>The final thing I did this week was implement a new model. The model combines elements from the two papers: <a href="https://arxiv.org/pdf/1707.07045.pdf">Lee et al.</a> and <a href="https://arxiv.org/pdf/1802.10569.pdf">Verga et al.</a> Basically, like my baseline neural model, this model encodes the inputs through a biLSTM. However, it then extracts span representations of the holder and target mentions using the encoded endpoints of the span, as in Lee et al. Then it runs the representations through separate FFNN as in Verga et al., and aggregates across holder and target mentions through a summation expression, and extracts the final score through a bi-affine operation. This is a very rough architecture at this stage, and there’s definitely parts of it that aren’t very well thought through, so I’ll definitely tinker with it in the future. However, the following are some preliminary results.</p><p>Results on Dataset C:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9tPF6HytReejUKE3NDwVOw.png"/></figure><p>At this point, it looks like this model has very similar performance, if not worse, to the neural baseline. I will continue tinkering with it, as well as the data, in hopes of improving performance. In particular, in accordance with the <a href="https://arxiv.org/pdf/1707.07045.pdf">Lee et al.</a> paper, perhaps adding features (i.e. the paper used distance and width features, which improved f1 scores by 3.1) or the head-finding attention mechanism will improve performance.</p><h3>Future Plans</h3><ol><li>Continue expanding training data by strategically combining the training data of Dataset C and D.</li><li>If this doesn’t work, do some error analysis to hopefully gain more insight into why the overfit is occurring.</li><li>Tinker with the advanced model by adding features or the head-finding attention mechanism. Also experiment more with the architecture.</li></ol><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d73810e0c390" width="1"/></div>
    </content>
    <updated>2018-05-03T04:25:50Z</updated>
    <category term="naturallanguageprocessing"/>
    <category term="deep-learning"/>
    <category term="machine-learning"/>
    <author>
      <name>Belinda Zou Li</name>
    </author>
    <source>
      <id>https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/0*A16vZtRWBzxYPlmn.</logo>
      <link href="https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@be.li.nda" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Belinda Zou Li on Medium</subtitle>
      <title>Stories by Belinda Zou Li on Medium</title>
      <updated>2018-05-15T04:00:24Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/d01e84c5e1da</id>
    <link href="https://medium.com/nlp-capstone-blog/advanced-model-attempt-1-neural-based-definition-extraction-d01e84c5e1da?source=rss----9ba3897b6688---4" rel="alternate" type="text/html"/>
    <title>Advanced Model Attempt #1: Neural-Based Definition Extraction</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>We last left off on the idea of using an FSA with a restricted vocabulary; restricted in the sense that we extract sentences coupled with a neural language model to assure semantic quality while allowing a generative RNN model a reasonable amount of improvisation to produce abstractive definitions.</p><p>Here, we discuss our approach for the extractive component of this model, and consider it our first attempt at an advanced model for the task.</p><h3>Introducing Extractive Summarization</h3><p>Recall that extractive summarization is the idea of reducing text down to a subset of its sentences that still preserves its semantic integrity. In particular, we intend to build on the work of a successful nerual-based extractive summarizer and tailor it to solve our task.</p><p><a href="https://arxiv.org/abs/1611.04230">SummaRuNNer</a> is an RNN-based extractive summarization algorithm developed by Nallapati et al. that encodes documents from the word level up to and across the sentence level before making inference. Essentially, the model is a binary classifier on sentences within a document on whether it should be included in a summary. Its decisions are conditioned on</p><ul><li>Averaged-pooled word-level hidden states of the sentence</li><li>Average-pooled sentence-level hidden states of the document</li><li>An abstract representation of the summary built so far (average-pooling of the word-level pooled hidden states of sentences selected thus far)</li></ul><p>After which, there are several affine transformations conducive to selecting and filtering sentences:</p><ul><li>Content: affine on the abstract sentence representation that measures semantic richness</li><li>Salience: bilinear affine on the abstract sentence representation and the document representation to measure cohesiveness</li><li>Novelty: bilinear affine on the abstract sentence representation and the running summary representation to address redundancy</li><li>Absolute and Relative Positioning: two separate affines on the embedded index of the sentence to allow how far we are into the document to influence inference</li></ul><p>As of now, we have built from scratch our own <a href="https://github.com/NLP-Capstone-Project/machine-dictionary/blob/development-tam/machine_dictionary_rc/models/SummaRuNNer.py">unofficial implementation of this model</a> with inspiration from another <a href="https://github.com/hpzhao/SummaRuNNer">unofficial implementation</a> and is capable of summarizing documents the way we’ve formatted them. What’s left is for us to tailor this model to fit the task.</p><h3>A Slight Twist on an Established Task</h3><p>As of now, the model summarizes documents. We’d like it so that it instead zeroes in on query terms we give it given a research paper, to intelligently extract only sentences from that paper conducive to defining that term.</p><p>Our approach for augmenting SummaRuNNer to be a definition extractor involves</p><ul><li>Encoding the query term with a character-level RNN and using its concatenated hidden states as its representation</li><li>Introducing this new query-term abstract representation when constructing the document representation through a bilinear affine</li><li>Further introducing this query term by converting many of the non-bilinear affines (content, positioning, and possibly new ones for the task) to further condition inference on the query term.</li></ul><p>Essentially, the sentences we extract from the document are being conditioned on the term we’re trying to define. Encoding technical terms using a character level RNN allows similar technical terms to have similar hidden representations. For example, if we see the term “Chronic Lymphocytic Leukemia” in the training data and encounter “Chronic Myelogenous Leukemia” in the testing data, we would have more of an idea of how to approach this new term because of its character level similarities to the term we have already seen during training time. This might help us break down more complicated novel technical terms at testing time.</p><p>Experiments have yet to be conducted on the effectiveness of this approach but will be discussed later in <strong>Advanced Model Attempt #1 (cont.):</strong> another post later in this series discussing the results of the groundwork we’ve laid out here.</p><h3>Training Methods</h3><h4>Collection Training Data with UMLS and ROUGE:</h4><p>Recall that SummaRuNNer is a model that aims to extract the sentences in a document that summarize it best. It does so by training on examples that teach the model which sentences to extract from the document.</p><p>SummaRuNNeR uses a <em>distant supervision</em> method that relies on ROUGE in order to produce training examples for the model. This portion of the architecture, which we refer to as the “extractor”, extracts the sentences out of each document which maximize the ROUGE score when compared against the gold standard definition for the term in question. The extractor in a summarization context can use a greedy approach as follows:</p><ul><li>Look at each sentence in the document one at a time and consider appending it to the extracted sentences that we have already chosen.</li><li>Calculate the ROUGE score of the old extracted sentences + this new sentence in comparison to the gold standard summarization for the document.</li><li>If the ROUGE score increases from the previous ROUGE score, keep the new sentence.</li><li>Otherwise, we don’t keep the new sentence and move on.</li></ul><p>Although this method may not produce the most optimal and compact set of sentences that are relevant, this approach will be faster and is reasonable. The output of the extractor for each document is a tensor whose length is the number of sentences in the document, and is 0 if the sentence is tagged with O or 1 if the sentence is tagged with I.</p><p>To tailor this style of data collection to our task however, we optimize on ROUGE with respect to an entity’s gold-standard definition instead of a gold-standard summarization of the document. We collect entity-definition pairs through <a href="https://www.nlm.nih.gov/research/umls/">UMLS</a> and creating training examples of the form</p><ul><li>Entity (the technical term to define)</li><li>Gold-standard definition for the entity</li><li>The target sentence IO tags found via distant supervision with ROUGE on sentences of a research paper with the gold-standard definition being the reference</li><li>A Semantic Scholar research paper in which the sentences came from (provides the sentences in which to perform inference)</li></ul><p>With this data, we can train the definition extraction model discussed earlier; we train using these &lt;entity, IO-tagged sentences, publication&gt; examples to learn a tagger that can extract sentences most relevant to a term given a publication.</p><p>While this may result in an unnecessarily large number of training data points, we can also consider pruning this dataset later on if we have irrelevant entities for a particular document. For example, if we were trying to find a training example that used the entity “dental cavity” for a document that was about blood cancers, we might not want to keep this training example because there wouldn’t be much of a correlation between the two. In order to do this, we can introduce a ROUGE threshold, where we only keep the training example if the ROUGE score of the sentences extracted by the tagger are above a particular threshold. This might be an optimization for the future.</p><p>Our previous approach was unsupervised and it relied only on the semantic scholar dataset to produce definitions. Our current approach is an extension of SummaRuNNer which requires gold standard definitions for entities that we’d like to define in each paper. We chose to focus on medical terms, and one of the most complete datasets for medical terms and their definitions happens to be the UMLS dataset. This dataset contains a <em>Metathesaurus</em> which contains, amongst many other pieces of data, medical terms and their definitions. The technical terms in the dataset serve as references for ROUGE in the tagging phase above.</p><h4>In summary</h4><p>Training is fairly straightforward; loss between predicted and target sentences is computed with log loss (each sentence in a document is IO-tagged where sentences labeled with <em>I </em>are to be included in the definition). Essentially, the definition extractor, much like SummaRuNNer, is trained as a sentence tagger.</p><h4>Attention as a Stretch Goal</h4><p>The first part of our basic SummaRuNNer-based model uses a document representation to predict tags for sentences in a document. The current document representation is constructed by averaging the hidden states from words in each sentence and averaging the hidden states from each sentence in the document. However, we believe that simply averaging the sentences may not be the best approach to constructing the latent document representation. One of our stretch goals for us to optimize the model will be to attend to the most important parts of sentences in each document. We can do this using the method proposed in Hierarchical Attention Networks for Document Classification (Yang et. al 2016).</p><p>This approach introduces a word level context vector and a sentence level context vector which allow us to calculate attention coefficients on the fly for every word in each sentence and every sentence in the document. In this manner, we can take a weighted sum of the hidden states in the sentences and will hopefully produce better document representations overall. The word level and sentence level context vectors can be initialized randomly and learned throughout training.</p><h4>Conclusion</h4><p>We are very excited to have found a supervised approach to this task per the advice of AI2 researchers. It’s a straightforward approach with measurable loss and clearer metrics.</p><p>We also hope to have enough time before the capstone is over to introduce attention!</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d01e84c5e1da" width="1"/><hr/><p><a href="https://medium.com/nlp-capstone-blog/advanced-model-attempt-1-neural-based-definition-extraction-d01e84c5e1da">Advanced Model Attempt #1: Neural-Based Definition Extraction</a> was originally published in <a href="https://medium.com/nlp-capstone-blog">NLP Capstone Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></div>
    </content>
    <updated>2018-05-03T03:32:53Z</updated>
    <category term="extractive-summarization"/>
    <category term="nlp"/>
    <category term="machine-learning"/>
    <category term="deep-learning"/>
    <author>
      <name>Tam Dang</name>
    </author>
    <source>
      <id>https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4</id>
      <logo>https://cdn-images-1.medium.com/proxy/1*TGH72Nnw24QL3iV9IOm4VA.png</logo>
      <link href="https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/nlp-capstone-blog" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>A Journey Through CSE 481N, the Natural Language Processing Capstone Course at the University of Washington - Medium</subtitle>
      <title>NLP Capstone Blog - Medium</title>
      <updated>2018-05-15T04:00:25Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/6f773ae418d0</id>
    <link href="https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone | 06: Uncertainty</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>previous posts: <a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5">01</a> <a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5">02</a> <a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3">03</a> <a href="https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7">04</a> <a href="https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a">05</a></p><p>I’ve begun to realize I may not be getting as much out of the project I chose I had hoped. My initial motivation for my project was a hope of expanding my knowledge and developing insights on the NLP front by leveraging the familiarity of Visualization. While I am certainly learning a lot by reading papers on Attention and Neural Networks as a whole (especially through my in-class paper presentation), I feel the work I am doing in building a tool for visualizing and debugging attention models may not be providing me the space to explore NLP that I had hoped for. While the tool will certainly <strong>enable </strong>exploration, my concern is that this exploration will not occur until after the tool is completed at the end of the quarter.</p><p>The good news is that there have been two recent developments that, while increasing my uncertainty, offer potential for greater depth in exploration along the NLP front.</p><h4>1. Potential Pivot</h4><p>I voiced these concerns with Prof. Choi this past week and was given a good amount of valuable advice. Per her suggestion, the beginning of my last cycle began with three tasks.</p><ol><li>Read <a href="https://dl.acm.org/citation.cfm?id=2470718"><em>The Efficacy of Human Post-editing for Language Translation</em></a><em>, </em>authored by<em> </em>Spence Green, Jeff Heer, and Christopher Manning. This paper is unique in that it presents the value of Visualization and HCI within Natural Language Processing, but not as a window into a model. Rather, the authors explore a specific task integral to the Language Translation pipeline and present suggestions for future work in improving Language Translation.</li><li>Do in-depth human error-analysis of existing summarization models. I used examples from See et al.’s paper <em>Get To The Point: Summarization with Pointer-Generator Networks </em>(2017).This was helpful gaining a better intuition as to the problem space and the challenges currently posed by machine summarization.</li><li>Think about how summarization as a task, whether that be the development of models, the model’s task itself, or end-user tasks that use the model, can be re-framed in order to leverage Visualization. This was especially time consuming, as it was difficult for me, but it helped immensely in taking a step back to understand the purpose of these models. This, in turn, helped me understand how my work can fit into this purpose.</li></ol><p>The next few days consisted largely of brainstorming pivots for my project. The most promising direction that came out of these sessions is very briefly outlined below.</p><p><strong>Assisted Cognitive Document Abstraction</strong></p><p>Machine-generated document summaries, even the state-of-the-art, are infrequently used in practice because their summaries are quite poor. Perhaps we can leverage existing models to, rather than produce definite summaries which may be error-prone or difficult to understand, create visualizations over the source text in order to assist humans in comprehension and abstraction.</p><p>For example, instead of treating attention weights as input for an output of text, as we do in summarization models, we can view them as output for human interpretation. Aggregate attention distributions (in summarization) highlight areas of the input text that are salient for the summary produced. Note that this is potentially more valuable than highlighting extractive summaries in the text because attention could potentially point towards different areas of the text that relate to a summary sequence. In this way, generation of summaries becomes a proxy task for creating salient highlights for text. We could then use this as a starting point from which ‘related’ sections in an article may be highlighted for users upon interaction (e.g. mousing over an attended-to sequence).</p><p>The hope is that these visualizations will increase the speed (over no summarization) or accuracy (over machine summarization) at which readers can abstract / understand key ideas in a document.</p><p>Most excitingly, with this re-framing of the task for these models, from sequence output to highlighting, perhaps the models can be modified by adding or removing constraints and mechanisms in order to improve performance for this new task.</p><p>Upon presenting this idea (in longer form) to Prof. Choi, I was encouraged to (1) think more about weaknesses of removing summaries altogether and (2) push for more novelty in the approach — is there any meaningful insight about attention models or summarization as a task that can be gleamed from this pivot, and if not, how can I work towards that. While I do not yet have answers to these concerns, the next development may result in a few.</p><h4>2. Related work, here at the Allen School</h4><p>It was just recently brought to my attention that a Tongshuang (Sherry) Wu, a PhD student in the Interactive Data Lab (in which I am currently working), is also working on visualizations for understanding attention models in NLP. As a part of her project, she and a few of her peers have developed a preliminary visualization tool for an attentive QA model (on the SQuAD dataset).She and my mentor, Kanit (Ham) Wongsuphasawat (whom I have been bouncing ideas off recently), have kindly offered to meet and discuss her work and insights on the problem space. Perhaps collaboration is a possibility — this is exciting! In any case, I suspect talking with Sherry and Ham will provide me the insight and guidance to make a decision on the direction of my project.</p><h4><strong>Future Work</strong></h4><p>I hope to make another blog post in the coming few days as I iron out a future direction. Before this, however, future work is unclear. Until next time!</p><h4>In the meanwhile (supplementary material)</h4><p>I’ve also been playing around with my visualization prototypes, even as I am uncertain as to whether or not they will be relevant to my project after this week. Here’s what I’ve discovered and implemented in that time.</p><ol><li>Interactive heat-maps likely won’t work.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_bVKvDPn6jBADKwFU9VG3g.gif"/>Interactive heat-maps result in a large degree of lag between input and visual update. This is likely due to the extremely large size of the attention matrix in summarization (24,000 individual squares in the heat-map).</figure><p>This is unfortunate, but browser limitations are limitations that must be worked around.</p><p>2. Selection over output text.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/999/1*KfMQd6YnDzdH9dZOyjVEIw.gif"/>Mousing over words in the summary results in a view of the attention distribution over the article for that decoder time-step.</figure><p>This is similar to the interactive visualizations presented by See et al. in their <a href="http://www.abigailsee.com/2017/04/16/taming-rnns-for-better-summarization.html">blogpost</a>.</p><p>3. Brushing over output text.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*nwGIF3VgNDeuFxRml8gGzg.gif"/>Brushing over the summary results in an aggregate attention distribution (i.e. coverage) over the article for the selected decoder time-steps.</figure><p>This is an interaction technique I have yet to see in work involving attention analysis, so this is exciting! It looks to be somewhat useful in identifying sections of input text that are salient to an <strong>idea</strong> rather than a <strong>single word</strong> in the output text.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6f773ae418d0" width="1"/></div>
    </content>
    <updated>2018-05-02T06:59:16Z</updated>
    <category term="visualization"/>
    <category term="data-visualization"/>
    <category term="nlp"/>
    <category term="machine-learning"/>
    <category term="computer-science"/>
    <author>
      <name>Halden Lin</name>
    </author>
    <source>
      <id>https://medium.com/@halden.lin?source=rss-2759d54493c0------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*Hzu2ZqgloT0I1F6Kwg8OPA.jpeg</logo>
      <link href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@halden.lin" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Halden Lin on Medium</subtitle>
      <title>Stories by Halden Lin on Medium</title>
      <updated>2018-05-15T04:00:29Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://deeplearningturingtest.wordpress.com/?p=21</id>
    <link href="https://deeplearningturingtest.wordpress.com/2018/05/02/advanced-model-attempt-1-part-1/" rel="alternate" type="text/html"/>
    <title>Advanced Model Attempt 1 (Part 1)</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">This week I created and populated my SQL database with the birth year, birth place, industry, gender, profession, and continent information corresponding to 100 random famous people spanning across all time periods. Furthermore, I created a little over 30 questions that the model can ask as well as the corresponding SQL queries for each question. … <a class="more-link" href="https://deeplearningturingtest.wordpress.com/2018/05/02/advanced-model-attempt-1-part-1/">Continue reading <span class="screen-reader-text">Advanced Model Attempt 1 (Part 1)</span> <span class="meta-nav">→</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>This week I created and populated my SQL database with the birth year, birth place, industry, gender, profession, and continent information corresponding to 100 random famous people spanning across all time periods. Furthermore, I created a little over 30 questions that the model can ask as well as the corresponding SQL queries for each question. During each game for the simulation, the user will randomly pick a person for the model to guess and the model picks from a list of these questions to ask. Then, the query corresponding to this question is used to extract the truth value of the question from the database (Yes, No, Unknown). This answer is used as the response to simulate a real person giving that answer through user input. Now that the code has been written to interact with the database, the model can now fully create the observation at any point, which is the input vector to the DRQN. Next, I will hardcode the sample rewards as well as the rules of the game (maximum 20 questions, rewards for winning/losing/wrong guess, terminating game, etc.). This week I will be focusing on getting the simulation to run end-to-end, use tensorflow-gpu, and do hyperparameter tuning.</p></div>
    </content>
    <updated>2018-05-02T06:38:52Z</updated>
    <category term="Uncategorized"/>
    <author>
      <name>ananthgo</name>
    </author>
    <source>
      <id>https://deeplearningturingtest.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://deeplearningturingtest.wordpress.com/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://deeplearningturingtest.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://deeplearningturingtest.wordpress.com/osd.xml" rel="search" title="NLP Capstone Project Updates - Ananth" type="application/opensearchdescription+xml"/>
      <link href="https://deeplearningturingtest.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <title>NLP Capstone Project Updates – Ananth</title>
      <updated>2018-05-15T04:00:27Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-US">
    <id>http://cse481n-capstone.azurewebsites.net/?p=64</id>
    <link href="http://cse481n-capstone.azurewebsites.net/2018/05/01/advanced-attempt-i/" rel="alternate" type="text/html"/>
    <title>Advanced Attempt I</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Data Collection: We have made a lot of progress increasing our data quality since the last blog post. We have fine-tuned our filtering parameters and experimented with a few different definitions for set similarity. On top of Jaccard Index, we tried Dice Index and Cosine Similarity. We found that depending on the threshold, these different … <a class="more-link" href="http://cse481n-capstone.azurewebsites.net/2018/05/01/advanced-attempt-i/">Continue reading<span class="screen-reader-text"> "Advanced Attempt I"</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h3><b>Data Collection: </b></h3>
<p><span style="font-weight: 400;">We have made a lot of progress increasing our data quality since the last blog post. We have fine-tuned our filtering parameters and experimented with a few different definitions for set similarity. On top of Jaccard Index, we tried Dice Index and Cosine Similarity. We found that depending on the threshold, these different methods gave very similar results, but Dice Index seemed to provide the highest quality sentences while being more tolerant of long sentences (unlike Jaccard, which favored short sentences). Although it’s very picky, we’re certain that due to the huge amount of raw Reddit data we have we can still get a dataset big enough to train our complex neural nets.</span></p>
<p><span style="font-weight: 400;">As an example of our improvement, consider this example from the last post:</span></p>
<pre><span style="font-weight: 400;">MeanJokes Post: “Don’t be offended but Fuck you”
</span>Similar Post: “fuck Foligno”
Similar Post: “fuck narek”
Similar Post: “fuck”
Similar Post: “Fuck me?”
Similar Post: “Fuck me”
Similar Post: “fuck me”
Similar Post: “Fuck it”
Similar Post: “Fuck”
Similar Post: “Who the fuck are you?”</pre>
<p><span style="font-weight: 400;">Now our output would look like:</span></p>
<pre><span style="font-weight: 400;">MeanJokes Post: Don't be offended but Fuck you
</span>Similar Post: why the fuck does he have to talk in a screaming voice
Similar Post 171137: "Officer, I have no idea what in the fuck you're talking about.
Similar Post 92163: Or maybe you just fuck me in public for all too see.
Similar Post 18052: "you know, I'm finally happy". UGH, fuck off.
Similar Post 2567: So reddit, that's my fuck up. Any advice if any of you are in HR?
Similar Post 160778: Now I'm questining what numbers are real and what was put down to fuck with me and what's serious.
Similar Post 210956: And when i ask him about it, he cusses me out (tells me to fuck off) and i just die/break down internally.</pre>
<p><span style="font-weight: 400;">As well, since Dice is so picky and because the MeanJokes set tends to have a very particular structure to all its posts, we are also adding in some other obviously offensive posts to use for our set similarity step. We’re using a hate speech lexicon developed by Tom Davidson (linked below) to extract hateful posts from the general Reddit set. We will concatenate this with the MeanJokes set before running Set Similarity against all of the posts again, hopefully giving us a wider range of language structure for our dataset. </span></p>
<p><span style="font-weight: 400;">Our final improvement was discovering that a handful of subreddits contribute a majority of the noise in our data. This noise is mostly of two varieties: 1. Personal ads for intimate encounters and 2. Trading requests, for both physical and virtual items. A handful of these subreddits are very activate and are surprisingly a large chunk of Reddit’s posts, although none of them ever get nearly enough upvotes to be noticed by the average user. </span></p>
<p><span style="font-weight: 400;">So in order to combat having a lot of posts of this sort in our dataset:</span></p>
<p><img alt="" class="alignnone wp-image-65" height="144" src="http://cse481n-capstone.azurewebsites.net/wp-content/uploads/2018/05/Picture1-300x110.png" width="393"/></p>
<p><span style="font-weight: 400;">We have put together a blacklist of subs and filtered them out of the posts we consider for set similarity.</span></p>
<table style="height: 620px;" width="414">
<tbody>
<tr>
<td><span style="font-weight: 400;">100k posts</span></td>
<td/>
<td/>
<td/>
</tr>
<tr>
<td><span style="font-weight: 400;">Top 10 Black List</span></td>
<td/>
<td><span style="font-weight: 400;">Top 10 White List</span></td>
<td/>
</tr>
<tr>
<td><span style="font-weight: 400;">RocketLeagueExchange’</span></td>
<td><span style="font-weight: 400;">1860</span></td>
<td><span style="font-weight: 400;">AskReddit’</span></td>
<td><span style="font-weight: 400;">5978</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">A5XHE’</span></td>
<td><span style="font-weight: 400;">1373</span></td>
<td><span style="font-weight: 400;">Showerthoughts’</span></td>
<td><span style="font-weight: 400;">1709</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dirtykikpals’</span></td>
<td><span style="font-weight: 400;">1128</span></td>
<td><span style="font-weight: 400;">The_Donald’</span></td>
<td><span style="font-weight: 400;">850</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dirtypenpals’</span></td>
<td><span style="font-weight: 400;">870</span></td>
<td><span style="font-weight: 400;">teenagers’</span></td>
<td><span style="font-weight: 400;">720</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">DirtySnapchat’</span></td>
<td><span style="font-weight: 400;">792</span></td>
<td><span style="font-weight: 400;">GlobalOffensiveTrade’</span></td>
<td><span style="font-weight: 400;">681</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dirtyr4r’</span></td>
<td><span style="font-weight: 400;">438</span></td>
<td><span style="font-weight: 400;">Bitcoin’</span></td>
<td><span style="font-weight: 400;">651</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">AppNana’</span></td>
<td><span style="font-weight: 400;">372</span></td>
<td><span style="font-weight: 400;">relationships’</span></td>
<td><span style="font-weight: 400;">586</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Roleplaykik’</span></td>
<td><span style="font-weight: 400;">368</span></td>
<td><span style="font-weight: 400;">FIFA’</span></td>
<td><span style="font-weight: 400;">558</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">buildapc’</span></td>
<td><span style="font-weight: 400;">364</span></td>
<td><span style="font-weight: 400;">explainlikeimfive’</span></td>
<td><span style="font-weight: 400;">500</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">AgeplayPenPals’</span></td>
<td><span style="font-weight: 400;">329</span></td>
<td><span style="font-weight: 400;">Fireteams’</span></td>
<td><span style="font-weight: 400;">469</span></td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;"><br/>
Running the filter on 100k posts, we can see that most of the most common subreddits that remained are conversational in nature, while those that were removed would not make very useful sentences.</span></p>
<p> </p>
<h3><b>Advanced Model Attempt: </b></h3>
<h4><span style="font-weight: 400;">Combining Datasets: </span></h4>
<p><span style="font-weight: 400;">In our last blog post, we mentioned our concern about the small size of </span><span style="font-weight: 400;">Waseem’s twitter dataset</span><span style="font-weight: 400;">. This week, we combined that dataset with another twitter hate speech dataset made by Thomas Davidson. The Davidson dataset contains 24,802 labeled tweets. Each tweet is coded by at least 3 CrowdFlower users. Each row contains 5 columns:</span></p>
<table style="height: 336px;" width="584">
<tbody>
<tr>
<td>count</td>
<td>number of CrowdFlower users who coded each tweet (min is 3, sometimes more users coded a tweet when judgments were determined to be unreliable by CF).</td>
</tr>
<tr>
<td>hate_speech</td>
<td>number of CF users who judged the tweet to be hate speech.</td>
</tr>
<tr>
<td>offensive_language</td>
<td>number of CF users who judged the tweet to be offensive.</td>
</tr>
<tr>
<td>neither</td>
<td>number of CF users who judged the tweet to be neither offensive nor non-offensive.</td>
</tr>
<tr>
<td>class</td>
<td>class label for majority of CF users. 0 – hate speech 1 – offensive language 2 – neither</td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;">Davidson et. al. used the following definition for hate speech: language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group. According to the paper, </span><span style="font-weight: 400;">“only 5% of tweets were coded by the majority of coders”</span><span style="font-weight: 400;">. If we directly combine Waseem Data with this we might get a even more skewed class distribution (31% ‘hate’, 69% ‘none’). Therefore, we decided to change the class labels of Davidson a little bit: if all CF users unanimously coded a tweet hate_speech or offensive_language, the tweet would be labeled ‘hate’; otherwise, the tweet would be labeled ‘none’. The modified Davidson dataset has a class distribution of 76% ‘hate’ and 24% ‘none’. Then we combined these two datasets (removed duplicate tweets if there are any). The new combined dataset has 40,509 tweets and a class distribution of 59% ‘hate’ and 41% ‘none. The combined dataset is much larger than the altered Waseem dataset (~15k tweets) and the labels are more balanced. </span></p>
<p><span style="font-weight: 400;">We do have the concern whether this more these more generously labeled ‘hate’ tweets are noisy. However, because the Waseem dataset is also more generous to ‘none’ labels (as long as the tweet is neither racist or sexist), we believe they would have some counter effect on each other. After all, data noise is very unlikely to be completely removed. </span></p>
<h4><span style="font-weight: 400;">Preprocessing: </span></h4>
<p><span style="font-weight: 400;">Since the model we tried requires each sentence to have at least 4 tokens, we decided to ignore sentences with less than 4 tokens after pre-processing.</span></p>
<h4><span style="font-weight: 400;">The effectiveness of Combined Dataset:</span></h4>
<p><span style="font-weight: 400;">To illustrate the effectiveness of the combined dataset, we chose the best NN model set up from baseline II to train on Waseem dataset and combined dataset separately and evaluated the two trained models on Waseem dev data. We decided not to evaluate on test data yet because we don’t want any leaked info from test.</span></p>
<p><span style="font-weight: 400;">Set up — embedding: 50 dimensional glove twitter embeddings, encoder: 1 layer GRU</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Trained on Waseem Dataset, epoch chosen: 13</span></li>
</ul>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Waseem-Dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy </span></td>
<td><span style="font-weight: 400;">0.8235</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8022</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7876</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.7940</span></td>
</tr>
</tbody>
</table>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Trained on Combined Dataset, epoch chosen: 16</span></li>
</ul>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Waseem-Dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy </span></td>
<td><span style="font-weight: 400;">0.8152</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.7979</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7672</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.7788</span></td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;">Although the two models had the same setup, the one trained on the combined dataset got performance close to the one trained on the original Waseem dataset despite the fact that we now have really different class distributions in the two datasets. </span></p>
<h4><span style="font-weight: 400;">Retrain Some Baseline Models on Combined Dataset:</span></h4>
<p><span style="font-weight: 400;">Here we retained some baseline models with different set ups on the combined dataset and evaluated them on both Waseem dev data and combined dev data.</span></p>
<ul>
<li>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Model1 — embedding: 50 dimensional glove twitter embeddings, encoder: 1 layer GRU, epoch chosen: 16</span><br/>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Combined-dev</span></td>
<td><span style="font-weight: 400;">Waseem-dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8665</span></td>
<td><span style="font-weight: 400;">0.8152</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8614</span></td>
<td><span style="font-weight: 400;">0.7979</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.8628</span></td>
<td><span style="font-weight: 400;">0.7672</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.8621</span></td>
<td><span style="color: #ff0000;">0.7788</span></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Model2 — embedding: 50 dimensional glove twitter embeddings, encoder: 1 layer LSTM, epoch chosen: 19</span><br/>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Combined-dev</span></td>
<td><span style="font-weight: 400;">Waseem-dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8625</span></td>
<td><span style="font-weight: 400;">0.8091</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8577</span></td>
<td><span style="font-weight: 400;">0.7875</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.8578</span></td>
<td><span style="font-weight: 400;">0.7648</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.8578</span></td>
<td><span style="color: #ff0000;">0.7739</span></td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;"> Model3 — embedding: 50 dimensional glove twitter embeddings, encoder: 1 layer BiGRU, epoch chosen: 16</span></p></li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li style="font-weight: 400;">
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Combined-dev</span></td>
<td><span style="font-weight: 400;">Waseem-dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8618</span></td>
<td><span style="font-weight: 400;">0.8104</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8567</span></td>
<td><span style="font-weight: 400;">0.7916</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.8575</span></td>
<td><span style="font-weight: 400;">0.7620</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.8571</span></td>
<td><span style="color: #ff0000;">0.7732</span></td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;">Model4 — embedding: 100 dimensional glove twitter embeddings, encoder: 1 layer GRU, epoch chosen: 11</span></p></li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li style="font-weight: 400;">
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Combined-dev</span></td>
<td><span style="font-weight: 400;">Waseem-dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8651</span></td>
<td><span style="font-weight: 400;">0.8194</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8605</span></td>
<td><span style="font-weight: 400;">0.7971</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.8603</span></td>
<td><span style="font-weight: 400;">0.7834</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.8604</span></td>
<td><span style="color: #ff0000;">0.7894</span></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h4><span style="font-weight: 400;">Model:</span></h4>
<p><span style="font-weight: 400;">Our first Advanced model will be a CNN model.</span></p>
<h5><span style="font-weight: 400;">The intuition of choosing this model:</span></h5>
<p><span style="font-weight: 400;">CNN provides us a convenient way to extract the most important information within the given fragment of a sentence through filters and max pooling. We found it might be a worth trying model on our task.</span></p>
<p><span style="font-weight: 400;">Our model looks like:</span></p>
<p><img alt="" class="alignnone wp-image-67" height="158" src="http://cse481n-capstone.azurewebsites.net/wp-content/uploads/2018/05/Picture2-300x116.png" width="409"/></p>
<pre><span style="font-weight: 400;">Image credit:</span><span style="font-weight: 400;">Gambäck, B., &amp; Sikdar, U.K. (2017). Using Convolutional Neural Networks to Classify Hate-Speech.</span></pre>
<ul>
<li>
<ul>
<li>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">Preprocess all words and encode them using pretrained glove embeddings.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Feed result into a convolution neural network, taking 2, 3 and 4-grams into consideration. Output dimension is 28, 26 for English alphabets, 1 for digits and 1 for all other symbols. </span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Feed result into a 2-layer feed-forward neural net, with dimension (28, 2)  and dropout (0.3, 0.3)</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Softmax on the result and pick the major class</span></li>
</ol>
</li>
</ul>
</li>
</ul>
<p><span style="font-weight: 400;">With not much tuning, here’s what our best model looks like:</span></p>
<ul>
<li>
<ul>
<li>
<ul>
<li><span style="font-weight: 400;">200 dimension embedding, filters=100, trained on Waseem twitter dataset</span></li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Waseem dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.79169</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.78274</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.80086</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.82142</span></td>
</tr>
</tbody>
</table>
<ul>
<li>
<ul>
<li>
<ul>
<li><span style="font-weight: 400;">200 dimension embedding, filters=100, trained on the combined dataset</span></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><span style="color: #ff0000;">*revised, due to an imperfection in the combined dataset, there was a mistake in numbers</span></p>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">combined dev</span></td>
<td><span style="font-weight: 400;">Waseem dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.85983</span></td>
<td><span style="color: #ff0000;">0.77451</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.86029</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.76156</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.85937</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.78791</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.86437</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.80837</span></td>
</tr>
</tbody>
</table>
<p><del><span style="font-weight: 400;">With no doubt, our combined dataset provides a huge boost on performance on original Waseem twitter dataset.</span></del></p>
<p><span style="color: #ff0000;">From the above results, it seems CNN hasn’t show an improvement on our job. We think doing more hyper parameter tuning should give us some improvement. Furthermore, we would like to incorporate Elmo to see if that will help us our not.</span></p>
<p><del><span style="font-weight: 400;">However, we do have some concern about our models: almost all of the best models we have with a large number of filters have their best epoch generally to be the first few epochs. We are a little bit concerned about that since that may be a sign of overfitting.</span></del></p>
<p><span style="color: #ff0000;">Since our result hasn’t show any improvement, we think it’s more appropriate to do error analysis once we gain some improvement.</span></p>
<p><del><span style="font-weight: 400;">Therefore, before we start to do any error analysis, we would like to do a little bit more hyperparameters since we haven’t really try different drop out rate or other output dimension values other than the one specified in the paper we referenced.</span></del></p>
<h3><span style="font-weight: 400;">Next Step:</span></h3>
<p><span style="font-weight: 400;">First, we will dig deeper on the model we have right now. We will first play with its parameters and then conduct error analysis on it.</span></p>
<p><span style="font-weight: 400;">As suggested in previous blog post feedback, we would like to try Elmo and see how much can we improve with it. Furthermore, we would like to try things like character level embedding as well as another very interesting model which combines CNN with GRU to make prediction.</span></p>
<h3><span style="font-weight: 400;">Work Cited:</span></h3>
<p><a href="https://www.semanticscholar.org/paper/Hateful-Symbols-or-Hateful-People%3F-Predictive-for-Waseem-Hovy/df704cca917666dace4e42b4d3a50f65597b8f06">Waseem, Zeerak and Dirk Hovy. “Hateful Symbols or Hateful People? Predictive Features for Hate Speech Detection on Twitter.” SRW@HLT-NAACL (2016).</a></p>
<p><a href="https://www.semanticscholar.org/paper/Automated-Hate-Speech-Detection-and-the-Problem-of-Davidson-Warmsley/6ccfff0d7a10bf7046fbfd109b301323293b67da">Davidson, Thomas J et al. “Automated Hate Speech Detection and the Problem of Offensive Language.” ICWSM (2017).</a></p>
<p><a href="https://www.semanticscholar.org/paper/Using-Convolutional-Neural-Networks-to-Classify-Gamb%C3%A4ck-Sikdar/0dca29b6a5ea2fe2b6373aba9fe0ab829c06fd78">Gambäck, Björn and Utpal Kumar Sikdar. “Using Convolutional Neural Networks to Classify Hate-Speech.” (2017).</a></p>
<p> </p></div>
    </content>
    <updated>2018-05-02T06:17:57Z</updated>
    <category term="Weekly blog"/>
    <author>
      <name>Team Watch Your Language!</name>
    </author>
    <source>
      <id>http://cse481n-capstone.azurewebsites.net</id>
      <link href="http://cse481n-capstone.azurewebsites.net/feed/" rel="self" type="application/rss+xml"/>
      <link href="http://cse481n-capstone.azurewebsites.net" rel="alternate" type="text/html"/>
      <subtitle>Spring2018 CSE481N Capstone</subtitle>
      <title>Team Watch Your Language!</title>
      <updated>2018-05-15T04:00:21Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-9203775015655831448.post-3361785683406757277</id>
    <link href="https://teamoverfit.blogspot.com/2018/05/6-milestone-advanced-model-attempt-1.html" rel="alternate" type="text/html"/>
    <title>#6 Milestone: Advanced model attempt #1</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h2 style="height: 0px;"><span>Team Overfit</span></h2><h3><span><br/></span></h3><h3><span>Project repo: <span style="font-size: 18.72px;"><a href="https://github.com/pinyiw/nlpcapstone-teamoverfit">https://github.com/pinyiw/nlpcapstone-teamoverfit</a></span></span></h3><h4><span>Team members: Dawei Shen, Pinyi Wang, Xukai Liu</span></h4><div style="text-align: start; text-indent: 0px;"><div style="margin: 0px;"><div><span><b>Blog Post: #6: 05/01/2018</b></span></div><div><span><span><b><br/></b></span></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Social Media Predicts Stock Price (StartUp Mode)</span><br/><br/><span><span style="white-space: pre;">This week, we added more data source and have finer process of the data. We also convert </span></span><br/><span><span style="white-space: pre;">Keras model to Tensorflow for better future improvement.   </span></span><br/><span><span style="white-space: pre;"><br/></span></span><span><b>Keras to TensorFlow</b></span><br/><ul><li><span>We updated our code from using Keras to Tensorflow which helps to do more improvement on model. For example, TensorFlow is a lower level library which allow us to have more control over the variables we used as the input and output. For example, if we want to try with more complicated input with adding the voerall market stock price and the competitors' stock prices, TensorFlow will be more helpful.</span></li></ul><div><span><b>Add One More Target Company: Tesla</b></span></div><div><ul><li><span>As there are too many Tweets that have tagged #Apple but are unrelated to the company Apple, we need to filter out such tweets. However, if we apply the model on the company Tesla, who's company name is uniquer than 'Apple' and has its products naming closer to its company name, the Tweets and news that have tagged #Tesla will contain much less noisy information and thus improve the prediction to its stock price.</span></li></ul><div><span><b>Try Out Different Layers Structure to Tune LSTM</b></span></div></div><div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><ul><span id="docs-internal-guid-1d495372-1f45-7a06-476d-fd5b4661d619"><li><span><span style="white-space: pre-wrap;">Add the NASDAQ index to the input</span></span></li><ul><li><span><span style="white-space: pre-wrap;">The composition of the NASDAQ Composite is heavily weighted towards information technology companies. Therefore, company Apple’s and Tesla’s stock prices may be influenced by the Nasdaq index.</span></span></li></ul><li><span><span style="white-space: pre-wrap;">Add a 'STAY' category as the output prediction of stock price</span></span></li><ul><li><span><span>If the change of the stock price for the next day is within 1%, we will mark the stock price of that day as a ‘STAY’. Otherwise, we mark it as ‘UP’ or ‘DOWN’</span></span></li></ul><li><span><span style="white-space: pre-wrap;">Lemmatization &amp; Stemming</span></span></li><ul><li><span><span style="white-space: pre-wrap;">Lemmatization and stemming help collect the same words with different tenses together, which reduce the total vocabulary size.</span></span></li></ul></span></ul><div><span id="docs-internal-guid-1d495372-1f45-7a06-476d-fd5b4661d619"><span><span style="white-space: pre-wrap;"><b>Update Of Evaluation Plan</b></span></span></span><br/><span><span style="white-space: pre-wrap;"><b><br/></b></span></span></div><div><span id="docs-internal-guid-1d495372-1f45-7a06-476d-fd5b4661d619"><span><span style="white-space: pre-wrap;"><b>Results &amp; Error Analysis</b></span></span></span></div><div><ul><span id="docs-internal-guid-1d495372-1f45-7a06-476d-fd5b4661d619"><li><span><span style="white-space: pre-wrap;">After we have improved the model and the training process, the prediction accuracy for Apple will be above 85% if we choose '<i>+/-1% change of the stock price</i>' as 'STAY'.</span></span></li><li><span><span style="white-space: pre-wrap;">The prediction accuracy for Apple will be above 60% if we choose '<i>+/-1% change of the stock price</i>' as 'STAY'.</span></span></li></span></ul></div><div><span id="docs-internal-guid-1d495372-1f45-7a06-476d-fd5b4661d619"><span><span style="white-space: pre-wrap;"><b>What To Investigate For The Next Week</b></span></span></span></div><div><ul><span id="docs-internal-guid-1d495372-1f45-7a06-476d-fd5b4661d619"><li><span><span style="white-space: pre-wrap;">Apply F1 scores. For the evaluation ,we would like to know:</span></span></li><ul><li><span><span style="white-space: pre-wrap;">The rate of stocks are marked 'UP/DOWN/STAY' that are predicted correctly as 'UP/DOWN/STAY' separately.</span></span></li><li><span><span style="white-space: pre-wrap;">The rate of stocks are marked 'UP/DOWN/STAY' that are predicted wrongly as 'UP/DOWN/STAY' separately.</span></span></li></ul><li><span><span style="white-space: pre-wrap;">Add competitors' stock prices to the input</span></span></li></span></ul></div><div/></div></div></div></div></div></div>
    </summary>
    <updated>2018-05-02T05:53:00Z</updated>
    <author>
      <name>Team Overfit</name>
      <email>noreply@blogger.com</email>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-9203775015655831448</id>
      <author>
        <name>Team Overfit</name>
        <email>noreply@blogger.com</email>
      </author>
      <link href="https://teamoverfit.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="https://teamoverfit.blogspot.com/feeds/posts/default?alt=rss" rel="self" type="application/rss+xml"/>
      <title>NLP Capstone</title>
      <updated>2018-05-15T04:00:30Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/e05ee9a7eaa8</id>
    <link href="https://medium.com/@hongnin1/image-captioning-model-advanced-model-attempt-1-e05ee9a7eaa8?source=rss-c450eb982161------2" rel="alternate" type="text/html"/>
    <title>Image Captioning Model: Advanced model attempt #1</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>To recap, this is our baseline approach:</p><p><a href="https://medium.com/@hongnin1/image-annotation-model-baseline-dataset-and-evaluation-framework-d1d1b2d1f34c">Image Annotation Model Baseline, Dataset and Evaluation Framework</a></p><p>For the past week, we have been trying to improve our model’s performance from two different aspect: training speed and model accuracy. In order to improve speed, we further investigated in TensorFlow’s API. We realized that the bottleneck of our model’s performance is in extracting and batching our data. After some research, we have decided to try tf.record (API: <a href="https://www.tensorflow.org/programmers_guide/datasets#consuming_tfrecord_data">https://www.tensorflow.org/programmers_guide/datasets#consuming_tfrecord_data</a>). We are working on using tf.record and tf.dataset to prepare and feed our data as proposed in the link, and we are hoping to see a performance increase (fingers crossed).</p><p>In order to improve model accuracy, we mentioned in previous post that we are working towards finding the right way to calculate attention weights. The APIs we have tried are: <a href="https://www.tensorflow.org/api_docs/python/tf/contrib/seq2seq/BahdanauAttention">https://www.tensorflow.org/api_docs/python/tf/contrib/seq2seq/BahdanauAttention</a> and <a href="https://www.tensorflow.org/programmers_guide/datasets#consuming_tfrecord_data">https://www.tensorflow.org/programmers_guide/datasets#consuming_tfrecord_data</a>, however the way they are calculating attention weights do not align with what the paper did, so we are considering implementing our own small neural network to extract attention weights, but it will take a while. Our teammates are currently working on developing our own neural network for this week and see if it will work. It’s a trail and error process so it might take some time.</p><p>In terms of the model itself, we have previously implemented InceptionNet as our CNN encoder. However we encountered the same problem as we had for calculating attention weights, this InceptionNet is a different implementation from the paper we are basing our model on, so we decided to switch to VGG. We are still trying to find a suitable VGG16 (CNN) implementation with checkpoint and this is what we are currently considering: <a href="https://github.com/machrisaa/tensorflow-vgg">https://github.com/machrisaa/tensorflow-vgg</a></p><p>Overall speaking, our baseline model has a lot of problems we have been fixing for the past week in terms of training speed and attention visualization. Also changing our neural network for CNN encoder is taking a large chunk of our time as well. We are hoping to fix these problems but it might take a while for us to figure out the best approach. We are trying our best and hopefully come up with an even more advanced model sometime soon.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e05ee9a7eaa8" width="1"/></div>
    </content>
    <updated>2018-05-02T04:26:35Z</updated>
    <category term="machine-learning"/>
    <author>
      <name>Ning Hong</name>
    </author>
    <source>
      <id>https://medium.com/@hongnin1?source=rss-c450eb982161------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/0*d6QC_ngideag3rTN.</logo>
      <link href="https://medium.com/@hongnin1?source=rss-c450eb982161------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@hongnin1" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Ning Hong on Medium</subtitle>
      <title>Stories by Ning Hong on Medium</title>
      <updated>2018-05-15T04:00:07Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-5600014144802012716.post-7248717662742163548</id>
    <link href="https://nlpcapstonesemparse.blogspot.com/2018/05/advanced-model-attempt-one.html" rel="alternate" type="text/html"/>
    <title>Advanced model attempt one</title>
    <summary>I fixed the performance issues, and I have been working on adding enhancements to the model such as restricting the action space, by only allowing the model to generate types from the class, as well as debugging it to improve accuracy. The results are: 7.7 EM and 22.1 Bleu.</summary>
    <updated>2018-05-01T15:57:00Z</updated>
    <author>
      <name>nlpcapstone</name>
      <email>noreply@blogger.com</email>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-5600014144802012716</id>
      <author>
        <name>nlpcapstone</name>
        <email>noreply@blogger.com</email>
      </author>
      <link href="https://nlpcapstonesemparse.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="https://nlpcapstonesemparse.blogspot.com/feeds/posts/default?alt=rss" rel="self" type="application/rss+xml"/>
      <title>NlpCapstone</title>
      <updated>2018-05-15T04:00:05Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/e7e525549f94</id>
    <link href="https://medium.com/@ryanp97/fully-featured-model-results-and-more-ideas-for-evaluation-e7e525549f94?source=rss-6378d85d3a9b------2" rel="alternate" type="text/html"/>
    <title>Fully-featured Model Results and More Ideas for Evaluation</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>In the past week, I’ve been working on training a fully-featured baseline model as well as a large, fully-featured model. This post will cover the results from these two models as well as a comparison between the featureless model.</p><p>Additionally, in the past week Jan, Michael, and I have been discussing different metrics for evaluating graphs. Based on this, the project may pivot away from building more complex models for the semantic transfer task to focus on exploring new and novel techniques for evaluation.</p><p>So in the coming week, I’ll be continuing to explore with slightly larger models as well as exploring different evaluation techniques.</p><h4>Fully-featured Model Results</h4><p>To be expected, evaluating the fully-featured model is not as simple as running SMATCH and taking the F1 score at face value. After expanding the model’s predictions, the baseline model received an F1 score of 0.77, with all features included. As mentioned in the previous post, this score is inflated since SMATCH equally weights predicate and feature accurate despite features generally being easier to predict compared to predicates or arguments.</p><p>Considering this, I stripped away all features from the predictions except for tense and mood and evaluated the model again. Note the only thing that has changed is an extra post-processing step has been added to the same model and the same predictions. This change resulted in a SMATCH score of 0.65. From here, I removed all features from the predictions and re-ran SMATCH and got an F1 score of 0.63. It seems that we are able to train a model using data with squashed features with little to no risk of performance loss.</p><p>For recap, here is a small table with the results so far.</p><pre>Fully-featured (all)          -  0.77<br/>Fully-featured (tense, mood)  -  0.65<br/>Fully-featured (none)         -  0.63</pre><pre>Featureless (baseline)        -  0.65</pre><p>As a side note: I also attempted to train a larger model with 600 embedding size, 750 hidden size, 3 encoder and decoder layers. This, however, resulted in extreme overfitting. The model predictions (without features) received an abysmal F1 of 0.32. In an effort to not go as crazy with the parameters while making the model larger to account for adding extra information in the input, I’m training a model with 600 hidden size and 3 layers and reverting back to a 500 embedding size.</p><h4>Other Ideas for Evaluation Exploration</h4><p>As mentioned earlier in this post, an issue with SMATCH is that it weights predicates, arguments, and features all equally when features are significantly easier to predict. To address this, Jan, Michael, and I have discussed some different evaluation ideas that we might want to explore.</p><p>The first idea is to separate the predicates from the features and calculate precision and recall on just the predicates. We can also further divide the predicates into surface predicates and abstract predicates (abstract predicates often have the _ prefix). This allows us to get a more detailed insight on the model’s ability to predict predicates that SMATCH has issues revealing.</p><p>A second idea is to replace all predicted features with some dummy feature so that we can upper bound the score when features are being predicted. By doing this, we can get a more accurate gauge of how well the model is predicting features.</p><p>Finally, the third idea is to eventually do something similar to this <a href="https://github.com/mdtux89/amr-evaluation">AMR evaluator</a>. It computes SMATCH and F-scores on various different versions of the predictions by selectively cleaning up portions that are not useful to a specific metric. This would be an interesting idea and an interesting thing to reimplement/repurpose for the use of DMRS graphs.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e7e525549f94" width="1"/></div>
    </content>
    <updated>2018-05-01T07:10:59Z</updated>
    <category term="machine-learning"/>
    <author>
      <name>Ryan Pham</name>
    </author>
    <source>
      <id>https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*83KfTWByl5pPq7A8_E8ApA.gif</logo>
      <link href="https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@ryanp97" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Ryan Pham on Medium</subtitle>
      <title>Stories by Ryan Pham on Medium</title>
      <updated>2018-05-15T04:00:06Z</updated>
    </source>
  </entry>

  <entry>
    <id>http://sarahyu.weebly.com/cse-481n/advanced-model-attempt-1</id>
    <link href="http://sarahyu.weebly.com/cse-481n/advanced-model-attempt-1" rel="alternate" type="text/html"/>
    <title>Advanced Model Attempt #1 (Act 1)</title>
    <summary>The first part of implementing my advanced model attempt was to work on implementing the IDP Algorithm presented in  Monroe, B. L., Colaresi, M. P., &amp; Quinn, K. M. (2008). Fightin' words: Lexical feature selection and evaluation for identifying the content of political conflict. Political Analysis, 16(4), 372-403. In doing so, I was able to find the weighted log odds ratio of each word present in both ND and NT posts, ultimately showing which type of subreddit each w [...]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><div class="paragraph">The first part of implementing my advanced model attempt was to work on implementing the IDP Algorithm presented in  Monroe, B. L., Colaresi, M. P., &amp; Quinn, K. M. (2008). <em>Fightin' words: Lexical feature selection and evaluation for identifying the content of political conflict. </em><font size="2">Political Analysis, 16(4), 372-403. </font><br/><br/>In doing so, I was able to find the weighted log odds ratio of each word present in both ND and NT posts, ultimately showing which type of subreddit each word was 'more affiliated' with. The findings were as one might expect, especially with my previous baselines and were in line with the results from those. As seen below we see some familiar words within the ND (I, you, <strong>she</strong>​) and NT (http) - so sorry for the ugly terminal output, but I need to find a prettier CSV presentation:</div>  <div><div class="wsite-multicol"><div class="wsite-multicol-table-wrap"> 	<table class="wsite-multicol-table"> 		<tbody class="wsite-multicol-tbody"> 			<tr class="wsite-multicol-tr"> 				<td class="wsite-multicol-col" style="width: 50%; padding: 0 15px;"> 					 						  <div><div class="wsite-image wsite-image-border-none " style="padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;"> <a> <img alt="Picture" src="http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-05-02-at-12-42-36-am_orig.png" style="width: auto;"/> </a> <div style="display: block; font-size: 90%;"/> </div></div>   					 				</td>				<td class="wsite-multicol-col" style="width: 50%; padding: 0 15px;"> 					 						  <div><div class="wsite-image wsite-image-border-none " style="padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;"> <a> <img alt="Picture" src="http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-05-02-at-12-43-09-am_orig.png" style="width: auto;"/> </a> <div style="display: block; font-size: 90%;"/> </div></div>   					 				</td>			</tr> 		</tbody> 	</table> </div></div></div>  <div class="paragraph">This was a good first step, and will need some more work hashing out some final implementation details, but my next step in making this an actual advanced model, is to now utilize some of that reddit data that I've been harvesting for the past week or so. With that, we have a lot more data and might need to make some changes on the subreddit subsets depending on how the data has developed (changes in sentence length and number of total number of posts in each subreddit). Off to more data!!!</div></div>
    </content>
    <updated>2018-05-01T07:00:00Z</updated>
    <category term="Uncategorized"/>
    <source>
      <id>http://sarahyu.weebly.com/cse-481n</id>
      <author>
        <name>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde</name>
      </author>
      <link href="http://sarahyu.weebly.com/cse-481n" rel="alternate" type="text/html"/>
      <link href="http://sarahyu.weebly.com/6/feed" rel="self" type="application/rss+xml"/>
      <subtitle>CSE 481N</subtitle>
      <title>Sarah yu - CSE 481N</title>
      <updated>2018-05-09T17:30:11Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://deeplearningturingtest.wordpress.com/?p=18</id>
    <link href="https://deeplearningturingtest.wordpress.com/2018/04/26/strawman-baseline-2-same-drqn-model-with-a-different-policy/" rel="alternate" type="text/html"/>
    <title>Strawman/Baseline 2: Same DRQN Model with a Different Policy</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">I decided to narrow the scope of my problem by changing the types of questions asked to the user to be only yes/no questions. This simplifies interpreting the user response into a classification task. More specifically, the questions will be about figuring out the attributes of any entities brought up in the text.  Therefore, I … <a class="more-link" href="https://deeplearningturingtest.wordpress.com/2018/04/26/strawman-baseline-2-same-drqn-model-with-a-different-policy/">Continue reading <span class="screen-reader-text">Strawman/Baseline 2: Same DRQN Model with a Different Policy</span> <span class="meta-nav">→</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>I decided to narrow the scope of my problem by changing the types of questions asked to the user to be only yes/no questions. This simplifies interpreting the user response into a classification task. More specifically, the questions will be about figuring out the attributes of any entities brought up in the text.  Therefore, I will use a relational database to store the accumulated entity-attribute relationships instead of a semantic network since it will be easier to extract quantifiable features by performing specific queries. In addition to asking the user questions, I decided to involve database queries in the training process. This way the model can query the database about any inferences or guesses it has about the attributes of an entity, and the database can return a list of entities that fit the hypothesis. Then, the model is given a reward based on how much it was able to narrow down the list of entities. This allows the model to get frequent reward signals from the database to speed up training.</p>
<p>Because of this change, my model architecture has also changed. The DRQN will now take as inputs the action from the previous time step (one-hot vector), the user response (word embeddings passed through CNN), and the database response (number of entities the previous query narrowed it down to). In addition, the outputs to the LSTM at each time step will feed into A+1 policy networks where A = number of attributes. The first A policy networks are needed because the model needs to learn how to guess each attribute independently. The last policy network determines which question the model will ask the user. So far I have implemented most of this architecture but still need to add in the policy networks and debug.</p>
<p>Finally, I will implement a question simulator to randomly pick an entity and have the model guess what it is, similar to 20 questions. During this simulation, rewards will be automatically given every time the model queries the database and whenever the game ends (win or loss). Furthermore, a small penalty is given for a wrong guess. By implementing this simulator, the need for user input to give rewards is eliminated and this should completely automate and greatly speed up training.</p>
<p>My goal for next week is to finish implementing and debugging the model to start this training simulation.</p></div>
    </content>
    <updated>2018-04-26T06:58:22Z</updated>
    <category term="Uncategorized"/>
    <author>
      <name>ananthgo</name>
    </author>
    <source>
      <id>https://deeplearningturingtest.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://deeplearningturingtest.wordpress.com/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://deeplearningturingtest.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://deeplearningturingtest.wordpress.com/osd.xml" rel="search" title="NLP Capstone Project Updates - Ananth" type="application/opensearchdescription+xml"/>
      <link href="https://deeplearningturingtest.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <title>NLP Capstone Project Updates – Ananth</title>
      <updated>2018-05-15T04:00:27Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/306dca636d3a</id>
    <link href="https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone | 05: Experimenting</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><em>previous posts: </em><a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5"><em>01</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5\"><em>02</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3"><em>03</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7"><em>04</em></a></p><p>Hi! Here’s what I’ve been up to in the past week.</p><h4>Progress on the TensorBoard Plugin</h4><p>Real data collection and the backend are functioning!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*l6M8uMcswVoaEtL0_HGt0w.png"/>Architecture of the Attention Plugin.</figure><p>At this point last week, I had implemented the nodes in green above. These were the operators / functions required to produce Summary protobufs that are in turn saved to disk.</p><p>This week, I completed a number of tasks to produce a bare-bones functioning plugin (sans visualizations).</p><p>First, I modified the source code for <a href="https://github.com/abisee/pointer-generator">See et al.’s (2017) attentional models</a> to use the Attention Plugin API to save input text, output text, and attention distributions during evaluation.</p><p>Next, I implemented the Attention Plugin’s back-end, which is used to fulfill requests made by the front-end. This service currently offers two services:</p><ol><li>tags This route returns all tags associated for each run in the log. This should include 3 tags for each run: one for each of the input, output, and attention tensors.</li><li>attention This route returns a list values associated with the given tag (including time and step stamps). This can be used by the front-end to acquire each of the input, output, and attention lists (converted from tensors) by passing the corresponding tag (retrieved using the tags route).</li></ol><p>Finally, as a proof of concept, I modified the front-end provided in the <a href="https://github.com/tensorflow/tensorboard-plugin-example">TensorBoard Plugin Example</a> to consume this back-end, showing it is able to retrieve summaries. Now we just need some visualizations to consume the data!</p><h4>Visualization Prototyping Begins</h4><p>While data collection and back-end development has been wrapping up, I’ve begun to prototype static visualizations for the plugin. To do this, I used data produced by <a href="https://github.com/abisee/pointer-generator">See et al.’s (2017) pre-trained attentional models</a> (produced only at decode time without the Attention Plugin). Through this process, I hope to gain two things in particular.</p><ol><li>A idea of what will/won’t work as visualizations for summarization tasks.</li><li><strong>A better understanding of the behavior of attentive models</strong>, and through that a better idea of how static and/or interactive visualizations can further interpretability and understanding.</li></ol><p>The first idea I decided to pursue was that of a <strong>condensed heat-map</strong>. You may recall the conventional heat-map used for attention visualizations described in <a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5">my first blog post</a>.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/612/1*_sq2Vy_Py7hEXp2tWBBXxg.png"/>Rikters et al. (2017). A heat-map with relatively large cells, allowing for display of text along the axes.</figure><p>The issues I noted with this visualization pattern are as follows:</p><ol><li>It is difficult to fit the words (as seen above) on the x-axis, harming readability.</li><li>This does not scale well with large input or output (e.g. summarization)</li><li>We do not read single-tokens at a time (i.e. y-axis), and input and output are generally not in this format either.</li></ol><p>To address the point (2), scalability, I decided to try producing a heat-map with no text labels, and thus each cell could be as small as a single pixel.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WOlVYgmeZ0DmutTZkDXn2g.png"/>A prototype of a condensed heat-map, where x-axis represents input and y-axis represents output.</figure><p>The color scale is a discrete scale, where each step is determined by the quantiles of the weight distribution. The x-axis represents the input text, and the y-axis represents the output text, with each cell representing the amount of attention paid for that pair (output paid to input). The good news here is that the attention distribution is relatively easy to understand at a quick glance. The downside is that cells that are not part of a larger trend (you may notice a lone red spot near the top of the heat-map, approximately a quarter of the way through the x-axis) are harder to make out, as the cells are so small. Further, the distribution is contextless — we don’t know the structure of the input text or what words these high weights are associated with. In the example above, we understand that the model focused primarily on the beginning of the article, but we can’t tell whether that is good or bad without seeing the text.</p><p>To remedy this, I decided to also display the input text, with the input text highlighted according to the maximum of the weights it received. This also solves concerns (1) and (3) for the conventional heat-map.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dJXS9s_391dACPuUwAgPmA.png"/>The input text corresponding to the heat-map above, where each token is highlighted according to its max attention weight received.</figure><p>By putting these two together (along with the output text for reference), we can gain a better understanding of how the model arrived at its summary. A viewer can now map the attention distribution shown in the heat-map to text in the input sequence by looking for patches of similar color intensity.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dMqdcl01Za5U4nYrXpye6g.png"/>A prototype static visualization including both heat-map and highlighted text.</figure><p>To get a better sense of how this visualization pattern would play out, I built a light web-page that allows users to cycle through different input / output examples. The gif below shows several of these.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*_ACE44hvUSrwfE3F04gslg.gif"/>The described visualization pattern over several input / output sequences.</figure><p>More exploration (inside and outside of this pattern) will need to occur, but this seems promising!</p><h4>What’s Next</h4><p>Lots to get done this next week. Here’s what’s in my plan:</p><ol><li>Continue working on data collection and cleaning up the TensorBoard plug-in. Move beyond the proof-of-concept front-end and show that meaningful visualizations (perhaps extremely basic ones) can be generated using the plugin back-end as a data source.</li><li>Read more into the model provided by See et al. (2017), as well as related work, to gain a better understanding of the architecture and function/behavior of attention. A closer study of the works cited in my <a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5">second blog post</a> will be a good starting point. The better I understand this mechanism the more equipped I’ll be to create meaningful visualizations.</li><li>Continue prototyping static visualizations, move on to interactive visualizations. Acquire feedback from peers for both.</li></ol><p>Thanks for reading!</p><h4>Works Cited</h4><ul><li><a href="https://arxiv.org/pdf/1704.04368.pdf">See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” <em>ACL</em> (2017).</a></li><li><a href="https://ufal.mff.cuni.cz/pbml/109/art-rikters-fishel-bojar.pdf">Rikters, Matīss, Mark Fishel, and Ondřej Bojar. “Visualizing neural machine translation attention and confidence.” <em>The Prague Bulletin of Mathematical Linguistics</em> 109.1 (2017): 39–50.</a></li></ul><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=306dca636d3a" width="1"/></div>
    </content>
    <updated>2018-04-25T06:48:23Z</updated>
    <category term="visualization"/>
    <category term="machine-learning"/>
    <category term="data-visualization"/>
    <category term="nlp"/>
    <category term="computer-science"/>
    <author>
      <name>Halden Lin</name>
    </author>
    <source>
      <id>https://medium.com/@halden.lin?source=rss-2759d54493c0------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*Hzu2ZqgloT0I1F6Kwg8OPA.jpeg</logo>
      <link href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@halden.lin" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Halden Lin on Medium</subtitle>
      <title>Stories by Halden Lin on Medium</title>
      <updated>2018-05-15T04:00:29Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/27c90aa3c1aa</id>
    <link href="https://medium.com/@be.li.nda/nlp-capstone-blog-5-more-baselines-and-error-analysis-27c90aa3c1aa?source=rss-fad49d942bf3------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone Blog #5: More Baselines and Error Analysis</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>I spent this week implementing other baselines, running last week’s neural baseline on the re-split training dataset, and analyzing results and errors from the run on the new dataset.</p><h3>Baselines</h3><h4>Random Baseline</h4><p>This baseline randomly assigned labels to examples in accordance with the training distribution. If 45% of the training examples were negative, it would assign a negative label to any given example with a 45% probability. I implemented this baseline as a comparison tool to ensure that other model I implemented were actually learning something. The f1 scores are as reported:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/503/1*GhPCrHpMs81djY06j3cFTA.png"/></figure><h4>Sentence-level Neural Baseline</h4><p>In the <a href="https://homes.cs.washington.edu/~eunsol/papers/acl2016.pdf">Choi et al., 2016</a> paper that I’m working on improving, this model is used as a baseline. I decided the report the results here and use them as baseline results for my own project as well.</p><p>This baseline is derived from <a href="https://nlp.stanford.edu/~socherr/EMNLP2013_RNTN.pdf">Socher et al., 2013</a>, in which the authors implemented a sentence-level RNN model for sentiment classification. To adapt this model for the purpose of entity-entity relation extraction, Choi et al. performed four steps:</p><ol><li>Collect all sentences where entities co-occur (appear in the same sentence)</li><li>Run each of the collected sentences through the classifier, and amalgamate the positive/negative sentiment results for each</li><li>Assign positive label to entity pair if at least one collected sentence was classified positively</li><li>Otherwise, assign negative label to entity pair if all sentences classified negatively</li></ol><p>The f1 scores for this model are as reported:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/402/1*H0uAoCZuPsanMJKNYfhebg.png"/></figure><h4>ILP Model Baseline</h4><p>This model is the main model introduced by the <a href="https://homes.cs.washington.edu/~eunsol/papers/acl2016.pdf">Choi et al., 2016</a> paper. It is an ILP model that is basically combines a base SVM model, which predicts entity-entity pairwise sentiment, with soft constraints from social science theories.</p><p>The f1 scores for this model are as reported:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/402/1*tCbKTqxFbNYcuGfbtrlyzA.png"/></figure><h4>Neural Baseline</h4><p>This model and the f1 scores for it are described in my previous post (see <a href="https://medium.com/@be.li.nda/nlp-capstone-blog-4-baseline-model-i-7de5277b5be">here</a>).</p><p>In my last blog post, I mentioned that one of the challenges I was facing was the fact that the train set and the dev/test sets were drastically different. This week, I have brainstormed a few ideas to approach this problem:</p><ol><li>Weak supervision approach: generate more training examples with the “no sentiment” label by assuming all unlabeled entity pairs in the training set express no sentiment to each other. Since the training set has many examples, but is very sparsely annotated (annotates few entities per document), it should be relatively easy to find many unlabeled entity pairs.</li><li>Adjust class weights to have the model pay more attention to minority classes in the training data, such as the “no sentiment” class.</li><li>Adjust the decision threshold of each sentiment class for the model. Given the final LSTM output (a probability score for each of the three classes), rather than just labeling the example by the majority class, perhaps tune the threshold for labeling an example as each of the three sentiments.</li></ol><p>In the meantime, I wanted to see how the model would perform if the datasets were more similar in distribution. I created a new dataset (which I will refer to as train’/dev’/test’) by splitting the train data by document using an 80/10/10 ratio. The results of the neural baseline on this dataset are report below:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JYd_FY4ZYnUJj5Fnn-kLKg.png"/></figure><p>The performance on the new dev’ set is much better than on the original dev set, although there is still some discrepancy.</p><h3>Error Analysis</h3><p>The final thing I did this week is error analysis. I used the results on the new dev’ of the neural baseline model for this analysis. The main thing I looked for was how each entity within a document was being classified, as I had hypothesized that the target/holder-ness of entities weren’t being encoded well enough.</p><p>The statistics from my error analysis appear to support my hypothesis.</p><ol><li>Of documents that had multiple entity pairs annotated (52% of documents), the model predicted 84.8% of them to have the same sentiment relation for all entity pairs, whereas only 30.3% of them actually classify the same sentiment for all entity pairs.</li><li>Up to 77% of the mistakes on the dev set could have been due to the model focusing on the classifying the central sentiment of the document, rather than classifying sentiments between specific (possibly peripheral) entity pairs in the document.</li></ol><p>For the second statistic, I defined the “central sentiment” of the document as the sentiment dynamic that the document was focused on , expressed by the main entities of the document. As a more concrete example, take an article headlined “<em>Protestors Storm BBC over Far-Right Leader’s TV Slot</em>,” which has a negative central sentiment. I manually went through the misclassified examples and counted how many of them were predicted in line with the central sentiment of the document (i.e. for the above example article, how many of its entity pairs are mistakenly predicted “negative”).</p><p>In terms of possible solutions for this problem, I’m planning to augment the architecture of my neural model to encode target/holder-ness in the architecture itself, rather than just within the input embeddings. Two possible architectures I plan to experiment with are either the <a href="https://homes.cs.washington.edu/~luheng/files/emnlp2017_lhlz.pdf">Lee et al. paper</a> or the <a href="https://arxiv.org/pdf/1802.10569.pdf">Verga et al. paper</a>. I describe both of these architecture, as well as how I’m going to adjust them for the entity-entity sentiment analysis task, in more detail in my project proposal blog post (see <a href="https://medium.com/@be.li.nda/nlp-capstone-blog-3-project-proposal-c8a12d3ae611">here</a>). While I haven’t figured out the exact mechanics of how I’m going to incorporate them, I definitely plan to experiment with some ideas from each paper next time.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=27c90aa3c1aa" width="1"/></div>
    </content>
    <updated>2018-04-25T06:30:23Z</updated>
    <category term="machine-learning"/>
    <category term="deep-learning"/>
    <category term="naturallanguageprocessing"/>
    <author>
      <name>Belinda Zou Li</name>
    </author>
    <source>
      <id>https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/0*A16vZtRWBzxYPlmn.</logo>
      <link href="https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@be.li.nda" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Belinda Zou Li on Medium</subtitle>
      <title>Stories by Belinda Zou Li on Medium</title>
      <updated>2018-05-15T04:00:24Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/a21b51cdd27c</id>
    <link href="https://medium.com/@viterbi.or.not/baseline-model-2-a21b51cdd27c?source=rss-c522ef075bb3------2" rel="alternate" type="text/html"/>
    <title>Baseline Model #2</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*M0h3Wof_sgtxGwgnT2IncQ.png"/>Bassline = Baseline?</figure><p>This week, we completed the baseline portion of our project (see the roadmap below!) by finishing the implementation of our various baseline models and evaluating their performance with the goal of providing context for the rest of the project. In last week’s blog post, we described the process of replicating the findings of a related research paper using a single model, and incorporating only features that apply to text summarization in general. This week, we expanded upon that start by adding an additional simple, single-feature baseline and by evaluating our implementation using other models as well! Finally, we built upon our codebase from last week with various bugfixes and feature additions, such as implementing k-fold cross validation for more reliable metrics.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*K0NWdjTpiYezkyqh34fdow.png"/>Roadmap of our project — At this point, we’ve completed the first big block, highlighted in orange!</figure><h4>Simple Baseline</h4><p>The simplest baseline we put together used only the sentence length feature, a very basic but often reliable measure of sentence importance, with a Naive Bayes model.</p><h4>More Realistic Baselines</h4><p>The more realistic and comprehensive baseline models that we implemented use the full “basic feature set” described in our <a href="https://medium.com/@viterbi.or.not/baseline-model-1-a6690114c441">last blog post</a> with Naive Bayes, Decision Tree, and Multilayer Perceptron models. The comprehensive Naive Bayes baseline is the same as the baseline model described in our previous post — the main progress on this week’s baselines is the addition of a simple feature to catch email lines that are quoted replies (a problem we found in a lot of the summaries generated by our models) as well as experimentation with the different types of models.</p><h4>Results and Evaluation</h4><p>As expected, the simple Naive Bayes baseline performed pretty poorly. The models using all of the features in the basic set all performed similarly well, with slight fluctuations in which ROUGE metric they did better in (seen in the table below). Overall, we found that our Naive Bayes model performed competitively with the other models in ROUGE-L and the best in ROUGE-1 and ROUGE-2, though most importantly, we thought the summaries generated by Naive Bayes were the most satisfactory when actually reading them.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Hv_d7fQj-ATlUEaV79Moiw.png"/>Table comparing the performances of the various baseline models we implemented, the best performing in each ROUGE metric highlighted in orange</figure><p>Our best baseline model does better than the corresponding model in <a href="http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf">Summarizing Online Conversations: A Machine Learning Approach</a> in the ROUGE-1 and ROUGE-2 metrics<strong>, </strong>but does significantly worse in the ROUGE-L metric. However, it is not clear which of the ROUGE metrics is more “important” to score well in, and it is hard to do a complete comparison between our model and theirs without a sample of the summaries generated by their model (which is not provided in the paper).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sFxZT2d-C_jKMnFxTWUHuA.png"/>Table comparing the performance of the our best baseline model with the corresponding model in <a href="http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf"><strong>Summarizing Online Conversations: A Machine Learning Approach</strong></a>, the best performing in each ROUGE metric highlighted in orange</figure><p>In an effort to better understand what these automated metrics are measuring, here are descriptions of what ROUGE-L and ROUGE-N (ROUGE-1 and ROUGE-2) measure —</p><p><strong>ROUGE-L: </strong>Based on Longest Common Subsequence statistics, identifies longest co-occurring in sequence n-grams.</p><p><strong>ROUGE-1: </strong>Unigram overlap between system and reference summaries.</p><p><strong>ROUGE-2: </strong>Bigram overlap between system and reference summaries.</p><p>ROUGE-L and ROUGE-N clearly measure summary quality very differently, and rather than increase together, the metrics vary greatly and sometimes change inversely. While performing a mini ablation study with our baselines, we noticed that removing certain features increased ROUGE-L but cause large drops in both ROUGE-1 and ROUGE-2, as well as generated less satisfactory summaries (judged by us reading the generated summaries).</p><p>Because ROUGE does not necessarily reliably measure the quality of a conversation summary, human monitoring of generated summaries and error analysis are crucial to this project.</p><h4>Error Analysis</h4><p>So, although we used the ROUGE metrics for our model in order to compare it to our baseline research paper, we put an emphasis on human evaluation due to the inability of ROUGE to capture all the elements of successful summarization. Namely, although ROUGE is capable of determining whether the words and subsequences used in a summary match the human-annotated reference, it cannot capture critical aspects of the text such as its coverage of the source document’s most important points or whether it makes logical sense when read.</p><p>Upon reading through the summaries produced by our model, we discovered an interesting mix of results. Several sentences that appeared key to establishing the email thread’s topic were included in the summary by the baseline, indicating that its features for topic identification and term similarity were contributing in a positive manner. However, although it is expected that any extractive summary will produce grammatically imperfect results, there were noticeably major issues with the formation of our baseline model’s summaries.</p><p>An excerpt of one fairly representative summary produced by our model appears below, unedited except for truncation and formatting for clarity. This is a summary of an email chain concerning accessible technology from the BC3 corpus:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JGjecxwGpwd-rxwnf_t_Cw.png"/>Comparison with reference summary</figure><p>As one can see, only the first two sentences (green) of this particular summary match the human-annotated summary; the rest (red) diverge and never again are the same sentences shared. This trend is seen across most of the summaries produced by our baseline model, where early sentences tend to be shared — one hypothesis is that the first email in a thread has clear significance in establishing that thread’s topic, while subsequent emails are less certain, leading to divergence between the model and human understanding.</p><p>Beyond the matching of sentences, there are certain aspects of the summary that, through a human evaluation, can be identified as clearly not belonging in the summary:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ni7uIemzWgCsW4Yvh0jlwA.png"/>Email-specific formatting leads to summarization mistakes</figure><p>In this example, there are sequences of text that are directly repeated (orange). This occurs due to emails having quoted text from previous emails in their message bodies, and as the general text summarization features attribute the same likelihood of being relevant to the summary to both versions of the text based solely on content (and not, for instance, sentence position), it makes sense that both would be included. Doing so seems not to vastly impact the ROUGE score, but provides another example of the importance of human evaluation because it seems reasonable that no human would prefer to have those repetitions in a summary. Another example of the baseline model’s errors can be found in the email signature present in the summary (blue), which a human reader would clearly not find meaningful for the summary.</p><p>Both of these mistakes can be attributed to the fact that our baseline model uses general features for text summarization, and does not factor in conversation-specific features such as recognizing an email signature as being irrelevant to the topics being discussed. Once we begin work on our minimum viable product, we expect it to perform much better in this category, because we will have the chance to add these features.</p><p>Finally, the following examples show cases in which our model makes the opposite mistake from above, failing to capture portions of the original conversation that are important to the summary through human eyes. As expected, both of the common cases of failure we identified seem to stem from the fact that the missed content is formatted in a different way than normal text.</p><p>For the same conversation as above, the following shows just the URLs that were included in a human-annotated summary. Highlighted in green are the URLs which our baseline model also included in its generated summary:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*P9C4OsXf9w3KK4ishqa9Tg.png"/>Almost all important URLs are not captured by the baseline model</figure><p>As one can see, the baseline model had a 10% success rate in identifying URLs from the email thread that the human annotator deemed as important. In a thread that primarily dealt with identifying resources from the internet, having these URLs in a summary would be highly desirable, so we consider this to be a major failing of the baseline model. Because URLs are much different from typical text, using general text summarization features likely led to this absence because there are no features that can ascribe importance to URLs based purely off their general format.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Wfd7cl-8KZ36YvAWXG4wHw.png"/>Structured data, such as ordered lists, are not captured</figure><p>As another example, the following is a comparison between our baseline model and a human-annotated reference summary for a different conversation that includes discussion of poll results:</p><p>Although the baseline model does relatively well in identifying sentences related to the discussion of the poll results, its summary is noticeably lacking the results themselves. We hypothesize that the general text summarization features are insufficient to detect numerical data or items that are presented in a list, such as the one above, and therefore because the actual text within each poll result item is very generic the baseline model was unable to successfully select them for the summary.</p><p>Ultimately, these few examples are not enough to capture the exact failings of our baseline model, but by analyzing them in conjunction with the other summaries generated for our validation set, we were able to get an impression of the types of improvements that will be needed. In our next step of including conversation-specific features, we plan to make our top priority addressing structured data unique to emails by creating features to target email summaries, quoted text (and repeated text in general), and certain entities such as URLs or lists.</p><h4>Steps Towards an Advanced Model</h4><p>Keeping the weaknesses of our baseline in mind, our next steps towards creating a more advanced conversation summarization model (and approaching our Minimum Viable Product!) include the following:</p><p><strong>Incorporate conversation-specific features</strong></p><ul><li>We would like to explore using topic segmentation to preprocess conversation data and potentially improve model performance.</li><li>We would also like to add features that incorporate detection of<strong> structured data</strong> (URLs, Lists, Numbers), <strong>sentiment scores</strong> of sentences, and <strong>discourse markers</strong> (defining the purpose of a sentence in the text, for example, identifying a sentence as an email signature).</li></ul><p><strong>Train the models on other datasets</strong></p><ul><li>We will need preprocess the other datasets and restructure some of our code to handle input of the other datasets.</li><li>We anticipate some challenges based on the differences of the other datasets — the chatlog data will require much more preprocessing and meeting transcripts will likely have different vocabulary (i.e. no URLs, fewer abbreviations) which may impact our feature engineering process.</li></ul><p>Check back next week to see our initial work on the most exciting part — the advanced model!</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a21b51cdd27c" width="1"/></div>
    </content>
    <updated>2018-04-25T06:29:12Z</updated>
    <category term="nlp"/>
    <author>
      <name>Viterbi Or Not To Be</name>
    </author>
    <source>
      <id>https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*wiisg40Bu4z11RTWJ66mnA.png</logo>
      <link href="https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@viterbi.or.not" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Viterbi Or Not To Be on Medium</subtitle>
      <title>Stories by Viterbi Or Not To Be on Medium</title>
      <updated>2018-05-15T04:00:27Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/fd61ae20a2f1</id>
    <link href="https://medium.com/@hongnin1/image-annotation-model-improved-baseline-fd61ae20a2f1?source=rss-c450eb982161------2" rel="alternate" type="text/html"/>
    <title>Image Annotation Model Improved Baseline</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>Our original baseline can be found here:</p><p><a href="https://medium.com/@hongnin1/image-annotation-model-baseline-dataset-and-evaluation-framework-d1d1b2d1f34c">Image Annotation Model Baseline, Dataset and Evaluation Framework</a></p><p>There are several major improve we have done to our baseline:</p><ol><li>We added Attention to our deep learning network to improve our decoding scheme: as can be seen in the snapshot below, we decided to change LSTM (previous baseline) to GRU due to performance reasons. We discovered that because our training corpus is extremely large, it takes way to long to train our model using LSTM, hence the switch to GRU.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/838/0*mAvISRtQGogv4cQ-."/>code block we added for adding attention/GRU</figure><p>2. Now that we are more familiar with TensorFlow (we have been watching tutorials online), we improved our APIs and incorporated better TensorFlow code to make our code base more organized and efficient. More specifically, we added “tf.contrib.seq2seq.GreedyEmbeddingHelper” to help feed data into the network, as well as adding “tf.contrib.seq2seq.BasicDecoder” and “tf.contrib.seq2seq.dynamic_decode” to perform dynamic unroll of RNN when doing decoding.</p><p>3. We had some bugs with our data parsing, and we have spent a large chunk of time debugging and eventually fixed the problem.</p><p>As for evaluation, we dived deep into the code base we found online for evaluation (for more detail see our previous post for baseline) and have decided to use the same evaluation method as the baseline approach because it is pretty established and work pretty well in determining whether an annotation is valid or not by using BLEU score).</p><p>4. We kept trying different attention weights and visualized the attention weight on input graphs.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=fd61ae20a2f1" width="1"/></div>
    </content>
    <updated>2018-04-25T05:48:06Z</updated>
    <category term="machine-learning"/>
    <author>
      <name>Ning Hong</name>
    </author>
    <source>
      <id>https://medium.com/@hongnin1?source=rss-c450eb982161------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/0*d6QC_ngideag3rTN.</logo>
      <link href="https://medium.com/@hongnin1?source=rss-c450eb982161------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@hongnin1" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Ning Hong on Medium</subtitle>
      <title>Stories by Ning Hong on Medium</title>
      <updated>2018-05-15T04:00:07Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/79ed786e5c74</id>
    <link href="https://medium.com/nlp-capstone-blog/baseline-ii-and-updates-79ed786e5c74?source=rss----9ba3897b6688---4" rel="alternate" type="text/html"/>
    <title>Baseline II and Updates</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>This week, our focus was to improve the original baseline model with an approach more tailored to the task of generating definitions. There were a few key challenges that the original baseline approach did not address. This included generating grammatically sound English sentences, and incorporating keywords. Over the past few weeks, we also explored text generation techniques used in poetry (Ghazvininejad et. al). Our new approach is inspired by the techniques used in this paper and aims to address the two major problems with our first baseline.</p><h4>Revised Approach</h4><p>One of the biggest issues with the first baseline models, which were neural language models, was that the sentence outputs were not coherent or grammatical. Ghazvininejad et. al addressed a similar structural issue by creating a large Finite State Machine of all possible paths one could take while generating a sonnet. Each path is grounded in the filtered vocabulary developed in earlier steps and technically would have produced a structurally sound sonnet. Though all of these paths were not great, the FSM provided a foundation for generating the best sonnet. We use a similar approach, where we create an FSM of all possible paths through the training corpus. For example, if we encountered the following sentence in the corpus, it’s corresponding FSM would look like this:</p><blockquote>Osteoporosis is a bone disease.</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uWBb5Vc4EerUU9hEvzHDuQ.png"/>Example FSM</figure><p>In this manner, we construct an FSM for the entire corpus.</p><h4>Extraction</h4><p>Another challenge of the original baseline was that it did not focus on the topic we provided to start with. Even though we provided the seed word, it tended to stray off topic very quickly. In order to fix this, we chose to use some techniques from extractive summarization and the keyword identification process from the poetry generation paper. To start, we have to identify some common words associated with the term we’re defining. In Generating Topical Poetry, the authors use distance between word vectors as a metric for similarity, which we also do in our model. This allows us to determine the top few keywords associated with the term.</p><p>Now, we can proceed to look through the corpus and extract all sentences that contain a keyword or the term itself. This allows us to capture the context in which a term is mentioned. In the future, we can capture more sentences than this, especially if we use a window larger than one sentence for capturing context. Once we have our extracted sentences, we can proceed to modify the FSM.</p><p>Our modified FSM will only contain words that are included in the extracted sentences and a set of pre-selected connective words required to generate grammatical sentences. We hope that this will narrow down the search space in our decoding phase.</p><h4>Definition Generation via Beam Search</h4><p>The FSM mentioned previously needs a scoring mechanism with which to extract likely paths. We plan on using an RNN language model (LSTM, GRU, etc.) to decode the FSM and produce the generated definition one sentence at a time. Although it is asking a bit much to trust the neural language model to produce coherent, semantically rich sentences, we trust that the amount of structure we’re introducing before inference nudges the model to connect the dots in the most sensible way.</p><p>An issue we’re left with is the actual beam search itself. Beam search is a useful alternative to exhaustive search for fixed sized sequences in that we only continue paths that are one of the top K likely paths at every step. The difficulty lies in the fact that beam search is best used for deriving most likely paths of a fixed length. When we’re at the stage of generating definitions, we’ll have to figure out how exactly sentence length will be enforced or relaxed. It’ll be especially difficult to enforce grammar, in particular, how to terminate sentences. In the most cases this can be mitigated by generating the sentences backwards and appending punctuation.</p><p>Difficulties also lie in what seed to use per generated sentence. It may make sense for semantically relevant terms to appear at the end of each sentence but that isn’t necessarily how all of these words are used in practice. Regardless, an FSA using a restricted vocabulary from extracted sentences coupled with a neural language model, we believe, will be the best of both worlds. We gain assurance in semantic quality uses aspects of extractive summarization and structure we introduce while allowing the generation a reasonable amount of improvisation.</p><h4>BIO-Tagging Approach for Sentence Extraction</h4><p>For what could be a part of the FSM-style definition generation, or even a standalone definition extractor, we plan on labeling sentences throughout the corpus using BIO tags. This approach proposed by AI2 researchers involves the use of distant supervision to label sentences conducive to definition structure and semantics by picking sentences that meet a ROUGE threshold w.r.t to gold standard definitions. We would then collect triples of terms, their gold standard definitions, and their BIO-tagged sentences. We could then train a sequence tagger to recognize what sentences in a paper are conducive to definitions and which ones aren’t.</p><p>Possible sources of gold standards to use for ROUGE are include WordNet, which has a large breadth of glosses but each gloss tends to be very short. We are also exploring the idea of using UMLS which would provide technical medical terms along the lines of what we’d like the model to be able to define, and another data set composed of NELL and Freebase which can be found <a href="http://rtw.ml.cmu.edu/wk/WebSets/glossFinding_wsdm_2015_online/index.html">here</a>. With “Automatic Gloss Finding for a Knowledge Base using Ontological Constraints”, Dalvi et al. set out to simplify KBs the same way we are, and they were kind enough to make this dataset of ~500k glosses available to the research community for continuing this work.</p><p>A supervised aspect of this project has been lacking until now, and we believe that incorporating this sequence-tagging or other intelligent forms of extracting rich, definition-like sentences will mean the language model and beam search won’t have to work as hard. The added assurance of a restricted search space to only what is relevant is better both for inference and training.</p><h4>Progress</h4><p>So far, the most difficult part of our project has been determining a more advanced approach to start with. Though the initial baseline model was easy to come up with, this model took several days to design. Most of the work we accomplished over the past few weeks involved talking with Waleed Ammar from AI2 and reading several research papers in order to define the architecture we have proposed above. As such, we have not made enough progress on this approach to evaluate it thoroughly. In this section, we list a breakdown of all the tasks we have.</p><ul><li>The infrastructure and interface for constructing the FSM is complete</li><li>The system used to determine keywords given a term is in progress. We are currently debating whether or not to use pre-trained word vectors and are working on finishing the code</li><li>The extraction phase of the model (after retrieving the keywords) is not complete as it relies on the keywords. However, this part should be fairly straightforward and should be complete by the end of the week</li><li>Beam search decoding is in progress and the functionality to find the next beam is complete but the infrastructure for deciding when to terminate the search is in progress.</li><li>Although the RNN for beam search through the FSM is already written (we can use the same RNN from the original baseline), it needs to be trained on a corpus, preferably the Semantic Scholar corpus</li></ul><p>Another challenge we are currently facing involves organizing the data. In our original baseline model, the loss would steadily decrease as we trained on a single document but would then suddenly spike upward when we switched to a new document. The AI2 Semantic Scholar dataset consists of many different types of research papers including Computer Science, Medical, and various other domains. As such, the language in each domain differs drastically, so organizing the papers into linguistically similar groups has remained a challenge. Currently, the API provides no such tools for categorizing the papers.</p><h4>Conclusion</h4><p>Overall, we hope that this approach is a step closer to defining an architecture specific to the definition generation task. That said, there are several ways to improve the individual pieces of this architecture. We can change the hyper parameters of models in every phase, change the way they are trained, and introduce new concepts such as sequence tagging to improve the quality of the text generated by the model. This current architecture gives us a baseline on which we can continually improve.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=79ed786e5c74" width="1"/><hr/><p><a href="https://medium.com/nlp-capstone-blog/baseline-ii-and-updates-79ed786e5c74">Baseline II and Updates</a> was originally published in <a href="https://medium.com/nlp-capstone-blog">NLP Capstone Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></div>
    </content>
    <updated>2018-04-25T05:43:39Z</updated>
    <category term="machine-learning"/>
    <author>
      <name>Karishma Mandyam</name>
    </author>
    <source>
      <id>https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4</id>
      <logo>https://cdn-images-1.medium.com/proxy/1*TGH72Nnw24QL3iV9IOm4VA.png</logo>
      <link href="https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/nlp-capstone-blog" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>A Journey Through CSE 481N, the Natural Language Processing Capstone Course at the University of Washington - Medium</subtitle>
      <title>NLP Capstone Blog - Medium</title>
      <updated>2018-05-15T04:00:25Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-9203775015655831448.post-597849658553454254</id>
    <link href="https://teamoverfit.blogspot.com/2018/04/5-milestone-strawmanbaseline-ii.html" rel="alternate" type="text/html"/>
    <title>#5 Milestone: Strawman/Baseline II</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h2 style="height: 0px;"><span>Team Overfit</span></h2><h3><span><br/></span></h3><h3><span>Project repo: <span style="font-size: 18.72px;"><a href="https://github.com/pinyiw/nlpcapstone-teamoverfit">https://github.com/pinyiw/nlpcapstone-teamoverfit</a></span></span></h3><h4><span>Team members: Dawei Shen, Pinyi Wang, Xukai Liu</span></h4><div style="text-align: start; text-indent: 0px;"><div style="margin: 0px;"><div><span><b>Blog Post: #5: 04/24/2018</b></span></div><div><span><span><b><br/></b></span></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Social Media Predicts Stock Price (StartUp Mode)</span><br/><span><br/></span><span><span id="docs-internal-guid-8a395488-fb3a-d9a7-cec2-8d3cb31f0a59"><span>This week, we tried to use tf-idf and seq2vec to process news headlines as input to our LSTM </span></span></span><span>model to predict UP/DOWN for APPLE stock price.</span><br/><span><br/></span><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span><b>Data Preprocessing</b></span><br/><br/><ul><li><span>Crawling historical news headlines from Twitter</span></li><li><span>Categorize tweets with date and correlated stock price</span></li><li><span>Cleanup unrelated data</span></li><li><span>Map vocabulary to index with removing words that appear less than 3 times in the tweet news corpus.</span></li></ul><div><span><b>Seq2One with TF-IDF</b></span></div><div><ul><li><span>TF-IDF</span></li><ul><li><span>Correlate word frequencies with price changes (convert words into normalized frequency count vector)</span></li></ul><li><span>Seq2One</span></li><ul><li><span>Correlate average word embeddings with price changes (convert words into normalized embedding vector)</span></li></ul><li><span>Bidirectional RNN</span></li><ul><li><span>Enhance the performance by knowing before and after prices</span></li></ul></ul><div><span><b>Evaluation</b></span></div></div><div><ul><li><span>Accuracy on predicting Up or Down</span></li><li><span>Accuracy on predicting Stock Price (TODO)</span></li></ul><div><span><b>Result</b></span></div></div><div><ul><li><span>TF-IDF: 60.7% accuracy predictin UP/DOWN on test set with 273 total data points and 9/1 train-test split</span></li><li><span>Seq2Vec: 53.6% accuracy predicting UP/DOWN on test set with 273 total data points and 9/1 train-test split</span></li></ul><div><span><b>Error Analysis</b></span></div></div><div><ul><li><span><b>Things that may impair the precision of prediction</b></span></li><ul><li><span>Words with high frequency but have low effect on stock prices:</span></li><ul><li><span>A, is, of, for, the</span></li><li><span>Tweets talking about fruit <i>apple</i> instead of the company</span></li></ul><li><span>Tweets news that have high frequency but low effect on stock prices and news that may have high effect on stock prices but with low frequencies</span></li><li><span>Losing information of each single tweet as we have combined all tweets in a day together to form a word frequency vector and do the prediction</span></li></ul><li><span><b>Things that could be done to improve the performance</b></span></li><ul><li><span>Add the overall market stock price as part of the input because it usually also has big impact on a single companies stock price.</span></li><li><span>Crawl more data for more companies and longer duration</span></li><li><span>Add financial</span></li><li><span>Add the competitor companies stock prices and tweets news as part of the input.</span></li></ul></ul></div></div></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span id="docs-internal-guid-8a395488-fb3c-6f01-c575-279c6f3d6421"/></div></div></div></div>
    </summary>
    <updated>2018-04-25T05:20:00Z</updated>
    <author>
      <name>Team Overfit</name>
      <email>noreply@blogger.com</email>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-9203775015655831448</id>
      <author>
        <name>Team Overfit</name>
        <email>noreply@blogger.com</email>
      </author>
      <link href="https://teamoverfit.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="https://teamoverfit.blogspot.com/feeds/posts/default?alt=rss" rel="self" type="application/rss+xml"/>
      <title>NLP Capstone</title>
      <updated>2018-05-15T04:00:30Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-US">
    <id>http://cse481n-capstone.azurewebsites.net/?p=51</id>
    <link href="http://cse481n-capstone.azurewebsites.net/2018/04/24/more-data-collection-and-baseline/" rel="alternate" type="text/html"/>
    <title>More Data Collection and Baseline</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Data Collection: In the last blog we discussed the challenges of trying to find general Reddit posts that were similar to the collected MeanJokes posts. Even limiting to posts with Jaccard Similarity &gt; .3 a lot of the data looked like the following: MeanJokes Post: “Don’t be offended but Fuck you” Similar Post: “fuck Foligno” … <a class="more-link" href="http://cse481n-capstone.azurewebsites.net/2018/04/24/more-data-collection-and-baseline/">Continue reading<span class="screen-reader-text"> "More Data Collection and Baseline"</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h3><span style="font-weight: 400;">Data Collection: </span></h3>
<p><span style="font-weight: 400;">In the last blog we discussed the challenges of trying to find general Reddit posts that were similar to the collected MeanJokes posts. Even limiting to posts with Jaccard Similarity &gt; .3 a lot of the data looked like the following:</span></p>
<pre><span style="font-weight: 400;">MeanJokes Post: “Don’t be offended but Fuck you”
    Similar Post: “fuck Foligno”
    Similar Post: “fuck narek”
    Similar Post: “fuck"
    Similar Post: “Fuck me?”
    Similar Post: “Fuck me”
    Similar Post: “fuck me”
</span>    Similar Post: “Fuck it”
    Similar Post: “Fuck”
    Similar Post: “Who the fuck are you?”</pre>
<p><span style="font-weight: 400;">These wouldn’t be very interesting examples to eventually train a model on. We also noticed that because of the nature of Jaccard Similarity and the sparsity of language in our collected Reddit posts, most of the posts that matched our MeanJokes posts would be very short, containing one or two key phrases from the MJ post. Posts made to Reddit are typically either very long or very short, so to make use of those long posts we decided to split them up by sentence and consider every sentence individually. We would also filter out sentences that are below a certain number of tokens, so that we avoid examples like the above.</span></p>
<pre><span style="font-weight: 400;">MeanJokes Post: “How is ScizorSci like Hoss McDank? They’re both faggots!”
</span>    Similar Post: “How long was he like that?”
    Similar Post: “More like CRAPitalism (this but unironically)
    Similar Post: “Volcanoes are like earth pimples”
    Similar Post: “I cried like a bitch”
    Similar Post: “She doesn’t like jewelry”
    Similar Post: “Everyone was like daaaaayum”
    Similar Post: “Don’t speak to me like that”
    Similar Post: “Don’t like the smell of this at all”
    Similar Post: “A few others I like are”
    Similar Post: “It’s like I’m on fire”</pre>
<p><span style="font-weight: 400;">These are better than the previous examples but still the similarities are very shallow. Most of the matches are just because there were one or two content phrases that matched between them. This could be expected from having a Jaccard Index cutoff as low as .3, since usually you want one that is somewhere above .7, but the language used in these posts is too sparse to be this picky and still have enough data to train a neural network. </span></p>
<p><span style="font-weight: 400;">We could possibly try similarity on word embeddings or sentence embeddings, but we liked using Jaccard Index because we actually care about the specific words used and not just the semantic meaning. </span></p>
<p><span style="font-weight: 400;">Our main issue ended up being that we assumed most posts would be conversationally structured with short-ish text, when in reality we found that posts are either really short, some collection of tags for indexing or trading, really long posts with at least a paragraph of text about some abstract subject, or requests for sexual favors. Overall this makes general reddit posts quite different from r/meanjokes, so at the surface level jaccard index won’t really do much, and furthermore general reddit posts won’t be conversational in structure the way r/meanjokes posts are. For these reasons we will have to move on to looking at comments instead, since we believe that they will be more conversational than posts. We originally wanted to use posts instead of comments since posts are contextually self-containing while comments are typically responses to multi-person conversations. However, we ended up splitting posts into independent sentences anyway, so this reasoning for avoiding comments became moot.</span></p>
<h3><b>Baseline Model:</b></h3>
<p><span style="font-weight: 400;">This week, we developed a baseline Neural Network model using allennlp. The model architecture is simple. We used pretrained </span><a href="https://nlp.stanford.edu/projects/glove/"><span style="font-weight: 400;">glove twitter word embeddings</span></a><span style="font-weight: 400;">, encode each tweet with a recurrent neural network (e.g. RNN, LSTM, GRU) sequence to vector encoder, and finally feed the vector into a feed-forward network with softmax at the end. We experimented with glove twitter word embeddings with 50 dimensions. We also tried different flavors of 1 layer recurrent neural network sequence to vector encoders, more specifically, GRU, LSTM, BiLSTM, and RNN. By the time this blog is written, we have yet performed extensive hyperparameter tuning. </span></p>
<p><span style="font-weight: 400;">Among the 4 different model setups that we tried, one of the models (Model1) got the highest accuracy, recall, and f1 score on test data, while another model (Model2) got the highest precision on test data. Below are their performances on dev and test dataset. </span></p>
<ul>
<li><span style="font-weight: 400;">Model1 — embedding: 50-dimensional glove twitter embeddings, encoder: 1 layer GRU, epoch chosen: 20</span></li>
</ul>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Dev</span></td>
<td><span style="font-weight: 400;">Test</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy </span></td>
<td><span style="font-weight: 400;">0.8245</span></td>
<td><span style="font-weight: 400;">0.8181</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.7934</span></td>
<td><span style="font-weight: 400;">0.7896</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7995</span></td>
<td><span style="font-weight: 400;">0.7947</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.7964</span></td>
<td><span style="font-weight: 400;">0.7921</span></td>
</tr>
</tbody>
</table>
<ul>
<li><span style="font-weight: 400;">Model2: — embedding: 50 dimensional glove twitter embeddings, encoder: 1 layer BiLSTM, epoch chosen: 5</span><br/>
<table>
<tbody>
<tr>
<td/>
<td><span style="font-weight: 400;">Dev</span></td>
<td><span style="font-weight: 400;">Test</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy </span></td>
<td><span style="font-weight: 400;">0.8409</span></td>
<td><span style="font-weight: 400;">0.8175</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8239</span></td>
<td><span style="font-weight: 400;">0.8004</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7909</span></td>
<td><span style="font-weight: 400;">0.7627</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.8070</span></td>
<td><span style="font-weight: 400;">0.7811</span></td>
</tr>
</tbody>
</table>
</li>
</ul>
<p><span style="font-weight: 400;">These two models’ setups are almost the same except for model1 uses a GRU encoder while model2 uses an BiLSTM encoder. Surprisingly, Model1 ends up having better overall performance on test data than the ones with more complex encoders like BiLSTM. </span></p>
<h4><span style="font-weight: 400;">Error Analysis:</span></h4>
<p><span style="font-weight: 400;">We will use the Model2’s errors in our error analysis:</span></p>
<p><span style="font-weight: 400;">First we will look into sentences that are hateful but our model classified as none:</span></p>
<ol>
<li style="font-weight: 400;">@RichardDawkins @AbuelitoSerge Really, Muslims understand this. They just want to be able to use the name “racism” to shut us up.</li>
<li style="font-weight: 400;">@RTUKnews An Islamist human rights group? LOL. Now there is a contradiction in terms.</li>
</ol>
<p><span style="font-weight: 400;">From the above examples, we found that our model is not good at understanding the underlying meaning of a sentence. For example, the 2rd one implies Islamist doesn’t care about human rights, which is attacking Islam people. However, since this sentence does not have any words that are very sensitive, our model considered it as OK instead of hateful.</span></p>
<p><span style="font-weight: 400;">Here are some other sentences that are not hateful but our model classified then as hateful:</span></p>
<ol>
<li style="font-weight: 400;">@Strubbestition Name one thing that is not an opinion but is still sexist. I will wait.</li>
<li style="font-weight: 400;">@Bipartisanism @AllooCharas Terrorism involves a political or religious objective to the terror.Most mass murderers have personal objectives</li>
</ol>
<p><span style="font-weight: 400;">On the other hand, we found a trend that sentences including words like “sexist”, “crime” are classified as hateful disregarding what exactly the post means. For a concrete example, the 3rd sentence from 2nd group is not saying anything hateful but our model considered it as hateful. We suspect that because “murderers” appeared in that sentence and in our training data and most other sentences with such word is hateful, our model picked up such pattern and made a wrong decision.</span></p>
<p><span style="font-weight: 400;">Why we end up have a pretty bad result? We have two possible reasons:</span></p>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">Our dataset used is really small (15k sentences in total) and dataset itself is really noisy. For example, “@dgbattaglia Saw this this morning… http://t.co/9YUwOuZugw” is somehow labeled as hateful as true label in original dataset.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Our model is not expressive enough to recognize more complicated patterns. This also has something to do with the dataset. With such a small dataset, we cannot really train a deep or more complicated model.</span></li>
</ol>
<h4><span style="font-weight: 400;">Next Steps: </span></h4>
<p><span style="font-weight: 400;">What we are seeing in training is is this general pattern. We suspect it is because the dataset we have (around 15k tweets) is too small for a neural network model. We would want to try combine another </span><a href="https://github.com/t-davidson/hate-speech-and-offensive-language"><span style="font-weight: 400;">twitter hate speech dataset (by Thomas Davidson et. al.)</span></a><span style="font-weight: 400;"> and Waseem’s twitter dataset and train different neural net models on the combined dataset. </span><span style="font-weight: 400;"><br/>
</span></p>
<p><img alt="" class="alignnone wp-image-54" height="192" src="http://cse481n-capstone.azurewebsites.net/wp-content/uploads/2018/04/P3-300x138.png" width="417"/></p>
<h4><span style="font-weight: 400;">Data Sources: </span></h4>
<p><a href="https://www.semanticscholar.org/paper/Hateful-Symbols-or-Hateful-People%3F-Predictive-for-Waseem-Hovy/df704cca917666dace4e42b4d3a50f65597b8f06">Waseem, Zeerak and Dirk Hovy. “Hateful Symbols or Hateful People? Predictive Features for Hate Speech Detection on Twitter.” SRW@HLT-NAACL (2016).</a></p>
<p><a href="https://www.semanticscholar.org/paper/Automated-Hate-Speech-Detection-and-the-Problem-of-Davidson-Warmsley/6ccfff0d7a10bf7046fbfd109b301323293b67da">Davidson, Thomas J et al. “Automated Hate Speech Detection and the Problem of Offensive Language.” ICWSM (2017).</a></p></div>
    </content>
    <updated>2018-04-25T05:00:21Z</updated>
    <category term="Weekly blog"/>
    <author>
      <name>Team Watch Your Language!</name>
    </author>
    <source>
      <id>http://cse481n-capstone.azurewebsites.net</id>
      <link href="http://cse481n-capstone.azurewebsites.net/feed/" rel="self" type="application/rss+xml"/>
      <link href="http://cse481n-capstone.azurewebsites.net" rel="alternate" type="text/html"/>
      <subtitle>Spring2018 CSE481N Capstone</subtitle>
      <title>Team Watch Your Language!</title>
      <updated>2018-05-15T04:00:21Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://mathstoc.wordpress.com/?p=323</id>
    <link href="https://mathstoc.wordpress.com/2018/04/25/nlp-capstone-post-5-a-new-hope/" rel="alternate" type="text/html"/>
    <title>NLP Capstone Post #5: A New Hope</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Dataset Improvements Last time, on Music NLP. We ran into many midi data parsing issues. Since then, we have discovered a new dataset called the Lakh MIDI Dataset (http://colinraffel.com/projects/lmd/) that comes with reasonably well-formed midi files. Using the “Clean MIDI Subset”, we found thousands of midi files with their associated song names and songwriters. From … <a class="more-link" href="https://mathstoc.wordpress.com/2018/04/25/nlp-capstone-post-5-a-new-hope/">Continue reading <span class="screen-reader-text">NLP Capstone Post #5: A New Hope</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h1><span style="font-weight: 400;">Dataset Improvements</span></h1>
<p><i><span style="font-weight: 400;">Last time, on Music NLP.</span></i><span style="font-weight: 400;"> We ran into many midi data parsing issues. Since then, we have discovered a new dataset called the Lakh MIDI Dataset (</span><a href="http://colinraffel.com/projects/lmd/"><span style="font-weight: 400;">http://colinraffel.com/projects/lmd/</span></a><span style="font-weight: 400;">) that comes with reasonably well-formed midi files. Using the “Clean MIDI Subset”, we found thousands of midi files with their associated song names and songwriters. From these midi files, we extracted all with nonempty “lyric” fields when parsed via the pretty_midi package (which, incidentally, is also developed by Colin Raffel). After this step, we were left with ~1200 midi files that contain lyrics.</span></p>
<p><span style="font-weight: 400;">We currently clean the lyrical content by removing all unusual symbols and setting all characters to lowercase. We leave all lyrical tokens as is, which typically means syllable. Due to the inconsistent quality of the MIDI annotations, many songs are tokenized instead to characters, words, or even sentences. We will explore other methods for processing data if this is not sufficient for our results.</span></p>
<p><span style="font-weight: 400;">It is unfortunate we did not find this dataset sooner, because most of our challenges up to this point have been dealing with the poor quality of the gathered data.</span></p>
<h1><span style="font-weight: 400;">Alignment</span></h1>
<p><span style="font-weight: 400;">For our task of producing karaoke style output, there are two main tasks we have to solve. The first task is the generation of plausible lyrics, and the second is to align the lyrics to the proper time along the musical data. The alignment task has been studied extensively, but specifically aligning lyrical content to MIDI has not been covered in literature we have found. The most common alignment task is lyrics to audio data, as opposed to MIDI. The other common task is to align audio data to the notes defined in a MIDI file. In [1], they show a method that takes a MIDI file with annotated lyrics and uses this to align the lyrics to the raw audio. Unfortunately this is not our task, because we are trying to generate the annotated MIDI.</span></p>
<p><span style="font-weight: 400;">This week, we have decided to ignore the alignment task and focus primarily on making a reasonable lyrical model. We will return to alignment next week.</span></p>
<p><span style="font-weight: 400;">The next step was to align the lyrics with pianoroll. Fortunately, well-formed midi data parsed into PrettyMIDI objects come with a “get_piano_roll” function that takes as input a list of “times” which correspond to where in time pretty_midi will attempt to sample the music. As each syllable in the lyrics comes with a start time for when the singer enunciates it, we can pass in these start times to produce pianoroll that is aligned (up to small error) with the lyrics.</span></p>
<p><span style="font-weight: 400;">For some implementation reasons that are difficult to explain in English, it is possible for “get_piano_roll” to produce NaN entries, which we have replaced with zeros. Due to this and the potential for other such problems, we have forked the pretty_midi package and will be able to modify the code for our needs. For example, as pointed out in [2], “in a given MIDI file there is no reliable way of determining which instrument is a transcription of the vocals in a song”. As such, there are many choices for how to do alignment; pretty_midi has implemented just one. It is an interesting task to see how different alignment methods help or hurt our models.</span></p>
<h1><span style="font-weight: 400;">Lyric prediction</span></h1>
<p><span style="font-weight: 400;">Now that we have aligned pianoroll to lyrics data, we can begin engineering the model. Last time, we used an LSTM to generate lyrics given starting characters. Here, we will again use LSTMs, but instead, work at the syllable level and take as input the pianoroll of a song. As each column of a pianoroll is a time slice, each input vector to the LSTM is a single time slice. Each time slice is a 128-dimensional vector, with each entry representing the activation of an instrument; there are 128 midi recognized “instruments”.</span></p>
<p> </p>
<p><span style="font-weight: 400;">All that is left is to play with the architecture. </span></p>
<p><img alt="RNN model" class="alignnone size-full wp-image-322" src="https://mathstoc.files.wordpress.com/2018/04/rnn-model1.png?w=676"/></p>
<p><span style="font-weight: 400;">At the moment, our pipeline looks like what is shown in the diagram. At each iteration, we take a song, extract the lyrics and the corresponding pianoroll data. We then feed each time slice of the pianoroll data through an encoder unit, then through an LSTM unit, then through a decoder unit, and finally through a softmax to produce the prediction. Our loss is the negative log-likelihood (negative logarithm of the RNN softmax probability of the true syllable).</span></p>
<p><span style="font-weight: 400;">We will compare our final model to this baseline with respect to the loss on a held-out validation set. We will also experiment with loss functions other than cross entropy to see how it affects the actual lyrical output.</span></p>
<h1><span style="font-weight: 400;">Model results</span></h1>
<p><span style="font-weight: 400;">We have so far only trained our model for a single iteration over the training set. For an empirical evaluation on the current model quality, we ran a single MIDI through the input and computed the argmax word for each output. This produced a result in which every predicted lyric was an empty message, which is the most common string in the training set. We will explore methods to handle this class imbalance as our next task.</span></p>
<h1>References</h1>
<p><span style="font-weight: 400;">[1] Müller, Meinard &amp; Kurth, Frank &amp; Damm, David &amp; Fremerey, Christian &amp; Clausen, Michael. (2007). Lyrics-Based Audio Retrieval and Multimodal Navigation in Music Collections. 4675. 112-123. 10.1007/978-3-540-74851-9_10.</span><br/>
<span style="font-weight: 400;">[2] </span><span style="font-weight: 400;">Raffel, Colin and Daniel P. W. Ellis. “Extracting Ground-Truth Information from MIDI Files: A MIDIfesto.” </span><i><span style="font-weight: 400;">ISMIR</span></i><span style="font-weight: 400;"> (2016). </span><span style="font-weight: 400;"> </span></p></div>
    </content>
    <updated>2018-04-25T04:44:57Z</updated>
    <category term="NLP Capstone"/>
    <author>
      <name>Nicholas Ruhland</name>
    </author>
    <source>
      <id>https://mathstoc.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://mathstoc.wordpress.com/category/nlp-capstone/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://mathstoc.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://mathstoc.wordpress.com/osd.xml" rel="search" title="Mathematical Distractions" type="application/opensearchdescription+xml"/>
      <link href="https://mathstoc.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A recreational (occasionally research) blog on topics in maths or computer science - by Kuikui</subtitle>
      <title>NLP Capstone – Mathematical Distractions</title>
      <updated>2018-05-15T04:00:30Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-5600014144802012716.post-1597347106413431292</id>
    <link href="https://nlpcapstonesemparse.blogspot.com/2018/04/blog-5-strawman-ii.html" rel="alternate" type="text/html"/>
    <title>Blog 5: Strawman II</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Currently my model is at 20.1 Bleu and .02 EM. The state of the art has 23 Bleu and .08 EM. I'm</span><br/><span> not doing error analysis yet since I'm only able to train my model on 1/3 of the data due to </span><br/><span>performance and memory issues. I've cut training time in half through several optimization </span><br/><span>but there is a memory bug which I haven't found yet which prevents me from training on the </span><br/><span>whole dataset. Thus, I will list what I've done on the performance end, and my action plan.</span></div><span id="docs-internal-guid-17abcdb6-f838-25e9-608e-d57755b90e92"><br/></span><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;"><span>Speed Optimizations:</span></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;"><span>Problem - Training ⅓ dataset taking 6 hours per epoch.</span></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;"><span>Solutions implemented:</span></span></div><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li>Get_states_to_consider slowest part of take_step. This was optimized along with the expensive padding operation in get_action_embeddings, and the inefficient looping and sorting in compute_new_states. This cuts the training time in half, but still takes 3 hours on training set for 1 epoch</li></ul><div><span><span style="font-size: 14.6667px; white-space: pre-wrap;">Solutions to explore:</span></span></div><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li>Further areas to improve which cut down by about ½ hour are create_grammar_state, embed_actions, map_entity_productions. Here since there are 10,000 global rules which are processed for every batch in every iteration, just process them once in the constructor.</li></ul><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;"><span>Memory Optimization:</span></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;"><span>Problem - Low identifier threshold or high embedding dim like in paper, on 40,000 or more instances causes gpu out of memory error.</span></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;"><span>Debugging:</span></span></div><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li>Printing all tensors in memory at the end of forward using python garbage collection package. Total size is around 115mb but gpu uses 12gb! Perhaps this is a memory leak?</li><li>Tried different configurations to see where its crashing, high embedding dim causes crash in action index select, while just large dataset causes crash in backward.</li></ul><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;"><span>Solutions that I've tried:</span></span></div><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li>Doing index select on action_embeddings for previous embedding to save space.</li><li>All finished states del’d</li><li>Del keyword used frequently after tensor no longer used.</li><li>Disabling cudnn backend</li></ul><div><span style="font-size: 14.6667px; white-space: pre-wrap;"><span>Solutions to explore:</span></span><br/><br/><ul><li>Using pytorch DataParallel package.</li><li>Split only when a state has finished.</li></ul><div>Let me know if you guys have any ideas on solving this gpu out of memory issue!</div></div></div>
    </summary>
    <updated>2018-04-24T15:14:00Z</updated>
    <author>
      <name>nlpcapstone</name>
      <email>noreply@blogger.com</email>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-5600014144802012716</id>
      <author>
        <name>nlpcapstone</name>
        <email>noreply@blogger.com</email>
      </author>
      <link href="https://nlpcapstonesemparse.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="https://nlpcapstonesemparse.blogspot.com/feeds/posts/default?alt=rss" rel="self" type="application/rss+xml"/>
      <title>NlpCapstone</title>
      <updated>2018-05-15T04:00:05Z</updated>
    </source>
  </entry>

  <entry>
    <id>http://sarahyu.weebly.com/cse-481n/actual-strawman-update</id>
    <link href="http://sarahyu.weebly.com/cse-481n/actual-strawman-update" rel="alternate" type="text/html"/>
    <title>Actual Strawman Update</title>
    <summary>Real Data and Results Have Been Seen! As I mentioned in my last post, I was struggling with accessing the data, but I've since solved my problems and got to learn some cool tools along the way (like apparently you can read a compressed file without decompressing??? wild). I've also spent a large part of the week learning and fighting with SqlAlchemy, PyMySQL, MySQL, and UTF-8 issues. With the interaction of all of these, I was able to read (most of the) Reddit posts of January 2017 (thanks  [...]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><div class="paragraph"><strong>Real Data and Results Have Been Seen! </strong><br/>As I mentioned in my last post, I was struggling with accessing the data, but I've since solved my problems and got to learn some cool tools along the way (like apparently you can read a compressed file without decompressing??? wild). I've also spent a large part of the week learning and fighting with SqlAlchemy, PyMySQL, MySQL, and UTF-8 issues. With the interaction of all of these, I was able to read (most of the) Reddit posts of January 2017 (thanks to Jason Baumgartner publishing these dumps on pushshift.io, I will donate when I have an income) which amounted to 80 million posts, find the users we are interested in, find neurotypical subreddits these users post to, and then get posts of our two (neurotypical and neurodivergent) subreddit subsets. <br/><br/>Side Note: I'm going to start referencing the Neurodivergent set as ND, and Neurotypical as NT, trying to save some typing<br/><br/><strong>Baseline #1 (kind of an update of the Strawman #1):</strong><ul><li><span>Glen Coppersmith and Erin Kelly (2014). <strong><em>Dynamic Wordclouds and Vennclouds for Exploratory Data Analysis. </em></strong></span><span><font size="2">Association for Computational Linguistics Workshop on Interactive Language Learning and Visualization</font></span></li></ul> With thanks to Coppersmith and Kelly, I was able to make a Term Frequency Venncloud as seen below that show in black the most frequent terms found in both subreddit subsets, and then separated into the most frequent terms in neurodivergent subreddits and neurotypical subreddits in blue and red, respectively. </div>  <div><div class="wsite-image wsite-image-border-none " style="padding-top: 10px; padding-bottom: 10px; margin-left: 0px; margin-right: 0px; text-align: center;"> <a> <img alt="Picture" src="http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-04-26-at-1-48-22-pm_orig.png" style="width: auto;"/> </a> <div style="display: block; font-size: 90%;">Naurodivergent vs. Neurotypical Subreddit Venncloud</div> </div></div>  <div class="paragraph"><br/>As we can see, the middle of the venncloud is pretty uninteresting, but here are some notable points:<ul><li>Personalization: Frequency of you/me, your/my words which indicate some sense of relationship and more personalization between ND posters. This contrasts the frequency of they, indicating some discussion of an other, in the NT subreddits.</li><li>"is": I interpreted the frequency of this word in the NT subreddits as a more definitive and declarative way of speech, rather than other words such as "think", "feel" and "maybe" (in the ND subreddits) which signal more hesitation. This is a point touched on and described as dogma in Fast &amp; Horvitz which is one of the papers I discussed in a previous post.</li><li>"www", "imagesofnetwork" :  This is something I cold probably fix; the way I pre-process the data scrubs and separates the links into separate words. At the end of the day though, this shows that there are significantly more links in NT subreddits. My thought is that the lack of such in the ND subreddits might mean more anecdotal and personal interactions than when compared to ND subreddits</li><li>Moral Adjectives: Some of the ND frequently used terms are what I am going to call Morale Adjectives (let me know if there's an actual term for this); here I mean, we see words like "good", "right", "bad", which are often used to describe habits or behavior.</li><li>SURPRISE GENDER DIFF: As you can see, 'she' is one of the most frequent ND words, whereas 'he' is  one of the most frequently used NT words. Some thoughts: 1) doesn't show anything, there are some partner subreddits and may just show that the predominantly male reddit user base talks about different genders in the two, but they themselves may not be a different gender distribution or 2) could show different gender engagement in the different subsets.</li></ul><br/><strong>Baseline #2: Connotation Frames</strong><ul><li><span style="color: rgb(0, 0, 0);">Hannah Rashkin, Sameer Singh, Yejin Choi. 2016. <strong><em>Connotation Frames: A Data-Driven Investigation.</em></strong><font size="2"> In Proceedings of ACL 2016</font></span></li><li><span style="color: rgb(0, 0, 0);">Maarten Sap, Marcella Cindy Prasettio, Ari Holtzman, Hannah Rashkin, &amp; Yejin Choi. 2017. <em><strong>Connotation Frames of Power and Agency in Modern Films.</strong></em> <font size="2">sched. to appear EMNLP 2017 short papers. </font></span></li></ul> With help from Maarten Sap, another model I explored was the Connotation Frames formalism, to look at the verbs used in both our NT and ND subreddits and the sentiments these provide between agent and subject. However, we found no significant differences between the two (output below).</div>  <div><div class="wsite-multicol"><div class="wsite-multicol-table-wrap"> 	<table class="wsite-multicol-table"> 		<tbody class="wsite-multicol-tbody"> 			<tr class="wsite-multicol-tr"> 				<td class="wsite-multicol-col" style="width: 50%; padding: 0 15px;"> 					 						  <div><div class="wsite-image wsite-image-border-none " style="padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;"> <a> <img alt="Picture" src="http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-04-26-at-9-45-10-am_orig.png" style="width: auto;"/> </a> <div style="display: block; font-size: 90%;"/> </div></div>   					 				</td>				<td class="wsite-multicol-col" style="width: 50%; padding: 0 15px;"> 					 						  <div><div class="wsite-image wsite-image-border-none " style="padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;"> <a> <img alt="Picture" src="http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/nt-verbs_1_orig.png" style="width: auto;"/> </a> <div style="display: block; font-size: 90%;"/> </div></div>   					 				</td>			</tr> 		</tbody> 	</table> </div></div></div>  <div class="paragraph"><br/><strong>Baseline #3: LIWC2015</strong><br/>Finally, I used LIWC2015 to count and classify the psychological meanings and categories for both NT and ND subreddits. This serves as another type of language model to define these two 'languages' and offers us another metric on which to find similarities and differences. ​<br/><br/>Just for some clarification, the way that this model works is by having 73 categories (more information available <a href="https://liwc.wpengine.com/compare-dictionaries/" target="_blank">here</a>), anywhere from topics - PRONOUN, HEALTH, BIO - to grammar - VERB, ARTICLE - and gives the percentage of the language that each category accounts for in that 'language'. In our case, we see the distribution of categories in NT subreddits compared to ND subreddits. <br/><br/><span>My hypotheses were:</span><ul><li>[You, Heshe, Pronoun, Health, Feel, They] categories would be significantly higher in ND </li><li>[Anger, Power, Swear] categories would be significantly lower in ND than in NT</li></ul><br/>After getting the results, I report the top 10 categories with the largest % difference between the two. <ul><li>HEALTH(3.34x), <span>INGEST(2.69x), BIO(2.13x)</span><br/><ul><li>These categories are topic specific (ingestion related to drug subreddits and bio on biological processes) and align with what we expect in mental health topic subreddits</li></ul></li><li>FEEL(2.04x), SAD(1.88x), ANX - anxiety (<span>2.86x)</span><br/><ul><li><span>​Also make sense for the support communities within the ND group, potentially, topical for "anxiety" as a temporary and consistent feeling</span><br/></li></ul></li><li>FAMILY(2.07x), HOME (2.05x)<br/><ul><li>This was a bit surprising, I believe appeals to the family and home tend are prominent in support groups as well as the "partners of" subreddits we have in the ND group</li></ul></li><li>I (1.73x)<ul><li>There seems to also be a lot of personal discussion, which we expect in subreddits that are meant to discuss personal problems</li></ul></li><li>FEMALE (1.81x)<br/><ul><li>ITS HERE AGAIN WHY AND HOW</li></ul></li></ul>​<br/>That's all for baseline models, here's to my first attempt at the more advanced model this week...</div></div>
    </content>
    <updated>2018-04-24T07:00:00Z</updated>
    <category term="Uncategorized"/>
    <source>
      <id>http://sarahyu.weebly.com/cse-481n</id>
      <author>
        <name>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde</name>
      </author>
      <link href="http://sarahyu.weebly.com/cse-481n" rel="alternate" type="text/html"/>
      <link href="http://sarahyu.weebly.com/6/feed" rel="self" type="application/rss+xml"/>
      <subtitle>CSE 481N</subtitle>
      <title>Sarah yu - CSE 481N</title>
      <updated>2018-05-09T17:30:11Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/79ba10bbc70c</id>
    <link href="https://medium.com/@ryanp97/baseline-evaluation-and-ideas-for-evaluating-fully-featured-graphs-79ba10bbc70c?source=rss-6378d85d3a9b------2" rel="alternate" type="text/html"/>
    <title>Baseline Evaluation and Ideas for Evaluating Fully-featured Graphs</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>Since the last week, I’ve been working on cleaning the model’s predictions in order to be able to evaluate it using SMATCH (note the following sections focus on the model trained on and predicting featureless graphs). There were a couple of cases in which the model was unable to produce a well formed graph, but those were few and far between.</p><h4>Dealing with Ill-formed Graphs</h4><p>I decided to deal with ill-formed graphs in a harsh way until Jan any I can decide on a better heuristic for dealing with them. Though, for now, whenever I encounter an invalid graph, I immediately replace it with (999999999 / invalid). I’ve verified that this graph does not appear in the development set and works as a dummy graph. Whenever SMATCH encounters this graph, it will output an F1 score of 0.0 for that prediction, label pair since there are no matched triples.</p><p>Ideally, we would like to be more generous with partially correct graphs, but dealing with that is non-trivial and is probably something I will explore more after training and evaluating a model that is able to predict features.</p><h4>Example of Ill-formed Graphs</h4><p>Below is an example of an ill-formed graph that the model predicted. Though the parenthesis structure is well-formed (i.e. none are missing or mismatched), the model predicted that the node _hito_n was a re-entrancy, despite it not appearing anywhere else in the graph</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/482/1*YlYEDUelqNqShF1bnjc5RA.png"/>An example of the model predicting a re-entrancy that has not yet occurred in the graph.</figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/439/1*2QvzOMoTdU_BhDB8Zhj-ig.png"/>The target graph for the above example. The model’s prediction is pretty far off, but it’s interesting to see that it is able to have fairly high precision on the nodes that it is able to generate.</figure><p>The model that was trained on the featureless data was able to learn the parenthesis structure and there were no cases, that I could find, where the model predicted mismatched or missing parenthesis.’</p><h4>Baseline Evaluation Results</h4><p>Even with the harsh treatment of ill-formed graphs, the model was able to achieve a F1 score of 0.65 on the development dataset. This was much higher than I was expecting and seems to be promising for further exploration. I suspect that once I begin to train the model on data that includes features, the model will have a harder time making completely accurate predictions (though the F1 score will likely be inflated as explained in the next section)</p><h4>Ideas for Evaluating the Feature-full Model</h4><p>Though it’s nice to have the model correctly predict the mood, tense, etc. of a sentence, these may not be entirely helpful when evaluating the model. By including these features, we increase the number of triples that SMATCH looks for. There are a couple different ideas that Jan, Michael, and I discussed when it comes to evaluating the predicted graphs:</p><p>The first option is to leave the features squashed. This is probably the simplest approach, but is not ideal since it does not allow for partial credit. If the model misses a single feature (i.e. predicts the mood as tensed rather than untensed, the entire triple would be wrong even though other features are correct).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iQNyCAiGWw0w5YIXND8THw.png"/>Example of squashed features. Note this is the same example from last week’s post.</figure><p>The second option is to uncompress the features. In the case of the previous picture, it would be removing the equals signs and splitting the “super feature” based on the colons. This approach is a bit nicer in terms of giving partial credit, but is still not ideal since in increases the number of triples. We believe that this would inflate the SMATCH score to something that is not entirely useful and most of the score would be based on the feature triples and not the actual semantic meaning.</p><p>The third and final option we discussed was to selectively include features during evaluation. During training and prediction, the model would take in the entire squashed feature as input and output squashed features during prediction. However, we would uncompress the features and then choose a couple (or none at all) to keep when we post-process the graphs. With this, we can evaluate using a couple different combinations of features and see how those affect the model’s performance.</p><p>Some of the features the model predicts are: tense, mood, pass, etc. We can choose to keep only mood and tense if we believe that these are the most useful features for semantic transfer and see how that affects performance vs. a featureless model or some other combination of features.</p><h4>Training a Fully-featured Model</h4><p>Currently I’m training a model on data that includes the squashed features, though it will not be evaluated in time for this post or for the presentation. The model is the same exact model as the featureless model, so I expect that it may have a more noticeable issue matching parentheses and generating well-formed graphs in general until I have some time to experiment with the hyperparameters.</p><p>For reference, the models (both featureless and feature-full) are trained with the following architecture and hyperparameters:</p><pre>Encoder:<br/>    RNN Type       :  LSTM    <br/>    Embedding Dim  :  500</pre><pre>Decoder:<br/>    RNN Type       : Stacked LSTM<br/>    Layers         : 2<br/>    Embedding Dim  : 500<br/>    Dropout        : 0.3</pre><pre>Attention:<br/>    Type           : Global (<a href="https://github.com/spro/practical-pytorch/blob/master/seq2seq-translation/seq2seq-translation.ipynb">general [Luong]</a>)</pre><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=79ba10bbc70c" width="1"/></div>
    </content>
    <updated>2018-04-24T06:17:52Z</updated>
    <category term="machine-learning"/>
    <author>
      <name>Ryan Pham</name>
    </author>
    <source>
      <id>https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*83KfTWByl5pPq7A8_E8ApA.gif</logo>
      <link href="https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@ryanp97" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Ryan Pham on Medium</subtitle>
      <title>Stories by Ryan Pham on Medium</title>
      <updated>2018-05-15T04:00:06Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://deeplearningturingtest.wordpress.com/?p=16</id>
    <link href="https://deeplearningturingtest.wordpress.com/2018/04/20/strawman-baseline-1-deep-recurrent-q-network/" rel="alternate" type="text/html"/>
    <title>Strawman/Baseline 1: Deep Recurrent Q Network</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">For this week, I decided to first develop the RL model for asking questions. I chose to try a Deep Recurrent Q Network (DRQN) first (and the policy gradient method later) using the following repository as a starting point: https://github.com/awjuliani/DeepRL-Agents/blob/master/Deep-Recurrent-Q-Network.ipynb This repository implements the DRQN for games by using LSTM cells to encode sequential information … <a class="more-link" href="https://deeplearningturingtest.wordpress.com/2018/04/20/strawman-baseline-1-deep-recurrent-q-network/">Continue reading <span class="screen-reader-text">Strawman/Baseline 1: Deep Recurrent Q Network</span> <span class="meta-nav">→</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>For this week, I decided to first develop the RL model for asking questions. I chose to try a Deep Recurrent Q Network (DRQN) first (and the policy gradient method later) using the following repository as a starting point:</p>
<p><a href="https://github.com/awjuliani/DeepRL-Agents/blob/master/Deep-Recurrent-Q-Network.ipynb" rel="nofollow">https://github.com/awjuliani/DeepRL-Agents/blob/master/Deep-Recurrent-Q-Network.ipynb</a></p>
<p>This repository implements the DRQN for games by using LSTM cells to encode sequential information as successive frames are passed in for each time step. These frames are then passed through a CNN, then the LSTM cell, and then output the Q values. In the code I replaced where the input image (frame) is passed into the DRQN with the 2D word embedding matrix (GloVe vector for each word in sentence) and passed it straight into the CNN. I also gave a default reward of 0 to the model and managed to run the model without errors.</p>
<p>My goal for next week is to change the reward allocation to be user input, hardcode all the question templates, and begin training the model.</p></div>
    </content>
    <updated>2018-04-20T06:47:18Z</updated>
    <category term="Uncategorized"/>
    <author>
      <name>ananthgo</name>
    </author>
    <source>
      <id>https://deeplearningturingtest.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://deeplearningturingtest.wordpress.com/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://deeplearningturingtest.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://deeplearningturingtest.wordpress.com/osd.xml" rel="search" title="NLP Capstone Project Updates - Ananth" type="application/opensearchdescription+xml"/>
      <link href="https://deeplearningturingtest.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <title>NLP Capstone Project Updates – Ananth</title>
      <updated>2018-05-15T04:00:27Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-5600014144802012716.post-2741407940361589303</id>
    <link href="https://nlpcapstonesemparse.blogspot.com/2018/04/blog-4-strawman-i.html" rel="alternate" type="text/html"/>
    <title>Blog 4: Strawman I</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">I'm implementing the parser within the the wikitables semantic parser(Neural Semantic parsing with type constraints by Krishnamurthy et al) since both are solving similar tasks and it'd be a cool result if the same architecture worked for both tasks. The similarity is that both tasks need to generate the logical form which incorporates elements of a context. For wikitables its cell and column names and for this task its variable and method names.<br/><br/>Results:<br/><br/><ul><li>Wikitables framework - 4% accuracy.</li><li>Wikitables framework + parent states - 12% accuracy.</li></ul><div><br/></div><div>The wikitables baseline performs poorly and integrating the parent production rule used as input to the decoder cell in the java paper but not the wikitables paper results in a eight percent improvement. This is since the java production rule sequences are much longer and cannot just rely on the previous rule.</div><div> </div><br/>These results demonstrate that while that tasks are similar there are some key differences in the datasets that won't allow the exact same architecture to be used. Nonetheless, I will still be implementing the java parser within the wikitables framework incorporating necessary elements to boost performance.<br/><br/>My code is here:<br/><b>https://github.com/rajasagashe/allennlp/tree/enviro-linking</b></div>
    </summary>
    <updated>2018-04-19T19:13:00Z</updated>
    <author>
      <name>nlpcapstone</name>
      <email>noreply@blogger.com</email>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-5600014144802012716</id>
      <author>
        <name>nlpcapstone</name>
        <email>noreply@blogger.com</email>
      </author>
      <link href="https://nlpcapstonesemparse.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="https://nlpcapstonesemparse.blogspot.com/feeds/posts/default?alt=rss" rel="self" type="application/rss+xml"/>
      <title>NlpCapstone</title>
      <updated>2018-05-15T04:00:05Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/be87c31976b7</id>
    <link href="https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone | 04: First Steps</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><em>previous posts: </em><a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5"><em>01</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5"><em>02</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3"><em>03</em></a></p><p>Nearing 4 weeks in — I’ve finally got a foothold in the development process. Over this past week I’ve been looking through TensorBoard and TensorFlow source-code and documentation in an attempt to develop a foundation for plugin development.</p><p><strong>Notable Resources:</strong></p><ul><li><a href="https://www.tensorflow.org/programmers_guide/summaries_and_tensorboard">TensorBoard Documentation</a></li><li><a href="https://github.com/tensorflow/tensorboard">TensorBoard Source Code</a> and <a href="https://github.com/tensorflow/tensorboard/tree/master/tensorboard/plugins">Existing Plugins</a></li><li><a href="https://github.com/tensorflow/tensorboard-plugin-example/blob/master/README.md">Developing a TensorBoard Plugin</a> (a simple example)</li></ul><h4>Completed Milestones:</h4><ol><li>Understand the structure of a TensorBoard Plugin, specifically how the architecture of the Attention Plugin should look like.</li><li>Design and write the data fetching layer.</li></ol><h4>Plugin Architecture</h4><p>In TensorFlow, data from iterations of training / evaluation is stored as a set of <strong>summaries</strong>. These can take the form of any tensor, including text, image, scalars, or time series. These are written to disk as the computation graph is executed. Each ‘summary’ takes the form of a <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/framework/summary.proto">Summary protocol buffer</a>, which holds, in addition to the data stored, critical identifying information (tags and metadata). A plugin can then read summaries associated with particular tags and sessions from disk to serve to the TensorBoard front-end via a plugin back-end, where a visualization is rendered.</p><p>Following <a href="https://github.com/tensorflow/tensorboard-plugin-example/blob/master/README.md"><em>Developing a TensorBoard plugin</em></a><em>, </em>the Attention Plugin with have three primary components:</p><ol><li>Data API layer. This is what allows users to capture relevant summaries from within their models.</li><li>Plugin backend, which serves said summaries.</li><li>Frontend, where the visualizations are displayed.</li></ol><p>Unlike commonly used plugins such as the <a href="https://github.com/tensorflow/tensorboard/tree/master/tensorboard/plugins/scalar]">scalar</a> and <a href="https://github.com/tensorflow/tensorboard/tree/master/tensorboard/plugins/histogram">histogram</a> plugins, the Attention Plugin consumes 3 distinct values: the input text, the decoded output text, and the attention matrix that correlates the two. Initially, I attempted to store these all in a single Summary protobuf, where the first two rows of the encapsulating matrix would contain the text, and the rest would contain the attention weights. This results in a mixing of string and float types in a single Tensor, which is not valid (to my knowledge) in TensorFlow. I then realized I could store these separately, each in their own summary, and retrieve them via an identifying name. The resulting architecture is shown in the diagram below.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*QK7USkxsSC3u6F0LKbKWXQ.png"/>The architecture of the Attention Plugin.</figure><p>I decided to make the output text an optional summary, as models don’t necessarily need to decode (via Viterbi, Beam Search, or otherwise) an output sequence while training. The input text and attention matrix are still valuable, as summary statistics (e.g. coverage, important words, etc) can be gleamed without the decoded text.</p><h4>Data API Layer</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*0m1-fllpNYMP666FhR0nbA.png"/>Data API Layer highlighted in green.</figure><p>As the TensorBoard authors suggest, the data API layer, defined in attention_summary.py, provides two methods for creating Summary protobufs, which can then be written to disk via a FileWriter. The first is via a TensorFlow op, which can be thought of as a node in the computation graph, that produces a Summary when the graph is executed. The second is by directly creating the protobuf, which allows for data to be saved outside the execution of a TensorFlow session. I’ve implemented both of these. There is a separate method for each of the three datum used by the plugin (input text, output text, attention matrix), and each of the three summary datum are tagged differently (e.g. name/attention_input_summary, name/attention_output_summary) in order to allow for distinguishable retrieval later.</p><p>An example of the usage of both methods can be found in attention_demo.py.</p><h4>Next Steps</h4><p>I suspect the work completed this week was the biggest hurdle in terms of time:code ratio. I would not be surprised if I had to revisit the work done here in order to clean things up or fix small bugs. However, with this understanding and architecture nailed down, I expect implementation of the rest of the plugin will come at a faster pace. With that said, three tasks stand as immediate goals for the next week.</p><ol><li>Modify my forked repository of the summarization model created by <a href="https://arxiv.org/pdf/1704.04368.pdf">See et al.</a> (original found <a href="https://github.com/abisee/pointer-generator">here</a>) to produce and save the appropriate summaries for the Attention Plugin. I’ve already started looking into this, and expect to have to fiddle around with the training / evaluation scheme in order to grab an appropriate amount of data.</li><li>Implement the backend of the Attention Plugin.</li><li>Begin prototyping visualizations (pen &amp; paper) and acquire preliminary feedback.</li></ol><p>Until next time.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=be87c31976b7" width="1"/></div>
    </content>
    <updated>2018-04-19T06:33:40Z</updated>
    <category term="nlp"/>
    <category term="visualization"/>
    <category term="machine-learning"/>
    <category term="data-visualization"/>
    <category term="computer-science"/>
    <author>
      <name>Halden Lin</name>
    </author>
    <source>
      <id>https://medium.com/@halden.lin?source=rss-2759d54493c0------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*Hzu2ZqgloT0I1F6Kwg8OPA.jpeg</logo>
      <link href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@halden.lin" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Halden Lin on Medium</subtitle>
      <title>Stories by Halden Lin on Medium</title>
      <updated>2018-05-15T04:00:29Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/a6690114c441</id>
    <link href="https://medium.com/@viterbi.or.not/baseline-model-1-a6690114c441?source=rss-c522ef075bb3------2" rel="alternate" type="text/html"/>
    <title>Baseline Model #1</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*bGQmjLRpsY3UnYhK6e8Lyg.png"/></figure><p>This week, we implemented our <a href="https://github.com/viterbi-or-not-to-be/viterbi-or-not-to-be/tree/master/baseline">first baseline model</a> for conversation summarization. In order to create a baseline that would be useful to build off of and compare our future results to, we decided to base this model off the Naive Bayes implementation described in the paper <a href="http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf"><strong>Summarizing Online Conversations: A Machine Learning Approach</strong></a>.</p><p>To begin with, we identified the W3C Email Threads dataset as a useful starting point because of the fact that we have access to multiple email datasets, and because the paper mentioned above indicated that chatlog data would require a great deal of additional preprocessing to be able to manipulate. By comparison, the email data is fairly simple to interpret because it is rare for a single sender to convey their portion of a message across multiple emails, and the writing is generally more grammatically well-formed. The experiments in the paper run on the <a href="https://flossmole.org/content/software-archaeology-gnue-irc-data-summaries">GNUe Archives</a> and the <a href="https://www.cs.ubc.ca/cs-research/lci/research-groups/natural-language-processing/bc3.html">BC3 Corpus</a> (annotated W3C Email Threads).</p><p>The paper also uses <a href="https://www.cs.waikato.ac.nz/ml/weka/">Weka Toolkit</a> for all of its model implementations, so we initially aimed to use Weka as well to reproduce our baseline. However, we encountered a few challenges while starting out with Weka that ultimately led to our abandoning the platform in favor of a more flexible Python implementation. The email data is in XML format, whereas Weka appears to work best with a format called ARFF, and in our preliminary examination we found ARFF to be fairly difficult to map directly to XML. In particular, ARFF’s apparent inability to handle dynamic-length data types or nested relations made it challenging to plan around — this was a problem because for each training example (email thread) in our dataset, we have a variable-length amount of information (number of emails, number of sentences per email, number of words per sentence, etc.). Without usage of dynamic-length data coupled with a toolset/interface more suited to data mining and application of basic, pre-made machine learning models than detailed feature engineering, we found Weka specifically difficult to use for feature extraction.</p><p>Instead, we ended up deciding to implement the baseline model in Python — including parsing the XML from our chosen dataset, extracting features, and using SciKit-Learn to train a Naive Bayes model to form the baseline itself. Since our aim with the baseline was to re-implement at least part of the work done by the <a href="http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf"><strong>Summarizing Online Conversations: A Machine Learning Approach</strong></a> paper, we also chose to set up evaluation that would mirror their evaluation techniques, and settled on using a previously-written implementation of ROUGE for the task. Re-implementing the baseline model in Python based on previous work took more effort than using Weka would have, but was advantageous in that it helped us understand the specific challenges of the task and resulted in somewhat extensible code we can adapt for later phases of the project.</p><h4><strong>Feature Selection</strong></h4><p>The Feature Selection section of the paper notes a “basic feature set,” which refers to features that are “not specific to conversations and consider the conversation as a simple piece of text.” For our baseline, we decided to target only the basic features to establish the difference that can be made by using conversation-specific features. Based on this basic set, our Naive Bayes baseline incorporates the following features —</p><p><strong>Mean TF-IDF: </strong>Term frequency-inverse document frequency (TF-IDF) characterizes frequency of a word and reflects its importance to an email thread. Calculating TF-IDF results in a vector of word frequencies per email, and we take the mean of the values in the vector for the mean TF-IDF feature.</p><p><strong>Mean TF-ISF: </strong>Similar to TF-IDF but at a different granularity, term frequency-inverse sentence frequency (TF-ISF) characterizes frequency of a word and reflects its importance to an email. Calculating TF-ISF results in a vector of word frequencies per sentence, and we take the mean of the values in the vector for the mean TF-ISF feature.</p><p><strong>Sentence Length: </strong>Number of characters in the sentence.</p><p><strong>Sentence Position: </strong>Index of the sentence within the email.</p><p><strong>Similarity to Title: </strong>We represent the name of an email thread as a TF-ISF title vector, in the same form as described earlier (without taking the mean). This feature is then the result of the cosine similarity between the TF-ISF vector for a sentence and the title vector.</p><p><strong>Centroid Coherence: </strong>We represent the centroid of an email thread as the average of the TF-ISF sentence vectors. This feature is then the result of the cosine similarity between the averaged centroid vector and the sentence vector.</p><p><strong>Special Terms: </strong>Numbers and proper nouns are deemed as ‘special terms.’ This feature is the count of special terms in a sentence normalized (divided) by the number of special terms in the email thread.</p><h4><strong>Results and Evaluation</strong></h4><p>After implementing our baseline model, we used the ROUGE package to evaluate its summarization on a variety of metrics. We split the data into training and testing segments, placing 80% of email threads in the training set and 20% in the testing set. We then used our model and features to generate summaries and used ROUGE-L to measure their performance. After computing the average ROUGE-L, ROUGE-1, and ROUGE-2 F1 scores across all the email threads in the testing set, we produced the following results (along with the results reported in the baseline paper for comparison):</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vjlGJvdBn_k4obtMdkGdIA.png"/>Mean F1 scores for various ROUGE metrics, compared to the results from <a href="http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf"><strong>Summarizing Online Conversations: A Machine Learning Approach</strong></a></figure><h4><strong>Error Analysis</strong></h4><p>It is certainly helpful to have a set of metrics like ROUGE to establish a comparison between our model and existing models, but for a task such as automatic summarization it is an unfortunate reality that no existing metrics really come close to fully capturing the “success” of a summary. Comparing the compositions of two summaries provides valuable insight into the performance of a model, but ultimately a great deal of the usefulness of a summary revolves around its ability to convey the information contained in a conversation without needless filler and in a logical, simple format. Because there are no metrics that can describe how well a summary captured the topics in a conversation or how understandable it is, we will have to rely heavily on human interpretation to judge the success of our model.</p><p>For our baseline, we took a look at the generated summaries and discovered that while the general topic of each email thread is easily discernible, it is sometimes difficult to follow the course of the discussion. In addition, we found that our summaries were especially susceptible to the inclusion of “fluff” — short, choppy sentences or signature elements with no relevance to the actual contents of the summary that simply obstructed the reader. Perhaps our future attempts will have to target this with features specifically designed to identify things like email signatures or greetings, to help distinguish between these sources of “fluff” and the actual content of each email. Notably, this is not an issue that chatlog data suffers from, because there are typically fewer signatures or static portions of chats to ignore.</p><p>Our analysis is exemplified by the sample summary and its annotated counterpart below:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ycgusov-GEUfQm7C."/>Summary for an email thread generated by our baseline model</figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*aOxikqivuOMXLgnM."/>Summary for the same email thread from the dataset annotation</figure><h4><strong>Future Improvements</strong></h4><p>Although our baseline model provided a useful point of comparison for future efforts, we were not able to entirely replicate the results of the paper we based it off of. Despite using the same features that they described, we achieved a significantly lower mean ROUGE-L F1 score of 0.409 as compared to their 0.245 for the same dataset. As a result, it seems that an important next step would be to identify the discrepancies between our implementation and theirs to try and faithfully reproduce their results before moving on to other models.</p><p>One possible issue we identified with our model could be the lack of a topic boundary preprocessing step as found in the research paper. Although their description made it seem as though the technique mainly applied to chatlog data, it is possible that performing such a preprocessing step would bring our model’s performance closer to theirs. The paper describes two different approaches at a very high level, so further research and experimentation would be needed to determine a reasonable implementation to perform such a task. In addition, there were various parameters left out of the paper’s description that could affect the model’s performance, such as ROUGE evaluation parameters and the implementation of Naive Bayes, which could have made an impact.</p><p>After finishing our baseline implementation, we plan to implement further models to address this task. The paper we previously mentioned uses a number of other approaches, so one direction we plan to move in is selecting other potentially effective models from their list and implementing them (decision trees look the most promising and would require very little modification to the code). Afterwards, we plan to address the other datasets, and then move into feature engineering and tweaking our implementations to produce our minimum viable product.</p><h4>Code</h4><p>As mentioned in our first blog post, the full code for our project is <a href="https://github.com/viterbi-or-not-to-be/viterbi-or-not-to-be">available on Github</a>, which currently includes usage instructions located in the README.md file for the baseline directory that can guide a user through the process of setting up the model, producing summaries, and running the ROUGE evaluation. We certainly have a long way to go in terms of code organization and cleanliness, but this baseline implementation at least allows for a preliminary examination of the task and produces the results necessary to interpret the rest of our model approaches with appropriate context.</p><p>Edited 4/24 to add baseline dog.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a6690114c441" width="1"/></div>
    </content>
    <updated>2018-04-18T06:55:14Z</updated>
    <category term="nlp"/>
    <author>
      <name>Viterbi Or Not To Be</name>
    </author>
    <source>
      <id>https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*wiisg40Bu4z11RTWJ66mnA.png</logo>
      <link href="https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@viterbi.or.not" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Viterbi Or Not To Be on Medium</subtitle>
      <title>Stories by Viterbi Or Not To Be on Medium</title>
      <updated>2018-05-15T04:00:26Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-3753031463594823927.post-8569998071322028844</id>
    <link href="https://cse481n.blogspot.com/2018/04/blog-post-4.html" rel="alternate" type="text/html"/>
    <title>Blog Post #4</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><div dir="ltr" id="docs-internal-guid-7937c8af-d777-ed0f-f77b-cf09623b985e" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">A big part of our work for setting up a baseline is the creation of a reasonably good dataset for training and evaluating extractive text summarization. Our goal was to build a dataset with all sentences from the articles marked with binary labels indicating whether or not they were part of the extracted summary.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">We used the DailyMail and CNN story dataset, which is meant for abstractive summarization, to build our own dataset. The data set includes automatically-parsed lines from news articles, as well as a few bullet point highlights for each article. These highlights are not sentences directly from the article, but are overall a decent indicator and considered to be one of the most useable datasets out there (if for no other reason than sheer volume of data).</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">To build our data set, we used a toy metric roughly based off of ROUGE-N, with the understanding that we would only need a way of relative ranking for each sentence.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">The procedure to generate the data set was as follows:</span></div><ol style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Read in a single .story file from the abstractive dataset into highlights and sentences.</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Post-process sentences- in the original data, new lines do not correspond exactly with sentence endings. Additionally, some sentences are originally split arbitrarily by new lines. We do an additional split by the regex (?&lt;=[.?!])\s+ (whitespace with period, question mark, or exclamation mark lookbehind), but sentence “re-joining” is off by default, as some sentences in the original dataset do not end with punctuation.</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Score each sentence with our metric.</span></div></li><ol style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Tokenize each sentence and highlight.</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Build unigram, bigram, and trigram lists.</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Count the number of matches between the sentence and all the highlights, giving more weight to bigram and trigram matches and also weighting by word length.</span></div></li></ol><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Sort sentences by score.</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Let S be the number of sentences and H be the number of highlights. The algorithm picks up to min(1, floor(S/2)) sentences as part of the summary. It picks at least the H sentences with the highest scores. After sentence H is picked, subsequent sentences will only be picked if their score was at least (80+3*X)% of the previously-picked sentence’s score, where X is the number of sentences currently picked. This is effectively a fairly arbitrary metric to pick the most likely sentences roughly in accordance with the size of the abstractive summary, while also allowing for particularly similar sentences to both be chosen for completeness.</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">All data input and output with UTF-8 encoding.</span></div></li></ol><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Output format:</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">&lt;#&gt; &lt;SENTENCE PLAINTEXT&gt;</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;"># is either 0 = normal sentence in the article, 1 = sentence chosen as part of extractive summary, 2 = original abstractive summary (should not be touched by model, only left there for human reference). </span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Overall, we think our data set is generally reasonable and makes sense. Nonetheless, there are a number of weaknesses with both extractive models in general and this specific type of dataset (including some problems which derive from the original abstractive dataset).</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Key weaknesses of data set:</span></div><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">In the original data, highlights do not always correspond to actual information in the article. For example, this short story has four highlights that are all new information: 008fc24ca9f4c48a54623bef423a3f2f8db8451a.story.</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Frequent formatting problems - sentences that don’t terminate with punctuation, repeated sentences, bugged unicode characters, etc.</span></div></li></ul><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Key weaknesses specific to extractive summarization:</span></div><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Articles that are particularly short are effectively impossible to meaningfully summarize with extractive techniques.</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Some sentences in articles contain the same content with slightly different wording. In these cases, we decided to choose both sentences, with the idea that post-processing could take care of highly-similar sentences, but a model could not be expected to accurately distinguish between two such sentences if they have different labels.</span></div></li></ul><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">The Baseline Model:</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">For our baseline combinatorial approach, we did a simple Maximum Coverage Problem implementation. The Maximum Coverage Problem is a classic NP-complete problem. Given a collection of n sets, the goal is to maximize the number of chosen (or “covered”) elements while only choosing k of the sets (where k &lt; n). It’s very straightforward to reduce summarization to this problem. The sentences in the document are the sets, and the vocabulary of the document represents the “universe”, or the elements in the sets. The goal is to cover as many words as possible while picking the same number of sentences as in the labelled summary. The intuition is that sentences with more words capture more semantic meaning, and once a word is listed in the summary, that word need not be considered again. This reduction makes some intuitive sense, but two main aspects must be refined. First, not all words are equally meaningful. Some words, like “a”, “the”, or “and”, have little semantic content, while named entities and other important words have much higher semantic content. Second, we should at least account for sentence lengths -- instead of constraining the algorithm to pick the same number of sentences, we should constrain it to the same word count. This two additional criteria turn the problem into the Budgeted Maximum Coverage Problem: elements in the sets have specified values, and the sets have specified costs. The new objective is to maximize the total value of the covered elements while remaining with a given budget.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Of course, this problem is NP-complete, so it may seem like a strange choice to model summarization with. There are two approaches to this. First, a simple greedy algorithm achieves an approximation of ~63%, which means that the greedy algorithm is guaranteed to get at least 63% of the value of the optimal solution. For the standard MCP, the greedy algorithm just chooses the set with the most uncovered elements until no more sets are allowed. For the budgeted MCP, the approximation algorithm is slightly more complex. See Khuller et al. for a detailed look at it -- the algorithm is slightly more work, but still very understandable, and achieves the same approximation bound.  We can also formulate the problem as an Integer Linear Program (ILP) and use an ILP solver to generate optimal solutions on realistic instance sizes. This works because the documents and sentences are both small.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">For now, we are using the greedy algorithm for the standard MCP. As a simple metric, we used the number of correct chosen sentences divided by the number of chosen sentences in total (correct means that the gold standard also picked that sentence). With a basic MCP approach, we had an accuracy of 0.218. This was measured on a small sample of 2000 stories. In order to approximate a weighting scheme, we use a stop list to simply remove common articles and other semantically empty words. With this small modification, we had an accuracy of 0.2328.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">We plan to extend this to a better baseline model in the next few days. We will formulate the problem as an ILP and pass it to an ILP solver for an optimal solution. We will also implement a more sophisticated weighting scheme. One idea is to use some of the labelled data as training data (right now, we don’t train) to build a weight matrix for common words -- we can build this matrix with a logistic regression, using n-gram (probably unigram) similarity as the loss function.This will hopefully give us a more reasonable baseline model.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Evaluation Framework:</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">For now, we’re using a simple accuracy metric. We plan to switch to ROUGE, which counts n-gram similarity (ROUGE measures recall, not precision). We will work with the ROUGE-2.0 Java package or pyrouge, depending on which language we are working with. </span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">So to summarize our goals for the next week, we will improve this baseline model by formulating the problem as an ILP and we may implement a weighting scheme (if that’s too complicated, we’ll save it for the advanced model). We will also build a baseline neural model. Then, we’ll flesh out our evaluation framework using ROUGE metrics, train/test using more of the corpus, and have detailed error analysis.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 700; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">References:</span></div><div dir="ltr"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Khuller, S., Moss, A., &amp; Naor, J. (Seffi). (1999). The Budgeted Maximum Coverage Problem. </span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Inf. Process. Lett.</span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">, </span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">70</span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">(1), 39–45. https://doi.org/10.1016/S0020-0190(99)00031-9</span></div></div>
    </summary>
    <updated>2018-04-18T06:25:00Z</updated>
    <author>
      <name>Ron &amp;amp; Aditya</name>
      <email>noreply@blogger.com</email>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-3753031463594823927</id>
      <author>
        <name>Ron &amp;amp; Aditya</name>
        <email>noreply@blogger.com</email>
      </author>
      <link href="https://cse481n.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="https://cse481n.blogspot.com/feeds/posts/default?alt=rss" rel="self" type="application/rss+xml"/>
      <title>PrimeapeNLP</title>
      <updated>2018-05-15T04:00:28Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/15357a82fe06</id>
    <link href="https://medium.com/nlp-capstone-blog/first-impressions-baselines-and-the-evaluation-framework-15357a82fe06?source=rss----9ba3897b6688---4" rel="alternate" type="text/html"/>
    <title>First Impressions: Baselines and the Evaluation Framework</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>Ultimately, our goal is to go beyond basic language modeling and create a new text generation architecture conducive to producing technical definitions. To get a feel for the data though, we approach it with familiar, simple baselines that give us a foundation in which we can improve from.</p><p>The baselines that we’ve experimented with are</p><ul><li><strong>Vanilla RNN:</strong> Hidden states as a function of the input and the previous hidden state, with Tanh activation (in particular, we’re using the <a href="https://medium.com/@tamdangnadmat/first-impressions-baselines-and-the-evaluation-framework-15357a82fe06">Elman Network</a>).</li><li><strong>GRU:</strong> An RNN architecture that learns to throttle the influence and usage of particular parameters on inference using a gating mechanism.</li><li><strong>LSTM: </strong>Another RNN architecture that specializes in intelligently remembering relevant details and forgetting irrelevant details through several gating mechanisms and a “cell state” in addition to the conventional hidden states. <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">Here’s more detail</a> about this particular kind of RNN.</li></ul><p>All baselines were trained as language models with cross entropy loss and were used to get a sense of how learnable the language of the Semantic Scholar dataset is. The metrics we are focusing on now are</p><ul><li><strong>Perplexity: </strong>A measure of how “confused” the model is at any point it’s attempting to predict the next word.</li><li><strong>Feature extraction through hidden states:</strong> Can the hidden states be used as features for a classification task?</li></ul><p>Our first metric is fairly straightforward; we calculate the aggregate sum of log probabilities for every word in the corpus and normalize by the size of the corpus.</p><p>Our second metric however, is inspired by Dieng et al.’s method for sentiment analysis in <a href="https://www.semanticscholar.org/paper/TopicRNN%3A-A-Recurrent-Neural-Network-with-Semantic-Dieng-Wang/412068c7e8e77b73add471789d58df3d2f3e08d8">TopicRNN</a>, in which the final hidden states after a forward pass of the model on a movie review were used to predict positive or negative sentiment using a single-layer neural network. We aim to adopt this metric from a multi-class classification perspective in which the passages we use are excerpts of research documents with an omitted, technical term. The question we aim to answer with this metric is “is the model capable of representing semantics in a latent space?”</p><p>Our labels will then be a defined set of these omitted, technical terms, and our goal will then be to predict them given the hidden states of the passage via a two-layer neural network. The framework for this evaluation metric can be found in <a href="https://github.com/NLP-Capstone-Project/machine-dictionary/tree/evaluation">this branch</a> of our codebase.</p><h4>Why we chose these metrics</h4><p>Our task is fairly novel given the way we’re approaching it, so currently no dataset exists that pairs domain-specific words with definitions that are to the caliber of research technicality. Because of this, metrics that depend on gold standards such as ROUGE and BLEU are currently out of reach at this time.</p><p>There’s a chance we’ll experiment with these metrics if we can find a labeled dataset to supplement Semantic Scholar’s Open Research Corpus. We are also considering using the publications themselves as the gold standards, which may be helpful since a desirable trait of our model would be its ability to produce language similar to that of the corpus.</p><h3>Challenges Encountered while Baselining</h3><p>In establishing our baselines and metrics, there were several issues we ran into, both in training.</p><h4>Dealing with a larger corpus</h4><p>Given that our baselines are language models, and that our later prototype models will most likely contain an LM component, we have to deal with efficient learning given there are several million documents to process.</p><p>For efficient backpropagation, we opted to introduce a “backpropagation through time” as a hyperparameter defaulted at 50, which specifies the number of words we allow the model to see before updating our parameters.</p><p>Currently, batching is supported by our codebase but was not used in our initial experiments. Given that it takes roughly one minute for the GPUs on the cloud to process a single publication, we plan to concatenate document vectors and reshape into batch-by-length tensors in the future.</p><h4>Sorting By Domain</h4><p>We’d like our model to be trained on a single domain/field of study for our future case studies comparing dictionaries built on one domain versus others. This is further motivated by some of our experiment results discussed later, how loss tends to spike between documents.</p><p>Currently, the Semantic Scholar Open Research Corpus doesn’t include anything in the set of JSON fields that we could find for filtering the data. However, we’ve been assured by AllenNLP researchers that its possible to sort the data by research domain. We may performing another round of baseline experiments once we’ve sorted the data, but for now the results below are on publications of mixed domains.</p><h3>Experimental Results</h3><p>The Semantic Scholar Open Research Corpus provides a sample subset of its dataset: a JSON file containing 4000 entries. Within each entry, the URL of the publication’s online PDF is provided. We use a GET request to <a href="https://github.com/allenai/science-parse">AI2’s Science Parse</a> service to extract the PDF contents.</p><p>From there, we run our experiments on 121 of the 4000 extracted documents, stopping training early at 15 documents and calculated perplexity on a validation set of 30 documents. The total vocabulary used was 11,330 words. Words outside of this vocabulary are replaced with an unknown token at training and test time.</p><p>Loss is calculated and normalized on the last 50 words the model is trained on.</p><ul><li><strong>Elman RNN:</strong> Perplexity of 250.25 with an average loss of 7.908 over the last 50 words.</li><li><strong>GRU:</strong> Perplexity of 265.50 with an average loss of 7.085 over the last 50 words</li><li><strong>LSTM:</strong> Perplexity of 261.95 with an average loss of 6.588 over the last 50 words</li></ul><p>Perplexities calculated using untrained models (with randomized parameters) were several orders of magnitude larger than the ones listed above, so it’s good to know that our baseline models can learn a significant amount of surface-level patterns with such a small subset of the corpus.</p><p>In terms of feature extraction and classification, the framework has been implemented but the data for this has not been created yet. We plan on evaluating our baselines along with our final model on this metric using publications from Semantic Scholar after establishing a vocabulary of semantically significant technical terms and creating the dataset using those terms. This will involve iterating over documents and replacing occurrences of these technical terms with a specialized, unknown token that won’t aid in inference.</p><h3>Conclusion</h3><p>Our methods helped us familiarize ourselves with the data as well as handle significant amounts of overhead in terms of processing the data, toggling between different models, and integration of our evaluation metrics in an organized fashion.</p><p>We are excited to see how novel architectures tailored to the task perform on these metrics!</p><p>To keep up to date with our progress in baselining, evaluation, and other things, you can watch <a href="https://github.com/NLP-Capstone-Project/">this repository</a>.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=15357a82fe06" width="1"/><hr/><p><a href="https://medium.com/nlp-capstone-blog/first-impressions-baselines-and-the-evaluation-framework-15357a82fe06">First Impressions: Baselines and the Evaluation Framework</a> was originally published in <a href="https://medium.com/nlp-capstone-blog">NLP Capstone Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></div>
    </content>
    <updated>2018-04-18T05:40:07Z</updated>
    <category term="capstone"/>
    <category term="machine-learning"/>
    <category term="deep-learning"/>
    <category term="nlp"/>
    <author>
      <name>Tam Dang</name>
    </author>
    <source>
      <id>https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4</id>
      <logo>https://cdn-images-1.medium.com/proxy/1*TGH72Nnw24QL3iV9IOm4VA.png</logo>
      <link href="https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/nlp-capstone-blog" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>A Journey Through CSE 481N, the Natural Language Processing Capstone Course at the University of Washington - Medium</subtitle>
      <title>NLP Capstone Blog - Medium</title>
      <updated>2018-05-15T04:00:25Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://mathstoc.wordpress.com/?p=314</id>
    <link href="https://mathstoc.wordpress.com/2018/04/18/nlp-capstone-post-3-baseline-and-midi-frustration/" rel="alternate" type="text/html"/>
    <title>NLP Capstone Post #4: Baseline and MIDI Frustration</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Baseline model Our baseline approach is taken from Daniil Pakhomov’s excellent blog post[1]. In this post, two separate RNNs are trained as generators: one for lyrical content and one for music content (in piano roll format). We will begin by using his trained lyrical model, and attempt to do conditional sampled character generation given a … <a class="more-link" href="https://mathstoc.wordpress.com/2018/04/18/nlp-capstone-post-3-baseline-and-midi-frustration/">Continue reading <span class="screen-reader-text">NLP Capstone Post #4: Baseline and MIDI Frustration</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h1><b>Baseline model</b></h1>
<p><span style="font-weight: 400;">Our baseline approach is taken from Daniil Pakhomov’s excellent blog post[1]. In this post, two separate RNNs are trained as generators: one for lyrical content and one for music content (in piano roll format). We will begin by using his trained lyrical model, and attempt to do conditional sampled character generation given a starting sequence of characters. We loaded the already trained models from the blog post and generated lyrics according to the style of a given songwriter and with a given seed word. The lyrics are generated via a character-level LSTM and generates the next character conditioned on the preceding characters and choice of songwriter. The model is trained on a corpus of song lyrics, where naturally the “correct” character to generate is the next character in the lyrics. Essentially the same mechanism is applied to the musical note generation.</span></p>
<p><span style="font-weight: 400;">The characters are encoded as a one-hot vector over all letters in the English alphabet plus space, comma, etc. Piano rolls already come in an encoding amenable to feeding into RNNs, modulo additional zero padding to ensure every time slice of every piano role has the same dimension. In particular, at each time step (discretized in an appropriately fine-grained way), we have an indicator 0-1 vector on which notes are currently activated.</span></p>
<p><span style="font-weight: 400;">Here is a song generated in the style of “Queen” with the starting seed sequence of characters “Music”:</span></p>
<blockquote>
<p style="text-align: center;"><i>Music savor valerite – yah  </i></p>
<p style="text-align: center;"><i>Imabribot, bind me – I – well  </i></p>
<p style="text-align: center;"><i>All going down to L</i></p>
<p style="text-align: center;"><i>At the eyes of the universe  </i></p>
<p style="text-align: center;"><i>Agree, five to the Slim  </i></p>
<p style="text-align: center;"><i>I just want to convincide  </i></p>
<p style="text-align: center;"><i>We wash stars and quiet Ich  </i></p>
<p style="text-align: center;"><i>You had a dirty old baby  </i></p>
<p style="text-align: center;"><i>We won’t  </i></p>
<p style="text-align: center;"><i>We does nothing no one ezy? follohin?  </i></p>
<p style="text-align: center;"><i>Sometimes we get down and ooh  </i></p>
<p style="text-align: center;"><i>Nothing do you see all night  </i></p>
<p style="text-align: center;"><i>  </i></p>
<p style="text-align: center;"><i>This is my pries  </i></p>
<p style="text-align: center;"><i>  </i></p>
<p style="text-align: center;"><i>Joyful the world  </i></p>
<p style="text-align: center;"><i>Does their beams  </i></p>
<p style="text-align: center;"><i>Surgeon makes the scule la beat  </i></p>
<p style="text-align: center;"><i>Walking out on my pocket ride  </i></p>
<p style="text-align: center;"><i>My faulty power  </i></p>
<p style="text-align: center;"><i>I wear from the ston</i></p>
</blockquote>
<p><span style="font-weight: 400;">Eventually, since we are actually interested in converting the musical information into plausible lyrics, we will need to modify this baseline in the natural way to take as input time slices of the musical instrumentation in piano roll format and predict characters (or syllables) that are to be enunciated simultaneously with the played notes. In this manner, the lyrics come already aligned in a natural way, and the words can be extracted by compressing the letters occurring between spaces.</span></p>
<h1><b>Dataset parsing</b></h1>
<p><span style="font-weight: 400;">The MIDI format has an unfortunate number of unexpected caveats. We have spent a majority of our time so far cleaning the data and attempting to use it in existing Python libraries that handle MIDI. A brief description of MIDI[2] covers some of the challenges:</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">MIDI is made up of a series of messages, such as notes, instruments, and tempo changes. Additional metadata messages exist called meta messages, which can contain text content such as the song title (and lyrics!). In our dataset, lyrics are provided either as “text” messages or as “lyrics” messages.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Messages are grouped into different tracks, often representing separate instruments. Metadata sometimes is located in its own track, and lyrics are sometimes found in a different track from the rest of the metadata.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Durations in the MIDI format are specified as a delta-time relative to the most recent frame. Delta times are in a unit called a tick. Ticks are defined in the file header as a division of the quarter note. The header also defines the number of ticks per frame, which is what the deltas are relative to. Beats per minute (bpm) messages adjust the speed of playback throughout the song.</span></li>
</ul>
<p><span style="font-weight: 400;">The most promising library so far is PrettyMIDI[3], which handles most of the unexpected behavior of the basic MIDI format. This library wraps MIDI messages into structured python objects, and provides a conversion from MIDI into piano roll format. Piano roll in this case is a numpy array of shape (num_notes, num_frames). This allows us to input the musical data directly into an RNN. The units are also converted into absolute seconds, as opposed to relative durations. PrettyMIDI can additionally handle embedded lyrics, but this has proven to be a challenge due to the variety of annotation styles in our dataset. About 200 of our 900 files have parsed lyric data properly, so continuing to clean our data is a high priority.</span></p>
<h1><strong>U</strong>pd<strong>ate</strong></h1>
<p><span style="font-weight: 400;">Unfortunately, we have found the Kara1k dataset[4] to be inapplicable to our project, as the raw sequence of musical notes and lyrical content are not provided, only metadata that the dataset developers have extracted.</span></p>
<h1>References</h1>
<p><span style="font-weight: 400;">[1] </span><a href="http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/"><span style="font-weight: 400;">http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/</span></a></p>
<p><span style="font-weight: 400;">[2] </span><a href="http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html"><span style="font-weight: 400;">http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html</span></a></p>
<p><span style="font-weight: 400;">[3] </span><a href="http://craffel.github.io/pretty-midi/"><span style="font-weight: 400;">http://craffel.github.io/pretty-midi/</span></a></p>
<p><span style="font-weight: 400;">[4] </span><a href="http://yannbayle.fr/karamir/kara1k.php"><span style="font-weight: 400;">http://yannbayle.fr/karamir/kara1k.php</span></a></p></div>
    </content>
    <updated>2018-04-18T04:58:56Z</updated>
    <category term="NLP Capstone"/>
    <author>
      <name>Nicholas Ruhland</name>
    </author>
    <source>
      <id>https://mathstoc.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://mathstoc.wordpress.com/category/nlp-capstone/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://mathstoc.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://mathstoc.wordpress.com/osd.xml" rel="search" title="Mathematical Distractions" type="application/opensearchdescription+xml"/>
      <link href="https://mathstoc.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A recreational (occasionally research) blog on topics in maths or computer science - by Kuikui</subtitle>
      <title>NLP Capstone – Mathematical Distractions</title>
      <updated>2018-05-15T04:00:30Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-9203775015655831448.post-1250926726356516395</id>
    <link href="https://teamoverfit.blogspot.com/2018/04/4-milestone-strawmanbaseline-i.html" rel="alternate" type="text/html"/>
    <title>#4 Milestone: Strawman/Baseline I</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h2 style="height: 0px;"><span>Team Overfit</span></h2><h3><span><br/></span></h3><h3><span>Project repo: <span style="font-size: 18.72px;"><a href="https://github.com/pinyiw/nlpcapstone-teamoverfit">https://github.com/pinyiw/nlpcapstone-teamoverfit</a></span></span></h3><h4><span>Team members: Dawei Shen, Pinyi Wang, Xukai Liu</span></h4><div style="text-align: start; text-indent: 0px;"><div style="margin: 0px;"><div><span><b>Blog Post: #4: 04/17/2018</b></span></div><div><span><span><b><br/></b></span></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Social Media Predicts Stock Price (StartUp Mode)</span><br/><br/><span>This week, we experimented with crawling data by querying from Twitter website, but we had some struggles finding the meaningful data set. Firstly, the Twitter API does not support fetching tweets prior than 7 days, so we have to write bash scripts and use a crawler to strip data from website, which is comparatively slower.</span><br/><span id="docs-internal-guid-945a652a-d716-7ba2-4653-bdd5ec706d01"><a href="https://github.com/Jefferson-Henrique/GetOldTweets-python"><span>https://github.com/Jefferson-Henrique/GetOldTweets-python</span></a></span><br/><span><br/></span><span>We tried to query keywords like Apple, iPhone, iPad. Lots of tweets we got are not in English, so we used language detection tools to filter out tweets in other languages. Unfortunately, there are too much giveaway and advertisement flooding on the platform. Some examples are:</span><br/><blockquote class="tr_bq"><span>"Microsoft planning to launch Surface Pro 6 in first quarter of 2017"</span></blockquote><blockquote class="tr_bq"><span>"KFire TV Giveaway: Win a Microsoft Bluetooth Mouse. http://kodifiretvstick.com"</span></blockquote><blockquote class="tr_bq"><span>"Microsoft Releases The 'Studio', Its First Desktop Computer"</span></blockquote><blockquote class="tr_bq"><span>"Like - free microsoft points world http://freemicrosoftpointsworld.weebly.com/"</span></blockquote><span>Therefore, for out strawman model #1 we decide to use the relative news headlines under twitter search query.</span><br/><span><br/></span><span>We searched companies' names like Google, Microsoft, Tesla to find relative new headlines and use unigram (bag of words) to put it in a decision tree model with random forest mechanism to predict the price go UP or DOWN. We had mixed results using this model. This is just our first attempt to see whether the twitter data is useful to predict the movement of future stock prices.</span><br/><span><br/></span><span>AAPL GOOG MSFT AMZN</span><br/><span>53.66% 58.53% 56.10% 37.50%</span><br/><span><br/></span><span>Next week, we'll try to use deep neural network as predictive model and expand our input to the user feedback of the product from general users.</span><br/><blockquote class="tr_bq"/><blockquote class="tr_bq"/><blockquote class="tr_bq"/><blockquote class="tr_bq"/><blockquote class="tr_bq"/></div></div></div></div>
    </summary>
    <updated>2018-04-18T04:47:00Z</updated>
    <author>
      <name>Team Overfit</name>
      <email>noreply@blogger.com</email>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-9203775015655831448</id>
      <author>
        <name>Team Overfit</name>
        <email>noreply@blogger.com</email>
      </author>
      <link href="https://teamoverfit.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="https://teamoverfit.blogspot.com/feeds/posts/default?alt=rss" rel="self" type="application/rss+xml"/>
      <title>NLP Capstone</title>
      <updated>2018-05-15T04:00:30Z</updated>
    </source>
  </entry>

  <entry>
    <id>http://sarahyu.weebly.com/cse-481n/first-strawman-attempt</id>
    <link href="http://sarahyu.weebly.com/cse-481n/first-strawman-attempt" rel="alternate" type="text/html"/>
    <title>First Strawman Attempt</title>
    <summary>Well...here's the first hiccup: the Reddit data I'd like to use is much too large (like 8GB compressed and unknown uncompressed for one month of posts). Since my last post, I had been working on trying to scrape the data manually through Reddit API requests, but I was running into some issues and it was taking quite a while because of the request restrictions.I decided, maybe a little later than I should have, to use the Reddit Data dumps provided by John Baumgartner at pushshift.io instead, but [...]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><div class="paragraph">Well...here's the first hiccup: the Reddit data I'd like to use is much too large (like 8GB compressed and unknown uncompressed for one month of posts). Since my last post, I had been working on trying to scrape the data manually through Reddit API requests, but I was running into some issues and it was taking quite a while because of the request restrictions.<br/><br/>I decided, maybe a little later than I should have, to use the Reddit Data dumps provided by John Baumgartner at pushshift.io instead, but much of the recent data is too large for my computer, attu, as well as my Azure instance. I am working with a grad student to get access to more resources so that I can work with (or even open) some of these files! However, in the meantime I have committed some files that <em>would </em>be my strawman. I have a list of 124 subreddits labeled as the neurodivergent subreddit subset and currently have a model that builds a set of users that post to these subsets, finds the other neurotypical subreddits those users also post to, and aggregates a set of those subreddits. The strawman compares the basic n-grams in each subset of the subreddits to see basic language model differences. I also cloned the vennclouds github project to try and visualize the n-grams (uni, bi, and tri) that are used in these two subsets as well as their overlap however, the current version seems to have a basic bug.<br/><br/>I will get the resources hopefully in the next couple of days and update this post with the actual data results! <br/><br/><em>To be continued...</em><br/><br/></div></div>
    </content>
    <updated>2018-04-18T03:47:19Z</updated>
    <category term="Uncategorized"/>
    <source>
      <id>http://sarahyu.weebly.com/cse-481n</id>
      <author>
        <name>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde</name>
      </author>
      <link href="http://sarahyu.weebly.com/cse-481n" rel="alternate" type="text/html"/>
      <link href="http://sarahyu.weebly.com/6/feed" rel="self" type="application/rss+xml"/>
      <subtitle>CSE 481N</subtitle>
      <title>Sarah yu - CSE 481N</title>
      <updated>2018-05-09T17:30:11Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-US">
    <id>http://cse481n-capstone.azurewebsites.net/?p=41</id>
    <link href="http://cse481n-capstone.azurewebsites.net/2018/04/17/data-collection-and-first-baseline/" rel="alternate" type="text/html"/>
    <title>Data Collection and First Baseline</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Data Collection In a previous blog, we mentioned using RAKE to collect content phrases from posts in order to compare their similarity. However, we decided since then that it would be easier to just look at ngrams, since they can capture the same information as the content phrases. So, after removing stopwords we collect all … <a class="more-link" href="http://cse481n-capstone.azurewebsites.net/2018/04/17/data-collection-and-first-baseline/">Continue reading<span class="screen-reader-text"> "Data Collection and First Baseline"</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h3>Data Collection</h3>
<p><span style="font-weight: 400;">In a previous blog, we mentioned using RAKE to collect content phrases from posts in order to compare their similarity. However, we decided since then that it would be easier to just look at ngrams, since they can capture the same information as the content phrases. So, after removing stopwords we collect all of the unigrams, bigrams, and trigrams on each MeanJokes post and on each general Reddit post. However, this creates a ton of data compared to the posts or even their content phrases. So, we must do some cleaning before we make use of this data.</span></p>
<p><span style="font-weight: 400;">For data cleaning, we decided to use document frequency to further clean content ngrams gathered from both mean-jokes and other Reddit posts. The reason why we choose df is:</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">First, we are using content ngrams, so it does not make sense to compute ngram term back on the original post since bigram, trigram term frequency is likely to be 1.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Second, df provides us a good way to remove too frequent and too infrequent ngrams. If an ngram is too frequent or too infrequent, it won’t be very informative about the pattern of the sentence.</span></li>
</ul>
<p><span style="font-weight: 400;">By using document frequency, we achieved the following purpose:</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Much shorter, cleaner content ngrams</span></li>
</ul>
<p><b>Example:</b></p>
<p><span style="font-weight: 400;">[(‘took’, ‘family’, ‘camping’), (‘camping’, ‘concentration’), (‘took’, ‘family’), (‘family’, ‘camping’), (‘took’,), (‘family’,), (‘concentration’, ‘camping’), (‘family’, ‘camping’, ‘concentration’), (‘camping’,), (‘concentration’,), (‘camping’, ‘concentration’, ‘camping’)]</span></p>
<p><b>After filtering:</b></p>
<p><span style="font-weight: 400;">[(‘took’,), (‘family’,), (‘camping’,), (‘concentration’,)]</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Filtered out posts written in a different language (like written in Spanish or Germany)</span></li>
</ul>
<p><strong>Example:</strong></p>
<p><span style="font-weight: 400;">[(‘adan’,), (‘zapata-con’,), (‘carino’,), (‘para’,), (‘ti’,), (‘letra’,), (‘encanta’,), (‘sii’,), (‘adan’, ‘zapata-con’), (‘zapata-con’, ‘carino’), (‘carino’, ‘para’), (‘para’, ‘ti’), (‘ti’, ‘letra’), (‘letra’, ‘encanta’), (‘encanta’, ‘sii’), (‘adan’, ‘zapata-con’, ‘carino’), (‘zapata-con’, ‘carino’, ‘para’), (‘carino’, ‘para’, ‘ti’), (‘para’, ‘ti’, ‘letra’), (‘ti’, ‘letra’, ‘encanta’), (‘letra’, ‘encanta’, ‘sii’)]</span></p>
<p><span style="font-weight: 400;">However, we sometimes encounter a problem that after filtering, the content ngrams becomes empty. We decide to skip these lines when we do set similarity because by looking back to the original posts, posts that end up with empty content ngram are generally </span><b>very short</b><span style="font-weight: 400;"> and </span><b>non-informative</b><span style="font-weight: 400;">. For example, the post “Bolivian coastline MeanJokes” ended up with an empty content ngrams. </span></p>
<p><span style="font-weight: 400;">To determine our final dataset, we want to find Reddit posts that use similar language to the MeanJokes posts. To do this, we use </span><a href="https://en.wikipedia.org/wiki/Jaccard_index"><span style="font-weight: 400;">Jaccard index</span></a><span style="font-weight: 400;"> to determine similarity. Due to the nature of MeanJokes posts being rather short compared to most Reddit posts, the Jaccard Index of most posts compared to these posts would be very low. By filtering as described above, Jaccard index becomes much more useful because the number of n-grams we consider for each post is greatly reduced, down to those we consider most identifying of those posts. However, Reddit posts are very diverse so there is a great sparsity of similar posts. Very few posts have Jaccard Indices greater than .2 even after this filtering. Before filtering, very few posts would even get close to .1. For context, Jaccard similarity could be thought of as a percentage from 0 to 1, where 1 means the posts are identical and 0 means they have no intersection. We have over 3 million Reddit posts just in one month though, so we are not worried about not getting a big enough dataset if we have a high threshold for similarity.</span></p>
<p><span style="font-weight: 400;">Here’s an example of what this data looks like:</span></p>
<p><b>Intersection: </b><span style="font-weight: 400;">{(‘ca’, “n’t”, ‘spell’), (‘ca’, “n’t”), (“n’t”, ‘spell’), (‘spell’,), (‘ca’,)}</span></p>
<p><b>MeanJokes Post:</b><span style="font-weight: 400;"> {(‘ca’, “n’t”), (‘therapist’,), (‘without’,), (‘ca’, “n’t”, ‘spell’), (‘rapist’,), (“n’t”, ‘spell’), (‘spell’,), (‘remember’,), (‘ca’,)}</span></p>
<p><b>Reddit Post:</b><span style="font-weight: 400;"> {(‘ca’, “n’t”), (‘ca’, “n’t”, ‘spell’), (“n’t”, ‘spell’), (‘spell’,), (‘crisis’,), (‘ca’,)}</span></p>
<p><b>Jaccard index:</b><span style="font-weight: 400;"> 0.5</span></p>
<p><span style="font-weight: 400;">5 / (9 + 6 – 5) -&gt; 5/10 -&gt; .5</span></p>
<p> </p>
<h3>Baseline Model</h3>
<p><span style="font-weight: 400;">Because we are in the process of data collection, we want to build baseline models on similar datasets and later port the model over to our own dataset. The dataset we chose for this purpose is the </span><span style="font-weight: 400;">Twitter Hate Speech dataset</span><span style="font-weight: 400;"> created by</span><span style="font-weight: 400;"> Zeerak Waseem and Dirk Hovy</span><span style="font-weight: 400;">. In this dataset, each tweet is labeled as “racism”, “sexism”, or “none”. Since our goal is to build tools that can not only detect if the text is offensive or non-offensive but also detect towards which group the text is offensive, the Twitter Hate Speech dataset serves as a good starting point. Here, we built a logistic regression model as a baseline for offensiveness detection. We consider both “racism” and “sexism” as offensive, and “none” non-offensive. </span></p>
<p><span style="font-weight: 400;">The each example in the dataset is of the format &lt;tweet_id&gt;, &lt;label&gt;. We first used </span><span style="font-weight: 400;">python-twitter </span><span style="font-weight: 400;">(a python wrapper around Twitter API) to collect the original tweets by the tweet_ids given. In this process, we noticed that 1133 tweets from this dataset are already removed from Twitter. </span></p>
<p><span style="font-weight: 400;">To make the results more reproducible, we made a train, dev, test dataset split (80%, 10%, 10%) using sklearn train_test_split function. </span></p>
<p><span style="font-weight: 400;">For data preprocessing, we used an existing </span><span style="font-weight: 400;">text preprocessor made by Zhang et. al. to clean each tweet down to plain text, removing extra space, URLs, hashtags, special characters, etc. </span></p>
<p><span style="font-weight: 400;">For text vectorization, we experimented with two different sklearn vectorizers: tf-idf vectorizer and count vectorizer. Count vectorizer converts a corpus to a document-term matrix. TF-IDF vectorizer converts a corpus to a tf-idf weighted document-term matrix. </span></p>
<p><span style="font-weight: 400;">After that, we trained a logistic regression model on training data and tuned epoch on dev data. Both the trained model and trained text vectorizer would be saved. We then loaded in the saved model and text vectorizer to make predictions and evaluate on test data. </span></p>
<p><span style="font-weight: 400;">The metrics we chose for performance evaluation are accuracy, precision, recall, and f1 score. Here we decided to be more conservative and paid more attention to precision because the expected downstream application (a.k.a. the targeting group detector)  relies on text predicted “offensive” to be actually offensive. We also focused on the f1 score to evaluate the overall performance of this baseline model.</span></p>
<p><span style="font-weight: 400;">We ran experiments with this baseline model with the different types of vectorizers and different vectorizer setups. We decided to keep follow ngram_range (1, 4) chosen by </span>Zeerak Waseem and Dirk Hovy.</p>
<ol>
<li>Set-up1:
<ul>
<li>Vectorizer:<br/>
<table>
<tbody>
<tr>
<td><span style="font-weight: 400;">type</span></td>
<td><span style="font-weight: 400;">strip_accents</span></td>
<td><span style="font-weight: 400;">analyzer</span></td>
<td><span style="font-weight: 400;">ngram_range</span></td>
<td><span style="font-weight: 400;">max_features</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">tf-idf</span></td>
<td><span style="font-weight: 400;">unicode</span></td>
<td><span style="font-weight: 400;">word</span></td>
<td><span style="font-weight: 400;">(1, 4)</span></td>
<td><span style="font-weight: 400;">10000</span></td>
</tr>
</tbody>
</table>
</li>
<li>Model: <span style="font-weight: 400;">Logistic regression, epoch_chosen=5</span></li>
<li>
<table>
<tbody>
<tr>
<td>dev accuracy: 0.8162</td>
<td>test accuracy: 0.8131</td>
</tr>
<tr>
<td>dev precision: 0.8170</td>
<td>test precision: 0.8203</td>
</tr>
<tr>
<td>dev recall: 0.7336</td>
<td>test recall: 0.7333</td>
</tr>
<tr>
<td>dev f1: 0.7560</td>
<td>test f1: 0.7552</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>Set-up2:
<ul>
<li>Vectorizer:<br/>
<table>
<tbody>
<tr>
<td><span style="font-weight: 400;">type</span></td>
<td><span style="font-weight: 400;">strip_accents</span></td>
<td><span style="font-weight: 400;">analyzer</span></td>
<td><span style="font-weight: 400;">ngram_range</span></td>
<td><span style="font-weight: 400;">max_features</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">tf-idf</span></td>
<td><span style="font-weight: 400;">unicode</span></td>
<td><span style="font-weight: 400;">char</span></td>
<td><span style="font-weight: 400;">(1, 4)</span></td>
<td><span style="font-weight: 400;">10000</span></td>
</tr>
</tbody>
</table>
</li>
<li>Model: <span style="font-weight: 400;">Logistic regression, epoch_chosen=18</span></li>
<li>
<table>
<tbody>
<tr>
<td><span style="font-weight: 400;">dev accuracy: 0.8175</span></td>
<td><span style="font-weight: 400;">test accuracy: 0.8067</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev precision: 0.8040</span></td>
<td><span style="font-weight: 400;">test precision: 0.7951</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev recall: 0.7482</span></td>
<td><span style="font-weight: 400;">test recall: 0.7388</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev f1: 0.7664</span></td>
<td><span style="font-weight: 400;">test f1: 0.7561</span></td>
</tr>
</tbody>
</table>
</li>
<li>Comparison: <span style="font-weight: 400;">By taking character level ngrams, test f1 actually improves, but test precision drops drastically. </span></li>
</ul>
</li>
<li>Set-up3:
<ul>
<li><span style="font-weight: 400;">Vectorizer:</span><br/>
<table>
<tbody>
<tr>
<td><span style="font-weight: 400;">type</span></td>
<td><span style="font-weight: 400;">strip_accents</span></td>
<td><span style="font-weight: 400;">analyzer</span></td>
<td><span style="font-weight: 400;">ngram_range</span></td>
<td><span style="font-weight: 400;">max_features</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">tf-idf</span></td>
<td><span style="font-weight: 400;">unicode</span></td>
<td><span style="font-weight: 400;">char</span></td>
<td><span style="font-weight: 400;">(1, 4)</span></td>
<td><span style="font-weight: 400;">30000</span></td>
</tr>
</tbody>
</table>
</li>
<li><span style="font-weight: 400;">Model: Logistic regression, epoch_chosen=10</span><br/>
<table>
<tbody>
<tr>
<td><span style="font-weight: 400;">dev accuracy: 0.8194</span></td>
<td><span style="font-weight: 400;">test accuracy: 0.8105</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev precision: 0.8099</span></td>
<td><span style="font-weight: 400;">test precision: 0.8021</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev recall: 0.7473</span></td>
<td><span style="font-weight: 400;">test recall: 0.7416</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev f1: 0.7669</span></td>
<td><span style="font-weight: 400;">test f1: 0.7598</span></td>
</tr>
</tbody>
</table>
</li>
<li><span style="font-weight: 400;">Comparison: By increasing the max number of features a document-term matrix can have, both test precision and test f1 improved compared with those of set-up2. </span></li>
</ul>
</li>
<li>Set-up4:
<ul>
<li><span style="font-weight: 400;">Vectorizer:</span><br/>
<table>
<tbody>
<tr>
<td><span style="font-weight: 400;">type</span></td>
<td><span style="font-weight: 400;">strip_accents</span></td>
<td><span style="font-weight: 400;">analyzer</span></td>
<td><span style="font-weight: 400;">ngram_range</span></td>
<td><span style="font-weight: 400;">max_features</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">count</span></td>
<td><span style="font-weight: 400;">unicode</span></td>
<td><span style="font-weight: 400;">word</span></td>
<td><span style="font-weight: 400;">(1, 4)</span></td>
<td><span style="font-weight: 400;">30000</span></td>
</tr>
</tbody>
</table>
</li>
<li><span style="font-weight: 400;">Model: Logistic regression, epoch_chosen=100</span><br/>
<table>
<tbody>
<tr>
<td><span style="font-weight: 400;">dev accuracy: 0.8321</span></td>
<td><span style="font-weight: 400;">test accuracy: 0.8213</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev precision: 0.8213</span></td>
<td><span style="font-weight: 400;">test precision: 0.8097</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev recall: 0.7690</span></td>
<td><span style="font-weight: 400;">test recall: 0.7618</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev f1: 0.7871</span></td>
<td><span style="font-weight: 400;">test f1: 0.7781</span></td>
</tr>
</tbody>
</table>
</li>
<li><span style="font-weight: 400;">Comparison: Vectorizer is now changed to count vectorizer. With this set-up, test f1 is the highest among all set-ups, while test precision is higher than that of set-up3 and lower of that of set-up1. </span></li>
</ul>
</li>
<li>Set-up5:
<ul>
<li><span style="font-weight: 400;">Vectorizer:</span><br/>
<table style="height: 96px;" width="328">
<tbody>
<tr>
<td><span style="font-weight: 400;">type</span></td>
<td><span style="font-weight: 400;">strip_accents</span></td>
<td><span style="font-weight: 400;">analyzer</span></td>
<td><span style="font-weight: 400;">ngram_range</span></td>
<td><span style="font-weight: 400;">max_features</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">count</span></td>
<td><span style="font-weight: 400;">unicode</span></td>
<td><span style="font-weight: 400;">char</span></td>
<td><span style="font-weight: 400;">(1, 4)</span></td>
<td><span style="font-weight: 400;">30000</span></td>
</tr>
</tbody>
</table>
</li>
<li><span style="font-weight: 400;">Model: Logistic regression, epoch_chosen=30</span></li>
<li>
<table style="height: 291px;" width="388">
<tbody>
<tr>
<td><span style="font-weight: 400;">dev accuracy: 0.8226</span></td>
<td><span style="font-weight: 400;">test accuracy: 0.8093</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev precision: 0.8001</span></td>
<td><span style="font-weight: 400;">test precision: 0.7860</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev recall: 0.7690</span></td>
<td><span style="font-weight: 400;">test recall: 0.7594</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dev f1: 0.7812</span></td>
<td><span style="font-weight: 400;">test f1: 0.7698</span></td>
</tr>
</tbody>
</table>
</li>
<li><span style="font-weight: 400;">Comparison: Test precision is the lowest of all the set-ups, and test f1 is higher than the first 3 set-ups, but lower than set-up4.</span></li>
</ul>
</li>
</ol>
<p><span style="font-weight: 400;">Although </span><span style="font-weight: 400;">Zeerak Waseem and Dirk Hovy’s paper stated that </span><span style="font-weight: 400;">character n-grams have better performance than work n-grams as features, our experiment results suggested otherwise. All of our set-ups have higher test precision and f1 score but lower test recall that the best model of the paper. These differences might be because of the removal of tweets from the original dataset. The train, dev, test data split method might also contribute to the differences. </span></p>
<p><span style="font-weight: 400;">Next Steps: We would like to experiment with other baseline models, especially neural networks and perform error analysis on these baseline models.</span></p>
<p>Work Cited:</p>
<p><a href="https://www.semanticscholar.org/paper/Hateful-Symbols-or-Hateful-People%3F-Predictive-for-Waseem-Hovy/df704cca917666dace4e42b4d3a50f65597b8f06"><span style="font-weight: 400;">Waseem, Zeerak and Dirk Hovy. “Hateful Symbols or Hateful People? Predictive Features for Hate Speech Detection on Twitter.” SRW@HLT-NAACL (2016).</span></a></p>
<p><a href="https://www.researchgate.net/publication/323723283_Detecting_hate_speech_on_Twitter_using_a_convolution-GRU_based_deep_neural_network">Zhang, Ziqi &amp; Robinson, D &amp; Tepper, J. (2018). Detecting hate speech on Twitter using a convolution-GRU based deep neural network.</a></p></div>
    </content>
    <updated>2018-04-18T02:36:38Z</updated>
    <category term="Weekly blog"/>
    <author>
      <name>Team Watch Your Language!</name>
    </author>
    <source>
      <id>http://cse481n-capstone.azurewebsites.net</id>
      <link href="http://cse481n-capstone.azurewebsites.net/feed/" rel="self" type="application/rss+xml"/>
      <link href="http://cse481n-capstone.azurewebsites.net" rel="alternate" type="text/html"/>
      <subtitle>Spring2018 CSE481N Capstone</subtitle>
      <title>Team Watch Your Language!</title>
      <updated>2018-05-15T04:00:21Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/d1d1b2d1f34c</id>
    <link href="https://medium.com/@hongnin1/image-annotation-model-baseline-dataset-and-evaluation-framework-d1d1b2d1f34c?source=rss-c450eb982161------2" rel="alternate" type="text/html"/>
    <title>Image Annotation Model Baseline, Dataset and Evaluation Framework</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h3>Baseline approach:</h3><h4>Overview:</h4><p>We are using a deep neural network that learns how to output the description of a general image. Example:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*RWtQGi8MpUzCsQTmWpR0Og.png"/>Image from paper <a href="https://arxiv.org/pdf/1412.6632.pdf">https://arxiv.org/pdf/1412.6632.pdf</a></figure><p>Our baseline model is an encoder-decoder neural network. First it encodes a image into a vector using a deep convolutional neural network (CNN), our baseline choice of network is <a href="https://arxiv.org/abs/1512.00567">Inception v3</a> image recognition model pre-trained on the <a href="http://www.image-net.org/challenges/LSVRC/2012/">ILSVRC-2012-CLS</a> image classification dataset. Then decode the vector into a paragraph of description using a long short-term memory network (LSTM). Words in the output description are represented with an embedding model with each word in the dictionary represented by a fixed-length vector (learned during training).</p><h4>Architecture:</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*na7zdPNZQG66QVCJK1Kqmg.png"/>Baseline Model Architecture</figure><p>Above architecture outputs the log likelihoods of the correct words at each step (logp1(S1)); later we use beam search to generate the description for given image.</p><h4>Running the model/Experiment:</h4><ol><li>we downloaded Cuda, Bazel, TensorFlow, Numpy, Natural Language ToolKit(NLTK).</li></ol><p>2. Download necessary data from Microsoft COCO:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Ap25lgpLRu8lkr0omWUdqQ.png"/>Bash screenshot of downloading MSCOCO data.</figure><p>3. Prepare all the necessary data we just downloaded for training:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*KBg_dBwZX6w3gIw2XzJDeA.png"/>Last few lines of bash logs for preparing data.</figure><p>4. Run training scripts and require: We only trained for about ~3 minutes.</p><p>5. After acquiring the model, we tried it out by input following images:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*a7WVZZT-k0fYKq82WUFLhA.png"/>input image: Surfer Guy</figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/623/1*H89koub2tfhDoxN4WPCYQA.png"/>input image 2: Rowing</figure><p>Our model’s output is not idea, for “Surfer Guy” image, our output is:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/784/1*Wl_AHUOJ8inu91LYEIKVZw.png"/></figure><p>For “Rowing” image, our output is:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/780/1*mHCnFYULsaI80jZWjfav5Q.png"/></figure><p>6. Then by using TensorBoard, we plotted the log loss for our model in training:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*kLU6ytNXYM9ytsKUS9bUrQ.png"/>TensorBoard Log Loss Graph</figure><p>As well as our model’s architecture:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Coh87C_W_jfo4Pg4aObPwA.png"/>Image Captioning Baseline Model Architecture on TensorBoard.</figure><h3>Evaluation Framework:</h3><p>The model we are referencing on <a href="https://github.com/tensorflow/models/tree/master/research/im2txt#prepare-the-training-data">git</a> hub has a built in evaluation framework, so we were using their evaluation script. It logs evaluation metrics to TensorBoard which allows training progress to be monitored in real-time (refer to the image “TensorBoard Log Loss Graph”).</p><h3>Resources:</h3><p>paper referenced: <a href="https://arxiv.org/pdf/1411.4555.pdf">https://arxiv.org/pdf/1411.4555.pdf</a></p><p>RMSProp referenced: <a href="https://www.coursera.org/learn/deep-neural-network/lecture/BhJlm/rmsprop">https://www.coursera.org/learn/deep-neural-network/lecture/BhJlm/rmsprop</a></p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d1d1b2d1f34c" width="1"/></div>
    </content>
    <updated>2018-04-17T07:30:16Z</updated>
    <category term="machine-learning"/>
    <author>
      <name>Ning Hong</name>
    </author>
    <source>
      <id>https://medium.com/@hongnin1?source=rss-c450eb982161------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/0*d6QC_ngideag3rTN.</logo>
      <link href="https://medium.com/@hongnin1?source=rss-c450eb982161------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@hongnin1" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Ning Hong on Medium</subtitle>
      <title>Stories by Ning Hong on Medium</title>
      <updated>2018-05-15T04:00:07Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/7de5277b5be</id>
    <link href="https://medium.com/@be.li.nda/nlp-capstone-blog-4-baseline-model-i-7de5277b5be?source=rss-fad49d942bf3------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone Blog #4: Baseline Model I</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>This week, I implemented the baseline neural model from my minimal viable plan. Specifically, my model was an attentive biLSTM, which took as input concatenated word, polarity, and holder/target embeddings.</p><p>As for evaluation frameworks, I’ve implemented f1 scoring. I also kept track of other metrics like accuracy and loss, in addition to f1 score, to get a better understanding of my model’s performance.</p><p>The following is a summary of my preliminary results. I’ve done very little hyper-parameter tuning thus far, but of the tuning that I did do, I found that changing the optimizer had the greatest benefit, specifically, using the Adam optimizer over the SGD optimizer. I trained the following two hyper-parameter settings:</p><pre>╔═════════════════════╦═════════╦═════════╗<br/>║   Hyperparameters   ║    1    ║    2    ║<br/>╠═════════════════════╬═════════╬═════════╣<br/>║ Optimizer           ║ Adam    ║ SGD     ║<br/>║ Learning Rate       ║ 0.01    ║ 0.05    ║<br/>║ # Epochs            ║ 20      ║ 20      ║<br/>║ Loss Function       ║ NLLLoss ║ NLLLoss ║<br/>║ Hidden Dimension    ║ 150     ║ 150     ║<br/>║ Dropout Rate        ║ 0.20    ║ 0.20    ║<br/>║ Batch Size          ║ 10      ║ 10      ║<br/>║ Embedding Dimension ║ 50      ║ 50      ║<br/>║    (all 3)          ║         ║         ║<br/>╚═════════════════════╩═════════╩═════════╝</pre><p>As you can see, the only differences are in the optimizer and learning rate. Note I did experiment a little with learning rate for each optimizer, however, the amount of tuning I did for this is definitely not sufficiently.</p><p>Also note hyper-parameter configuration 1 (Adam optimizer) performed much better than 2 (SGD optimizer).</p><h3>Preliminary Results</h3><h4>Adam Optimizer</h4><p>Graph of the <strong>loss</strong> over time:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*sYny1MXCplPx-XQ_ToYN4Q.png"/></figure><p>Graph of <strong>f1 scores</strong> over time: (Note there are 3 types of sentiments two pairs of entities can share: positive sentiment, negative sentiment, or no sentiment)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iPBZ5X-TctKEGWXub_8Klw.png"/></figure><p>Graph of <strong>accuracies</strong> over time:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*5TrbatjcthnZDlaz4eNxXg.png"/></figure><h4>SGD Optimizer</h4><ul><li>For SGD, I experimented with a few values for learning rate (0.01, 0.05, and 0.1), and found 0.05 to fairly optimal.</li></ul><p>Graph of the <strong>loss</strong> over time:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*nweK1MYnyudak8XGAHMnng.png"/></figure><p>Graph of <strong>f1 scores</strong> over time:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VPN0B5UEkH1tWDShzrcSLQ.png"/></figure><p>Graph of <strong>accuracies</strong> over time:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*9BmjOwEAcPQbHR-a1ZINLg.png"/></figure><h3>Key Takeaways</h3><ul><li>There’s a huge discrepancy between the performance on the train set and the performance on the dev set, indicating that the development data set and training data set are very different.</li><li>Analysis of the datasets, as you can see, the training set is very different in composition from the other sets:</li></ul><pre>╔══════════════╦══════════╦══════════╦══════════╦══════════╦═══════╗<br/>║              ║          ║ average  ║    #     ║    #     ║   #   ║<br/>║              ║    #     ║ entities ║ positive ║ negative ║ none  ║<br/>║              ║ articles ║ /article ║  pairs   ║  pairs   ║ pairs ║<br/>╠══════════════╬══════════╬══════════╬══════════╬══════════╬═══════╣<br/>║ train-ACL    ║ 897      ║ 2.63     ║ 648      ║ 815      ║ 355   ║<br/>║ dev-ACL-tune ║ 38       ║ 8.82     ║ 257      ║ 95       ║ 2520  ║<br/>║ dev-ACL-test ║ 36       ║ 9        ║ 237      ║ 118      ║ 2547  ║<br/>║ test-ACL     ║ 79       ║ 9.25     ║ 379      ║ 198      ║ 6037  ║<br/>║ test-MPQA    ║ 54       ║ 11.72    ║ 435      ║ 362      ║ 6813  ║<br/>╚══════════════╩══════════╩══════════╩══════════╩══════════╩═══════╝</pre><ul><li>For the Adam optimizer, the loss is still decreasing at the 20th epoch, meaning that I could probably keep seeing an improvement in performance if I continued running many more epochs.</li></ul><h3>Plan for Next Time</h3><ol><li>Deal with the discrepancy between train/dev/test data.</li><li>Do some more hyper-parameter tuning to try and improve scores.</li><li>Implement the end-to-end model architecture based on the <a href="https://homes.cs.washington.edu/~luheng/files/emnlp2017_lhlz.pdf">Lee et al. paper</a>, i.e. scoring holder/target sentiment using a FFNN in a second step. This is point 1 of my MVP/Stretch Goal from my last blog post. If time suffices, also implement bi-affine scoring (<a href="https://arxiv.org/pdf/1802.10569.pdf">Verga et al., 2018</a>, or point 2 in my MVP/Stretch Goal from my last blog post) and compare the results with the baseline model.</li><li>Experiment with attention mechanism, instead of calculating attention weights through a linear mapping from hidden state → weight, perhaps use a FFNN and pass in the hidden state.</li></ol><p>All code I’ve written for this post can be found on Github: <a href="https://github.com/eunsol/document-e2e-sent">https://github.com/eunsol/document-e2e-sent</a></p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7de5277b5be" width="1"/></div>
    </content>
    <updated>2018-04-17T06:51:48Z</updated>
    <category term="nlp"/>
    <category term="machine-learning"/>
    <category term="deep-learning"/>
    <author>
      <name>Belinda Zou Li</name>
    </author>
    <source>
      <id>https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/0*A16vZtRWBzxYPlmn.</logo>
      <link href="https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@be.li.nda" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Belinda Zou Li on Medium</subtitle>
      <title>Stories by Belinda Zou Li on Medium</title>
      <updated>2018-05-15T04:00:24Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/613328b9a85e</id>
    <link href="https://medium.com/@ryanp97/further-data-simplification-and-baseline-exploration-613328b9a85e?source=rss-6378d85d3a9b------2" rel="alternate" type="text/html"/>
    <title>Further Data Simplification and Baseline Exploration</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>As a side note, after meeting with Michael (the linguistics grad student mentioned in the first post), it seems that the “final” check of the Kyoto corpus is the most semantically accurate translation despite not being the most fluent. So it’s now feasible, and makes sense to, to get the Kyoto corpus incorporated into training at some point. He also suggested that I could use the top 5 statistically “best” parses from ERG/Jacy rather than just the best to increase the size of my dataset. These are both things that I will look into later down the line.</p><h3>Data Simplifications</h3><p>Jan and I decided to make a couple extra modifications to the input data in hopes of simplifying the model’s output. Ideally, these changes should allow the model to have a smaller output vocabulary size, and hopefully reduce the number of errors when generating a target tree.</p><h4>Simplifying Parentheses</h4><p>The first basic change was to separate closing parens from each other such that ) is the only way token that contains a closing paren. Originally, the parser would give spit out the closing parens as a single token, which most likely would confuse the model and result in non-wellformed output graphs.</p><p>The second step was to move the opening paren from the node label and attach it to the argument. Since the opening paren should only ever occur with an argument, this simplification removes the responsibility of having to figure out when to output an opening paren. We believe that this should not cause any sparsity issues since there is not very many different types of arguments.</p><h4>Simplifying Features</h4><p>Next, we concatenate argument features into a single token. The statistical parser is deterministic in its output, so the ordering of the features is always the same. Since there are only a few values each feature take on, the number of possible combinations is reasonable.</p><p>This is less than ideal since the model may never output sparse feature combinations. However, this is just a simplification to see the viability of the concept. Once we get a model that performs reasonably well, we can use the normal feature format as input and output.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*cFt-96vfvxtMvURKdfNttw.png"/>Simplified Japanese DMRS graph with squashed features.</figure><h4>Removing Features</h4><p>As a sanity check dataset, we created a dataset that has no features. This way, the model only has to predict arguments and argument labels. Though the features provide a lot of context, we are just using this dataset for preliminary testing and exploration.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*O5_KxoX1_gH9YURuqOu4nQ.png"/>Simplified, featureless, Japanese DMRS graph. Note that this is the featureless version of the above graph.</figure><h4>Removing `cargs`</h4><p>When parsing the graph, cargs shows up as one of the features of certain nodes. These represent the proper noun that the argument represents. In our scenario, we remove these carg features from the nodes since this should not affect semantic meaning and simplifies the model’s tasks and reduces sparsity issues (especially when we factor in squashing the features into a single token).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/576/1*mIhOrdHdlF_R2_QCeXyxFQ.png"/>Example of English DMRS before simplification, with `carg` feature.</figure><h3>Baseline Exploration</h3><p>I’ve taken a look at both AllenNLP and OpenNMT for starting points of my code, but I haven’t quite made a full decision yet. AllenNLP seems much easier to extend and better documented, while OpenNMT is significantly faster but has a much less intuitive interface and codebase. For now, I’ve tested some models using AllenNLP, but I’m still considering OpenNMT. This week, I focused on experimenting on just the simplified, featureless dataset.</p><p>As for the AllenNLP model, it was trained with negative log likelihood as the objective function, 3 layer, BiLSTM with (very) small embedding and hidden sizes for 12 epochs. I wanted to see how much a small model could learn, and it learned how to match parens by epoch 5. It didn’t seem to learn much between the semantic structures, however. I assume this is caused mainly by two things: 1) the model was not trained for long enough or 2) the default attention is not particularly helpful for learning semantic structure. For changing the default attention, the structured attention presented in <a href="https://arxiv.org/pdf/1705.09207.pdf"><em>Learning Structured Text Representations</em></a><em> </em>by<em> </em>Liu et al. seems like an interesting and potentially useful change to the seq2seq model.</p><p>While I take a look at implementing the above attention, I’m going to train a similar model with 256 embedding and hidden sizes for 20 epochs, and see how that affects the ability of learning semantic representations. Ideally, I would like to get an implementation of the described attention in AllenNLP by next week, but depending on the difficult and how the next model goes, I may switch over to using OpenNMT as they already have it <a href="https://github.com/OpenNMT/OpenNMT-py/blob/master/onmt/modules/StructuredAttention.py">implemented</a>.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=613328b9a85e" width="1"/></div>
    </content>
    <updated>2018-04-17T05:49:19Z</updated>
    <category term="machine-learning"/>
    <author>
      <name>Ryan Pham</name>
    </author>
    <source>
      <id>https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*83KfTWByl5pPq7A8_E8ApA.gif</logo>
      <link href="https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@ryanp97" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Ryan Pham on Medium</subtitle>
      <title>Stories by Ryan Pham on Medium</title>
      <updated>2018-05-15T04:00:06Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/7d8e9ec1a8e3</id>
    <link href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone | 03: Project Proposal</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><em>previous posts: </em><a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5"><em>01</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5"><em>02</em></a></p><h3>Towards a Better Understanding of Neural Networks: Visualizing Attention in Sequence-to-Sequence Models</h3><h4>A brief review of attention</h4><p>The idea of ‘attention’ was first introduced to the sphere of natural language processing by Bahdanau et al. (2014) in <em>Neural machine learning by jointly to align and translate</em>. The idea is fairly straightforward: if we have an encoder-decoder model, at each decoding time-step we generate a vector of attention weights corresponding to each of the encoding units. That is to say, when generating each output token, we pay ‘attention’ to certain parts of the input sequence. Intuitively, this is much how we as humans fixate on parts of text to perform tasks such as summarization or question answering.</p><h4>Why visualization?</h4><p>In Machine Learning, neural networks have always been a sort of black box. We know they work incredibly well in certain contexts, but its often difficult to understand why they work so well. The following quote sums up the need for interpretability quite well.</p><blockquote><strong><em>“I believe the most important direction for future research is interpretability.</em></strong><em> The attention mechanism, by revealing what the network is “looking at”, shines some precious light into the black box of neural networks, helping us to debug problems like repetition and copying. To make further advances, we need greater insight into what RNNs are learning from text and how that knowledge is represented.”</em></blockquote><blockquote>- Abigail See, PhD - Stanford University, <em>‘So, is abstractive summarization solved?’</em> from <a href="http://www.abigailsee.com/2017/04/16/taming-rnns-for-better-summarization.html">Taming Recurrent Neural Networks for Better Summarization</a></blockquote><p>Visualization provides an avenue for interpretability by mapping the behavior of the complex networks to easy-to-understand visual encodings.</p><h4>A survey of related work</h4><p>Although I am not aware of any papers dedicated to the visualization of attention, examples can be readily found in both published literature and online blogposts. For each example below, I’ll point out strengths and weaknesses. Ultimately, I hope to show that there are improvements we can make that can augment the interpretability of the workings of seq2seq attentional models.</p><p><strong>Heat-maps</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/404/0*9FCWt3AO5oGxLxtg."/>Bahdanau et al. (2014). An attention visualization for a seq2seq problem (in this case, translation). Whiter cells represent higher attention.</figure><p>The encoding scheme used by Bahdanau et al. (2014) themselves, heat-maps were the most common encoding of attentional data I found. While making the task of relative correlation lookup efficient, these have a couple of weaknesses.</p><ol><li>Hard to scale. With tasks involving large input or output (e.g. a hundred or more tokens) the size of the heat-map quickly gets out of hand. Scrolling greatly decreases the effectiveness of a visualization with respect to analysis tasks.</li><li>Difficult to read. We generally don’t read in a token-per-line format. Furthermore, source text is rarely in a token-per-line format — we lose insightful information that could be drawn from analyzing the original structure of the text.</li></ol><p><strong>Flow-maps</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*I3cdFcqDAcdKEwuCpAPHTA.png"/>Rikters et al (2017). The input sequence is seen on top — output on bottom. Thicker lines denote higher attention.</figure><p>Less common, but interesting nonetheless. This kind of flow-map suffers from problems similar to those of heat-maps. One could also argue that the thinness of the lines and their cross-hatch nature hinder interpretability.</p><p><strong>Interaction</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*3dTXvSI-L3X3M-MKXRraBA.gif"/>See et al. (2017). Interactive visualization of attention</figure><p>Interaction solves many of the issues of the static visualizations surveyed above. We retain the structure of both the input and output text, and lookup is quick and efficient. There is a trade-off, however. We are only able to view the attention of a single word at a time, and as a result it is hard to get a sense of the overall coverage or structure of attention.</p><h4>A case study: Summarization</h4><p>In particular,<strong> abstractive summarization</strong>. Summarization is a particularly interesting use case of attention because of the requirement of the condensing of text. The hypothesis is that good abstractive models will be able to cover the majority of the original document. Here I note the difference between <strong>extractive </strong>and<strong> abstractive </strong>summarizations. The former involves selecting pieces of the original text, verbatim. The latter involves compressive paraphrasing.</p><p>Until recently, most of the work in text summarization has revolved around extractive summarization (See et al. 2017). However, the rising prevalence of recurrent neural networks has allowed for further focus in abstractive summarization. Attention has played an important role in improving results. Below is a brief list of relevant work.</p><p><a href="https://arxiv.org/pdf/1509.00685.pdf">Rush, Alexander M. et al. “A Neural Attention Model for Abstractive Sentence Summarization.” <em>EMNLP</em> (2015).</a></p><p><a href="https://arxiv.org/pdf/1602.06023.pdf">Nallapati, Ramesh et al. “Abstractive Text Summarization using Sequence-to-sequence RNNs and Beyond.” <em>CoNLL</em> (2016).</a></p><p><a href="https://arxiv.org/pdf/1712.06100.pdf">Hasselqvist, Johan et al. “Query-Based Abstractive Summarization Using Neural Networks.” <em>CoRR</em> abs/1712.06100 (2017): n. pag.</a></p><p><a href="https://arxiv.org/pdf/1705.04304.pdf">Paulus, Romain et al. “A Deep Reinforced Model for Abstractive Summarization.” <em>CoRR</em> abs/1705.04304 (2017): n. pag.</a></p><p><a href="https://arxiv.org/pdf/1704.04368.pdf">See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” <em>ACL</em> (2017).</a></p><h4>Summarization Specific Challenges</h4><p>While visualizations of attention are helpful in shedding light on the workings of seq2seq models, summarization models in particular have trouble leveraging this window.</p><ol><li>We care about <strong>where</strong> attention falls just as much as what it falls on. We hope to maximize <strong>coverage</strong>. This is not currently addressed in any interactive visualizations I am aware of.</li><li>We have large input sequences. As discussed in <strong>“A survey of related work,”</strong> this is particularly problematic for static visualizations.</li></ol><p>With this in mind, I propose areas for improvement in both interactive and static visualizations.</p><h4>Where to?</h4><p>With interactive visualizations, two things.</p><p><strong>One. Coverage </strong>is the aggregated attention over a sequence of output tokens. An example given by See et al. can be seen in the figure below. Perhaps allowing brushing to visualizing the aggregate attention over a phrase or sentence can help us understand attention in a more global context.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/956/0*vE-iXohphbWY6Nam."/>See et al. (2017). Example of coverage.</figure><p><strong>Two. Extraction vs Abstraction: </strong>Ideally, we want our model to learn how to abstract rather than extract. 1:1 exact match attention is less interesting to see than seeing attention to groups of words. Perhaps emphasizing / de-emphasizing can this in visualizations can help aid understanding of models.</p><p>With static visualizations, there are two analysis tasks that we wish to optimize for.</p><ol><li><strong>Summary. </strong>What is the overall structure of the attention (e.g. coverage).</li><li><strong>Value. </strong>Which input words are attended (i.e. focused on) by each output timestep?</li></ol><p>It is difficult to design an <em>effective</em> static visualization that lends itself well to both of these tasks. Perhaps we need a set of visualizations. For example, one visualization might afford better performance for summary analysis, while another might afford better performance for value analysis. In addition, these static visualizations can incorporate ideas described in previous section.</p><p>Additionally, attention visualizations thus far have been for <strong>specific examples</strong>. Perhaps there a way we can look <strong>across examples</strong> to better understand the behavior of these neural networks. Derived metrics for attention or coverage could be useful in better understanding and diagnosing these models.</p><p>My hope is that addressing these items in both interactive and static visualizations will allow us to better reason about neural networks. In particular, I hope the result can be used as a valuable tool for error analysis, <strong>even</strong> <strong>beyond</strong> hyperparameter tuning. Insights could be gleamed that motivate additions or constraints or mechanisms to optimize coverage (e.g. See et al. (2017)) or abstraction.</p><h4>The Plan</h4><p><strong>Minimum Viable Plan</strong></p><ol><li>Develop a TensorBoard plugin that allows for the static and interactive visualizations described in <strong>Where to?</strong></li><li>Acquire feedback from students / researchers in the Allen School.</li></ol><p>I intend to leverage existing models to retrieve data. For example, that <a href="https://github.com/abisee/pointer-generator">provided publicly</a> by See et al. (2017). The dataset used by them is a <a href="https://github.com/abisee/cnn-dailymail">modified CNN/Daily Mail Dataset</a> [Hermann et al. (2015), See et al. (2017)] — a collection of articles and bullet point summaries.</p><p><strong>Stretch Goals</strong></p><ol><li>Explore and implement aggregate, cross-example visualizations as described in <strong>Where to?</strong></li><li>Release a beta of the TensorBoard plugin on github and acquire feedback there.</li></ol><h4>Works Cited</h4><ul><li><a href="https://arxiv.org/pdf/1704.04368.pdf">See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” <em>ACL</em> (2017).</a></li><li><a href="https://arxiv.org/pdf/1506.02078.pdf">Karpathy, Andrej, Justin Johnson, and Li Fei-Fei. “Visualizing and understanding recurrent networks.” <em>arXiv preprint arXiv:1506.02078</em>(2015).</a></li><li><a href="https://arxiv.org/pdf/1712.06100.pdf">Hasselqvist, Johan et al. “Query-Based Abstractive Summarization Using Neural Networks.” <em>CoRR</em> abs/1712.06100 (2017): n. pag.</a></li><li><a href="https://arxiv.org/pdf/1602.06023.pdf">Nallapati, Ramesh et al. “Abstractive Text Summarization using Sequence-to-sequence RNNs and Beyond.” <em>CoNLL</em> (2016).</a></li><li><a href="https://arxiv.org/pdf/1705.04304.pdf">Paulus, Romain et al. “A Deep Reinforced Model for Abstractive Summarization.” <em>CoRR</em> abs/1705.04304 (2017): n. pag.</a></li><li><a href="https://arxiv.org/pdf/1509.00685.pdf">Rush, Alexander M. et al. “A Neural Attention Model for Abstractive Sentence Summarization.” <em>EMNLP</em> (2015).</a></li><li><a href="https://arxiv.org/pdf/1409.0473.pdf">Bahdanau, Dzmitry, Kyunghyun Cho, and Yoshua Bengio. “Neural machine translation by jointly learning to align and translate.” <em>arXiv preprint arXiv:1409.0473</em> (2014).</a></li><li><a href="https://arxiv.org/pdf/1506.03340.pdf">Hermann, Karl Moritz et al. “Teaching Machines to Read and Comprehend.” <em>NIPS</em>(2015).</a></li></ul><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7d8e9ec1a8e3" width="1"/></div>
    </content>
    <updated>2018-04-12T05:46:21Z</updated>
    <category term="computer-science"/>
    <category term="machine-learning"/>
    <category term="data-visualization"/>
    <category term="nlp"/>
    <category term="visualization"/>
    <author>
      <name>Halden Lin</name>
    </author>
    <source>
      <id>https://medium.com/@halden.lin?source=rss-2759d54493c0------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*Hzu2ZqgloT0I1F6Kwg8OPA.jpeg</logo>
      <link href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@halden.lin" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Halden Lin on Medium</subtitle>
      <title>Stories by Halden Lin on Medium</title>
      <updated>2018-05-15T04:00:29Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/b951950ad9a5</id>
    <link href="https://medium.com/@hongnin1/image-summarization-b951950ad9a5?source=rss-c450eb982161------2" rel="alternate" type="text/html"/>
    <title>Image Annotation Papers</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><a href="https://github.com/tensorflow/models/tree/master/research/im2txt#prepare-the-training-data">https://github.com/tensorflow/models/tree/master/research/im2txt#prepare-the-training-data</a></p><ul><li><a href="https://arxiv.org/abs/1412.6632">[1412.6632] Deep Captioning with Multimodal Recurrent Neural Networks (m-RNN)</a></li><li><a href="https://arxiv.org/abs/1411.4555">[1411.4555] Show and Tell: A Neural Image Caption Generator</a></li></ul><a href="https://medium.com/media/3d1f87b3acd58d4b818d676b6a67c63a/href">https://medium.com/media/3d1f87b3acd58d4b818d676b6a67c63a/href</a><p><a href="https://arxiv.org/abs/1502.03044">[1502.03044] Show, Attend and Tell: Neural Image Caption Generation with Visual Attention</a></p><p>Image Annotation for medical use:</p><p><a href="https://arxiv.org/pdf/1603.08486.pdf">https://arxiv.org/pdf/1603.08486.pdf</a></p><p>Image Annotation for visually impaired:</p><p><a href="https://cs224d.stanford.edu/reports/mcelamri.pdf">https://cs224d.stanford.edu/reports/mcelamri.pdf</a></p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b951950ad9a5" width="1"/></div>
    </content>
    <updated>2018-04-12T04:21:59Z</updated>
    <category term="artificial-intelligence"/>
    <author>
      <name>Ning Hong</name>
    </author>
    <source>
      <id>https://medium.com/@hongnin1?source=rss-c450eb982161------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/0*d6QC_ngideag3rTN.</logo>
      <link href="https://medium.com/@hongnin1?source=rss-c450eb982161------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@hongnin1" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Ning Hong on Medium</subtitle>
      <title>Stories by Ning Hong on Medium</title>
      <updated>2018-05-15T04:00:07Z</updated>
    </source>
  </entry>

  <entry>
    <id>http://sarahyu.weebly.com/cse-481n/formal-proposal</id>
    <link href="http://sarahyu.weebly.com/cse-481n/formal-proposal" rel="alternate" type="text/html"/>
    <title>Formal Proposal</title>
    <summary>Linguistic Accommodation for Self-Presentation as seen in Neurotypical vs. Neurodivergent SubredditsHypotheses: 1) Users change their language depending on the community, represented by subreddits categorized as Neurotypical vs Neurodivergent      - The divergence from their own baseline is a sign of assimilation through tuned self-presentation*2) Language Models, as used by the whole community, differ and not just in topic-specific jargon      - The langu [...]</summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><div class="paragraph">Linguistic Accommodation for Self-Presentation as seen in Neurotypical vs. Neurodivergent Subreddits<br/><br/><u>Hypotheses:</u> <br/>1) Users change their language depending on the community, represented by subreddits categorized as Neurotypical vs Neurodivergent<br/>      - The divergence from their own baseline is a<span> sign of assimilation through tuned self-presentation*</span><br/>2) Language Models, as used by the whole community, differ and not just in topic-specific jargon<br/>      - The language changes of the individual user and the change in delta from the community's language model is a sign of their attempt at assimilating language accommodation*<br/>          - Do certain users adapt better? If so, what is differentiating those users?<br/><font size="1">*(subpoints are very similar, and I'm still working through if there is a nuance, or if they're the same)</font><br/><br/>My <strong>objective</strong>, then, is to address these hypotheses through the following approach:<br/><br/><u>Literature Survey:</u><br/>While this project is novel, mainly in the focus on neurotypical vs neurodivergent separation and the use of Reddit data, this project finds guidance from previous work done on similar questions. First, this project aims to extend upon the work of Danescu-Niculescu-Mizil et al. in<em> </em><u><em>Mark My Words! Linguistic Style Accommodation in Social Media​.</em></u> This was the first large-scale endeavor in identifying linguistic accommodation using social media. However, our project extends this work by taking advantage of the siloed nature of Reddit to identify linguistic accommodation employed by a single user across communities as opposed to the one-dimensional view of a user's linguistic accommodation to the general twittersphere in Danescu's paper. Also, this project is informed by Fast and Horvitz in <u><em>Identifying Dogmatism in Social Media: Signals and Models</em></u>, specifically in their methodologies and models; I attempt to extend upon these with more complex models. In this process, I also found several works that were similar in nature: Tamburrini et al. on language change based on social identity on Twitter, Nguyen and Rose on language socialization in online communities, and Michael and Otterbacher on herding in online review language. Two more relevant works for my project are De Choudhury et al.'s work on identifying the shift to Suicidal Ideation in social media and D<span>anescu-Niculescu-Mizil's work on the life-cycle of users in online communities. <br/>​<br/><u>Proposed Methodologies</u>: </span><br/>In it's most basic form, these questions can be explored with basic language models. First, we will identify a subset of neurotypical and neurodivergent subreddits to explore (100 or so respectively), chosen by a preliminary search on overlapping users posting between these. Based on this preliminary search, we will also gain a set of users who potentially post to both neurotypical and neurodivergent subreddits (we may need to look only at posts within a band of characters, but that is a parameter I'd like to explore). We will aggregate all of a user's posting history, not just in the subset aforementioned, to model the user's language use and do the same for the language of all posts made by any user (not just our set) to the subreddit to model the subreddit's language. I will supplement these models with the LIWC lexicon to characterize the differences between the communities and between users in different subreddits. (I may use a subset of the LIWC categories later on). A more complex model would be to use PPDB to find differences via paraphrasing. Yet another complex model would be to use a graphical model as inspired by Bamman et al's <em><u>Learning Latent Personas of Film Characters</u></em>. A stretch goal would be to train an RNN model for the language model of a neurotypical subreddit and that of a neurodivergent to see the probability of a post to belong to either of these categories. A stretch goal (not in complexity as in the RNN, but rather in interest) is to use the <em>Zelig Quotient</em>, a proposed measure for normalizing linguistic accommodation by Jones et al and see how much this may affect our findings. <br/>One special consideration is the use of NSFW language. My only filter will be to disqualify the list of NSFW subreddits, as named by a reddit post (so meta) in being chosen for the subsets, but otherwise we will not do anything special for NSFW language in other subreddits. <br/><br/><u>Resources</u>: Lots of Reddit fun!!!<br/><br/><em>​Here goes nothing...</em></div></div>
    </content>
    <updated>2018-04-11T07:00:00Z</updated>
    <category term="Uncategorized"/>
    <source>
      <id>http://sarahyu.weebly.com/cse-481n</id>
      <author>
        <name>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde</name>
      </author>
      <link href="http://sarahyu.weebly.com/cse-481n" rel="alternate" type="text/html"/>
      <link href="http://sarahyu.weebly.com/6/feed" rel="self" type="application/rss+xml"/>
      <subtitle>CSE 481N</subtitle>
      <title>Sarah yu - CSE 481N</title>
      <updated>2018-05-09T17:30:11Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://deeplearningturingtest.wordpress.com/?p=14</id>
    <link href="https://deeplearningturingtest.wordpress.com/2018/04/11/project-proposal-question-based-knowledge-representation/" rel="alternate" type="text/html"/>
    <title>Project Proposal: Question-Based Knowledge Representation</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Project Objective: The objective of this project is to create a model that can build a representation of the knowledge it’s gathered by reading the input text line by line and asking appropriate clarifying questions to a human for further insight. Literature Survey: Williams, Jason D. et al. “Hybrid Code Networks: practical and efficient end-to-end … <a class="more-link" href="https://deeplearningturingtest.wordpress.com/2018/04/11/project-proposal-question-based-knowledge-representation/">Continue reading <span class="screen-reader-text">Project Proposal: Question-Based Knowledge Representation</span> <span class="meta-nav">→</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><strong>Project Objective:</strong> The objective of this project is to create a model that can build a representation of the knowledge it’s gathered by reading the input text line by line and asking appropriate clarifying questions to a human for further insight.</p>
<p><strong>Literature Survey:</strong></p>
<ul>
<li><cite class="formatted-citation formatted-citation--style-mla">Williams, Jason D. et al. “Hybrid Code Networks: practical and efficient end-to-end dialog control with supervised and reinforcement learning.” <em>ACL</em> (2017).</cite></li>
<li>
<div class="padded"><cite class="formatted-citation formatted-citation--style-mla">Zhang, Qianqian et al. “A Review on Entity Relation Extraction.” <em>2017 Second International Conference on Mechanical, Control and Computer Engineering (ICMCCE)</em> (2017): 178-183.</cite></div>
</li>
<li>Arvind Neelakantan’s Doctoral Disseration: <em>Knowledge Representation and Reasoning with Deep Neural Networks (2017)</em></li>
<li>
<div class="padded"><cite class="formatted-citation formatted-citation--style-mla">Zhao, Tiancheng and Maxine Eskénazi. “Towards End-to-End Learning for Dialog State Tracking and Management using Deep Reinforcement Learning.” <em>SIGDIAL Conference</em> (2016).</cite></div>
</li>
</ul>
<p><strong>Minimal Viable Action Plan:</strong> My minimum action plan would be to implement and train an RL model to ask certain question template(s) as clarification as it processes input text line by line. Then a human (myself) would assign a reward to indicate the quality of the question and give a brief answer to the question. This brief answer would then be used to expand the model’s stored knowledge representation and the assigned reward would be used to train the RL model. This series of exchanges is treated like a one-on-one conversation even if it’s more like a one-sided lecture.</p>
<p><strong>Stretch Goals:</strong> Stretch goals include extracting features from the existing knowledge base and feeding those into the model to further improve the relevancy of questions (for example not asking questions that the model should already know). Another stretch goal would be to translate the knowledge representation back into everyday English text for tasks such as answering reading comprehension questions. This can be done either by training a Machine Translation model, using a parser like ANTLR, or some other method.</p>
<p><strong>Proposed Methodologies:</strong> My proposed methodologies follows a similar outline as given by Williams et al. in their paper on Hybrid Code Networks (HCNs).</p>
<ul>
<li>The input text is read in line-by-line and goes through various preprocessing steps like entity extraction, word embeddings layer, sentiment analysis, bag of words, etc. These features are concatenated and fed into the model.</li>
<li>In the HCN paper, the model was an RNN followed by a softmax layer (probability distribution over the various actions to take).
<ul>
<li>In this problem, the “actions” to take are the different types of question templates to ask so copying this model and substituting their action templates with my question templates would work.</li>
</ul>
</li>
<li>An alternative approach would be to build a Deep Q Network model with an LSTM (or GRU) layer at the end, so the network would update the Q values for each question type that can be asked (and the one with the highest Q value can be greedily selected). For clarification, each input sentence would represent a time step.</li>
<li>After a question type is selected with either of the 2 approaches above, nouns need to be substituted in to form an actual question (as in the HCN paper). For example, a question template might be “Is there a relationship between ______ and ______?” and the two blanks need to be filled in with nouns. If the substitution results in a good question, a good reward is assigned and otherwise, a very negative reward is assigned. If it’s a good question, then an answer is given to update the knowledge representation.
<ul>
<li>Some possible ways to create this knowledge representation is to use lists, trees, semantic networks, production rules, logical propositions and/or other existing NLP knowledge representation models (I haven’t decided on one yet).</li>
</ul>
</li>
</ul>
<p><strong>Available Resources/Databases:</strong> To train the model, any reading comprehension dataset like MS Marco (Microsoft), SQuAD (Stanford), RACE, etc. can be used. If my project is successful enough, I can even use these datasets for evaluation.</p>
<p><strong>Evaluation Plan:</strong> If I only finish my minimum viable action plan, I’m not sure how I can qualitatively assess my knowledge representation except by comparing the representation against the information I wanted to be recorded (or have other people judge what knowledge should be stored). On the other hand, if I finish my stretch goals (translating knowledge representation to English) I can try to use the knowledge representation to train on and respond to queries in a reading comprehension dataset (which would be a much more qualitative evaluation).</p></div>
    </content>
    <updated>2018-04-11T06:59:08Z</updated>
    <category term="Uncategorized"/>
    <author>
      <name>ananthgo</name>
    </author>
    <source>
      <id>https://deeplearningturingtest.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://deeplearningturingtest.wordpress.com/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://deeplearningturingtest.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://deeplearningturingtest.wordpress.com/osd.xml" rel="search" title="NLP Capstone Project Updates - Ananth" type="application/opensearchdescription+xml"/>
      <link href="https://deeplearningturingtest.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <title>NLP Capstone Project Updates – Ananth</title>
      <updated>2018-05-15T04:00:27Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/7b6d1a9ec67c</id>
    <link href="https://medium.com/@viterbi.or.not/formal-project-proposal-7b6d1a9ec67c?source=rss-c522ef075bb3------2" rel="alternate" type="text/html"/>
    <title>Formal Project Proposal</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*cr8jfKVLjgd9Y7YmxXWSYA.png"/></figure><p>Introducing our project topic, <strong>automatic conversation summarization</strong>! Our proposal will outline specific objectives, motivations, and plan we have for this project. We also cover here the resources we have gathered — related work, datasets (as promised), and evaluation frameworks, to demonstrate viability and give background on the topic.</p><h4><strong>Objective</strong></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DmM6aXAhZi61Ec7Yhp6YBw.png"/>Example summarization of an email chain from the <a href="https://www.cs.ubc.ca/cs-research/lci/research-groups/natural-language-processing/bc3.html">W3C email threads corpus</a></figure><p>In the field of automatic text summarization, there are numerous techniques that can be used to produce summaries of general text data. However, for our project, we seek to work on a more specific type of data by exploring and evaluating techniques for summarization of conversation logs. Therefore, the models we will attempt to implement and measure will take input in the form of natural text from conversations, such as email threads, chat logs, or transcribed spoken conversations, and output more concise summaries that capture the most important parts of the input.</p><p>While a document or paper typically sticks to a single topic at once and represents communication between an author and the reader, conversational data is characterized by a mixing of sub-topics and, in many cases, contributions from multiple different authors before one topic is finished. As a result, the objective of conversational summarization includes identifying topics and threads among a potentially chaotic conversation in order to make a sensible summarization even without the benefit of a single, linear topic progression.</p><h4><strong>Extractive vs. Abstractive</strong></h4><p>When considering text summarization, a distinction has to be made between two different approaches to summarization that offer different levels of implementation difficulty and usefulness. An extractive summary is produced by identifying the most important sentences from the input text and combining them to form a summary that is the concatenation of those sentences.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iZujvW2rP_HSVU2KXLtvew.png"/>Example of a short chatlog and its corresponding extractive summary</figure><p>Alternatively, an abstractive summary consists of new text generated from the topics and important aspects of the input text, but requires the model to create new summary sentences rather than simply re-using existing ones. As a result of this generation process, abstractive summaries are typically considered to be more useful, because they consist of natural-sounding text while still paraphrasing the concepts that are important. However, current techniques perform much better at generating extractive summaries, which are considered much easier to implement because they only require assigning scores to the sentences of the input.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*1oiGv-MrfdubjbKv-Vp9fA.png"/>Example of a short chatlog and its corresponding abstractive summary</figure><h4><strong>Motivation</strong></h4><p>The <strong>academic</strong> motivations behind our project are to pursue a topic in summarization that has been relatively less explored. This means tackling the challenges that come with the conversation summarization domain — annotated conversation datasets are typically smaller and more unpredictable, and whereas tasks like document summary usually involve one topic written by one author/voice, conversations and involve many participants and have less well-defined topic segmentation.</p><p>The project is also motivated by the possibly impactful <strong>applications </strong>of conversation summarization. Being able to summarize long chains of emails or group IMs is an increasingly important task to tackle in today’s world and can be a useful augmentation to digital group conversations.</p><h4><strong>Related Work</strong></h4><p>In our literature survey, we will first discuss the two papers that have been most impactful in helping establish our project plan.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*U0i-moKx4s_YB3My."/>Graph of contributions of general feature categories to the performance of logistic regression classifiers</figure><p><a href="http://www.aclweb.org/anthology/D08-1081"><strong>Summarizing Spoken and Written Conversations</strong></a><strong>¹ </strong>uses meeting and email datasets. The authors of this paper approach extractive summarization with logistic regression classifiers and a mix of general summarization features as well as some basic conversation summarization features. The overall feature categories can be seen in the corresponding figure, which graphs the contributions of each feature category to the classifier’s performance. “Participant” category features were found to help achieve competitive results.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1010/0*wLl3u1tR-GKYuIql."/>Table of performances of previously published models and the models used in the experiment (C4.5, NB, MLP, SVM)</figure><p><a href="http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf"><strong>Summarizing Online Conversations: A Machine Learning Approach</strong></a><strong>²</strong> uses chatlog and meeting datasets. The authors of this paper conduct experiments with Decision Tree, Naive Bayes classifier, Multilayer Perceptron (MLP) and Support Vector Machine (SVM) summarizers to create extractive summaries. The input feature vectors to these trainable summarizers use both general summarization features (sentence length, sentence position, similarity to title, etc.) as well as conversation specific summarization features that are more specialized than those mentioned in the previously discussed paper (is question, sentiment score, discourse markers). The paper overall found that the Naive Bayes classifier and MLP performed the best.</p><h4><strong>Datasets</strong></h4><p>The datasets we found cover a variety of conversation domains and are all human-annotated with summaries.</p><p><strong>Email: </strong><a href="https://www.cs.ubc.ca/cs-research/lci/research-groups/natural-language-processing/bc3.html"><strong>W3C Email Threads</strong></a></p><ul><li>40 email threads of ~80 lines each</li><li>Extractive and Abstractive Summaries</li></ul><p><strong>Chat: </strong><a href="https://flossmole.org/content/software-archaeology-gnue-irc-data-summaries"><strong>GNU Enterprise Chatlogs</strong></a></p><ul><li>~120 chats of ~1200 lines each</li><li>Abstractive Summaries</li></ul><p><strong>Spoken Conversation: </strong><a href="http://groups.inf.ed.ac.uk/ami/corpus/"><strong>AMI Meeting Transcripts</strong></a></p><ul><li>140 meeting transcriptions of ~45 minutes each</li><li>Extractive and Abstractive Summaries</li></ul><h4><strong>Evaluation</strong></h4><p>In terms of <strong>automated</strong> methods of evaluation for the summaries that we will generate, there are a few frameworks we can use:</p><p><strong>BLEU</strong> (BIlingual Evaluation Understudy)</p><ul><li>Precision measure with some enhancements</li></ul><p><strong>METEOR</strong> (Metric for Evaluation of Translation with Explicit ORdering)</p><ul><li>Improves on BLEU by adding recall, synonyms</li><li>Better at sentence-level evaluation</li></ul><p><strong>ROUGE</strong> (Recall-Oriented Understudy for Gisting Evaluation)</p><ul><li><strong>ROUGE-L</strong>: Longest common subsequence</li><li><strong>ROUGE-N</strong>: Overlap of N-Grams between passages</li></ul><p>However, for summarization tasks, <strong>human evaluation</strong> is possibly most ideal and it is unclear if any automatic metric can be as effective.</p><h4><strong>Minimum Viable Product</strong></h4><p>Our plan is to start with two <strong>baseline models</strong> that replicate the best performing models (Naive Bayes and MLP approaches) of “Summarizing Online Conversations: A Machine Learning Approach” using the non-conversation specific features.</p><p>We would then experiment with tweaks to the baseline models that use conversation-specific features, both based off of the ones described in the paper and also based on some of our ideas about what kinds of domain-specific features might benefit conversation summarization. We can also continue to explore alternative models and compare model approaches.</p><h4><strong>Stretch Goals</strong></h4><p>There are a number of ideas we have for stretch goals that can push our project further:</p><p><strong>Neural Network implementation: </strong>Applying general summarization techniques to conversation</p><p><strong>Model entity relationships: </strong>Identifying the role of a contributor or named entity, such as a supervisor in an email thread</p><p><strong>Abstractive summarization: </strong>Convert a previously extractive summary to be natural-sounding and abstractive</p><p><strong>Optimize performance for a specific domain: </strong>For example, in chats about bugfixes, use that specific context to try outperforming the general case</p><p><strong>Relate parameters from different types of data: </strong>For example, use data from spoken corpus to improve results on email</p><p>We hope you enjoyed reading our project proposal and we are excited to get working!</p><p>[1] Murray, G. &amp; Carenini, G. (2008). Summarizing Spoken and Written Conversations. <em>Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, </em>773–782.</p><p>[2] Sood, A. &amp; Varma, V. (2012). Summarizing Online Conversations: A Machine Learning Approach. <em>Centre for Search and Information Extraction Lab International Institute of Information Technology Hyderabad,</em> 500.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7b6d1a9ec67c" width="1"/></div>
    </content>
    <updated>2018-04-11T06:56:31Z</updated>
    <category term="nlp"/>
    <author>
      <name>Viterbi Or Not To Be</name>
    </author>
    <source>
      <id>https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*wiisg40Bu4z11RTWJ66mnA.png</logo>
      <link href="https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@viterbi.or.not" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Viterbi Or Not To Be on Medium</subtitle>
      <title>Stories by Viterbi Or Not To Be on Medium</title>
      <updated>2018-05-15T04:00:27Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/c8a12d3ae611</id>
    <link href="https://medium.com/@be.li.nda/nlp-capstone-blog-3-project-proposal-c8a12d3ae611?source=rss-fad49d942bf3------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone Blog #3: Project Proposal</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>The project I’m working on is document-level entity-entity sentiment analysis.</p><h4>Objectives and Definition</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*mfDKzKS3wAEnJZ3gvLHwyw.png"/>Notice in the above example that the arc from Russia to Belarus is negative, which makes sense if our article has the sentence “Russia criticizes Belarus.”</figure><p>The goal of my project can be stated thusly: given a document, be able to figure out whether various entities within the document feel positively or negatively towards each other.</p><p>In particular, I’m looking to apply a neural model to <a href="https://homes.cs.washington.edu/~eunsol/papers/acl2016.pdf">an existing paper</a> in an attempt to improve its F1 scores.</p><p>Applications of this work include:</p><ul><li>Modeling social dynamics between entities</li><li>Applying sentiment analysis to problems beyond simply movie/product reviews</li></ul><p>A farther motivation for this project is that entity-entity sentiment analysis is a relatively novel task, with little existing work thus far. Also, even work in related fields is usually focused on the sentence level, rather than the document level.</p><h4><strong>Literature Survey</strong></h4><p>Some work in related fields to this project. For each paper, I will be focusing especially on its model /methodologies, which could be of use to developing my own model —</p><p><strong>Targeted Sentiment Analysis</strong></p><p><a href="https://www.aaai.org/ocs/index.php/AAAI/AAAI16/paper/download/12074/12065">Zhang, Meishan, Zhang, Yue, and Vo, Duy-Tin, 2016. Gated Neural Networks for Targeted Sentiment Analysis.</a></p><ul><li>Introduced the use of gated neural networks to perform targeted sentiment analysis.</li><li>Inputs: Concatenation of 2 types of word embeddings: both embeddings incorporate sentiment information in some way</li><li>Model: GRNN + G3 model, where outputs of GRNN are pooled and fed into G3. The G3 was used to better model interaction between left and right context for an entity, as sentiment can be dominated by left or right context</li><li>Outputs: Targeted sentiment</li></ul><p><strong>Coreference Resolution</strong></p><p><a href="https://homes.cs.washington.edu/~luheng/files/emnlp2017_lhlz.pdf">Lee, Kenton, He, Luheng, Lewis, Mike, and Zettlemoyer, Luke, 2017. End-to-end Neural Coreference Resolution.</a></p><ul><li>Model: 2-step, 1st step being a biLSTM, and 2nd step being a FFNN</li><li>Inputs to FFNN: Something nice about this model is the fact that they were able to encode multi-word entities efficiently by concatenating LSTM outputs.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/227/1*7yoU47vuvU5CaBm-r3n3aw.png"/>ϕ used to encode size of span. x* are outputs of LSTMs for boundaries of span. x hat are outputs of attention mechanism over span.</figure><ul><li>FFNN architecture:</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/390/1*9KxdIWkYNSzMwDJeSI3fuw.png"/></figure><p><strong>Document-level Relation Extraction</strong></p><p><a href="https://www.cs.jhu.edu/~npeng/papers/TACL_17_RelationExtraction.pdf">Peng, Nanyun, Poon, Hoifung, Quirk, Chris, Toutanova, Kristina, Yih, and Wen-tau, 2017. Cross-Sentence N-ary Relation Extraction with Graph LSTMs.</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/1*-M0TCCGCpmYtYpVnYfhAHg.png"/>Example of a graph LSTM structure used in the paper. Note the additional links between non-adjacent cells encodes for syntactic dependencies and discourse relations.</figure><ul><li>Uses a graph LSTM with architecture following the structure of the document graph (introduced by <a href="https://arxiv.org/pdf/1609.04873.pdf">Quirk and Poon, 2017</a>), which encodes various dependencies, including word adjacency, syntactic dependencies, and discourse relations</li></ul><p><a href="https://arxiv.org/pdf/1802.10569.pdf">Verga, Patrick, Strubell, Emma, and McCallum, Andrew, 2018. Simultaneously Self-Attending to All Mentions for Full-Abstract Biological Relation Extraction.</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/345/1*6ap---pVvwWNNdCgwhh16w.png"/></figure><ul><li>Bi-affine neural model: First pass document through Transformer, then evaluate relations between pairs of tokens using a bi-affine operator and the LogSumExp function</li></ul><h4><strong>Methodologies</strong></h4><p><strong>Baseline Neural Model (Minimal Viable Plan)</strong></p><p>Inputs: for each token, concatenate word embeddings, polarity embeddings, and holder/target/none embeddings</p><ul><li>Word embeddings are pre-trained GloVe embeddings</li><li>EX: “the cat disliked milk”, holder = “cat”, target = “milk”</li><li>Input becomes: [the, 0, 0] [cat, 0, H] [disliked, NEG, 0] [milk, 0, T]</li></ul><p>Model: Attentive biLSTM</p><p>Output: Sentiment score for positivity and negativity</p><p><strong>Scoring Holder/Target Sentiment in a Second Step (Minimal Viable Plan / Stretch Goal, i.e. I think I can get this but I can’t guaruntee it)</strong></p><ol><li>Feedforward Neural Network: Incorporating the FFNN from the Lee et al. paper (see above for details). To adapt the architecture for my needs, I will get rid of the mention score, and thus the white and grey cells will be the same. The grey cell, instead of outputting a coreference score, will output a sentiment (positivity and negativity) score.</li><li>Bi-affine Scoring: Incorporating the scoring mechanism from the Verga et al. paper (see above for details). Instead of a “Transformer,” I will use the LSTM from my baseline model, which gets fed in to two MLPs, the biaffine operator, and finally aggregated using the LogSumExp function.</li></ol><p><strong>Experimenting with Different Ways of Aggregating across Different Mentions (Stretch Goal)</strong></p><ol><li>LogSumExp function from the Verga et al. paper (see above).</li><li>Encode inputs to second step in a way that incorporates information from all mentions.</li></ol><p><strong>Experimenting with Graph LSTM Structure (Stretch Goal)</strong></p><ul><li>Based off of ideas in Peng et al. paper (see above)</li></ul><p><strong>Incorporate Ideas from Targeted Sentiment Analysis (Stretch Goal)</strong></p><ul><li>Add a G3 gate, based on Zhang et al. paper (see above), or even adapt the architecture of the G3 gate to better suit the task of sentiment analysis between entities</li></ul><h4><strong>Available Resources</strong></h4><p>Dataset from Choi et al. (paper I’m improving). The data has already been pre-processed using StanfordNLP. Some of the preprocessing that’s been done includes tokenization, named entity recognition, and co-reference resolution.</p><h4><strong>Evaluation Plan</strong></h4><p>As an evaluation metric, I’m going to use the F1 scores for both positive and negative sentiments.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c8a12d3ae611" width="1"/></div>
    </content>
    <updated>2018-04-11T06:47:08Z</updated>
    <category term="deep-learning"/>
    <category term="naturallanguageprocessing"/>
    <category term="machine-learning"/>
    <author>
      <name>Belinda Zou Li</name>
    </author>
    <source>
      <id>https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/0*A16vZtRWBzxYPlmn.</logo>
      <link href="https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@be.li.nda" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Belinda Zou Li on Medium</subtitle>
      <title>Stories by Belinda Zou Li on Medium</title>
      <updated>2018-05-15T04:00:24Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://mathstoc.wordpress.com/?p=309</id>
    <link href="https://mathstoc.wordpress.com/2018/04/11/nlp-capstone-post-3-proposal/" rel="alternate" type="text/html"/>
    <title>NLP Capstone Post #3: Proposal</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Here, we finally present our project proposal in full. Project Objectives: Our goal for this project is to engineer a model that, given the instrumental (“karaoke”) music for a song in English represented as MIDI data, output a coherent sequence of words corresponding to lyrics for the music. The model will produce timings along with … <a class="more-link" href="https://mathstoc.wordpress.com/2018/04/11/nlp-capstone-post-3-proposal/">Continue reading <span class="screen-reader-text">NLP Capstone Post #3: Proposal</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>Here, we finally present our project proposal in full.</p>
<h3>Project Objectives:</h3>
<p>Our goal for this project is to engineer a model that, given the instrumental (“karaoke”) music for a song in English represented as MIDI data, output a coherent sequence of words corresponding to lyrics for the music. The model will produce timings along with the words to align it with the background instrumentals. Additionally, given the output of the model and the input music, we will automate their combination into a song complete with lyrics and supporting instrumentals. This combined output will be playable and we intend to do live demonstration.</p>
<h3>Proposed Methodology:</h3>
<p>Here, we outline the steps we will need to take in detail.</p>
<li>Data collection (datasets of songs, preferably with instrumentals and lyrics already separated)</li>
<li>Decide on vocabulary and how to handle uncommon words</li>
<li>Decide and implement any required preprocessing of the raw MIDI data. Strip lyrics from MIDI data if not already provided in dataset.</li>
<li>Decide and implement model (see Model Design)</li>
<li>Implement model sanity checks</li>
<li>Model tweaking (we expect this will take the majority of the time; see Model Design)</li>
<li>Implement automated combination of model output (lyrics) and model input (instrumentals)</li>
<li>Further testing</li>
<li>Assuming preceding steps are completed satisfactorily, proceed to stretch goals</li>
<li>Presentation and write-up</li>
<h3>Model Design:</h3>
<p>We will pursue a seq2seq RNN approach, taking in input MIDI data represented as a sequence, and outputting a sequence of words from a specified vocabulary. This model will be referred to as the generator. We will employ adversarial training, simultaneously training a many-to-one RNN discriminator that, given the input instrumentals and corresponding lyrics, output if the lyrics were produced by the generator or not. We will follow approaches taken in previous works such as SeqGAN [2] (and [3, 4]), namely using policy gradient ideas from reinforcement learning to obtain gradients that can be backpropagated from the discriminator network through the generator network. We note that syntactic correctness can be enforced in this manner, as malformed lyrical output can be assigned arbitrarily small reward.</p>
<h3>Stretch Goals:</h3>
<p>There are several stretch goals we will consider, time permitted. They are as follows, in no particular order.</p>
<li>Handling multiple languages, particularly those with less available data</li>
<li>Given a specific songwriter/band, produce the instrumentals along with lyrics for a new song that is in the style of that songwriter/band</li>
<li>Lyrics generation for duets, or multi-singer songs</li>
<li>Playing with phoneme-level generation</li>
<h3>Core Challenges:</h3>
<p>The core challenges we will need to overcome include alignment of lyrics with the music, and production of sensible lyrics. On the more technical side, it is well-known that ensuring convergence in adversarial training is difficult.</p>
<h3>Available Resources:</h3>
<p>Existing music datasets for machine learning tasks are made up of audio samples (such as .wav or .mp3), or MIDI data that specifies timing and notes. For karaoke, lyrics are also provided either as a separate text file (.LRC) specifying the timing of each word, or can be embedded into the MIDI file directly (.KAR). It may also be useful to train a lyric model on a larger corpus of song lyrics, since lyrics are easier to collect than fully time-annotated karaoke files.</p>
<p>The MusicNet dataset [9] provides 330 classical instrumental audio files, each of which has associated timing provided for every note. Since we are primarily interested in lyrical generation and alignment, this dataset is not going to be useful for creating a language model.</p>
<p>An existing karaoke dataset called Kara1k [1] provides many features computed from 1000 lyric-annotated songs. This provides lots of metadata about each song, including annotated chords for each timestep of the song. According to the KaraMIR website, these features are extracted from audio samples using Vamp Plugins, which estimates chords with accuracy up to 70%. </p>
<p>We propose a new dataset (name not yet determined) of MIDI karaoke data with embedded lyrics (.KAR). This dataset contains over 700 files, scraped from a karaoke content aggregator [11]. Timed lyrical data has been extracted from these files, and the precise timing of each note is already available by nature of the MIDI format.</p>
<p>Additional datasets for training a lyric model may be useful, and many are available. One such dataset is the 55000+ Song Lyrics on Kaggle [10]. This could help our model generalize its lyrical output beyond the limited set of vocabulary available within the 1000 or fewer annotated karaoke songs.</p>
<h3>Evaluation Plan:</h3>
<p>Evaluation of our model can be done several ways. The first is simply to listen to the music ourselves. This is the most direct method of evaluation but is not efficient, as likely we will need many iterations of tuning; furthermore, will likely need to listen to several songs to be confident of the model’s quality. Hence, we will also design basic “sanity check” tests for our models.</p>
<p>Recall that in our proposed methodology, we intend to use adversarial training. The discriminator network itself gives a direct evaluation of the generator. As long as the discriminator is of vetted quality, and the discriminator is run on sufficiently many examples (with roughly even number of generated and true examples mixed in), the generator will be deemed also of sufficient quality (as a “sanity check”).</p>
<p>Of course, this leaves the question of ensuring the discriminator is good. We can run the discriminator on instrumentals combined with randomly generated words (according to some distribution), or on instrumentals combined with the original lyrics, which are perturbed in some fashion. As an example, one can perturb the original lyrics temporally (making an utterance off-beat when it should be precisely on the down-beat of a bar) or replacing a few words with randomly selected ones (according to some distribution over the vocabulary). These “test inputs” to the discriminator can be generated before-hand.</p>
<h3>Literature Survey:</h3>
<p>Here are some relevant papers (most were already included in preceding posts).</p>
<p>[1] Y. Bayle, L. Marsik, M. Rusek, M. Robine, P. Hanna, K. Slaninova, J. Martinovic, J. Pokorny. “Kara1k: A Karaoke Dataset for Cover Song Identification and Singing Voice Analysis”. IEEE International Symposium on Multimedia (ISM), 2017. <a href="https://ieeexplore.ieee.org/document/8241597/" rel="nofollow">https://ieeexplore.ieee.org/document/8241597/</a></p>
<p>[2] L. Yu, W. Zhang, J. Wang, Y. Yu. “SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient”. Proceedings of the Thirty-First AAAI Conference on Artificial Intelligence, 2017. <a href="https://arxiv.org/abs/1609.05473" rel="nofollow">https://arxiv.org/abs/1609.05473</a></p>
<p>[3] S. Lee, U. Hwang, S. Min, S. Yoon. “A SeqGAN for Polyphonic Music Generation”. 2017. <a href="https://arxiv.org/abs/1710.11418" rel="nofollow">https://arxiv.org/abs/1710.11418</a></p>
<p>[4] H. W. Dong, W. Y. Hsiao, L. C. Yang, Y. H. Yang. “MuseGAN: Multi-track Sequential Generative Adversarial Networks for Symbolic Music Generation and Accompaniment”. 2017. <a href="https://arxiv.org/abs/1709.06298" rel="nofollow">https://arxiv.org/abs/1709.06298</a></p>
<p>[5] I. J. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, Y. Bengio. “Generative Adversarial Nets”. NIPS, 2014. <a href="https://papers.nips.cc/paper/5423-generative-adversarial-nets" rel="nofollow">https://papers.nips.cc/paper/5423-generative-adversarial-nets</a></p>
<p>[6] T. Salimans, I. J. Goodfellow, W. Zaremba, V. Cheung, A. Radford, X. Chen. “Improved Techniques for Training GANs”. NIPS, 2016. <a href="https://arxiv.org/abs/1606.03498" rel="nofollow">https://arxiv.org/abs/1606.03498</a></p>
<p>[7] M. Arjovsky,  S. Chintala, L. Bottou. “Wasserstein GAN”. 2017. <a href="https://arxiv.org/abs/1701.07875" rel="nofollow">https://arxiv.org/abs/1701.07875</a></p>
<p>[8] J. Faille, Y. Wang. “Using Deep Learning to Annotate Karaoke Songs”. 2016. <a href="https://www.semanticscholar.org/paper/Using-Deep-Learning-to-Annotate-Karaoke-Songs-Faille-Wang/521361762a7327f8fcc77bd9d76eaa2b503f845a" rel="nofollow">https://www.semanticscholar.org/paper/Using-Deep-Learning-to-Annotate-Karaoke-Songs-Faille-Wang/521361762a7327f8fcc77bd9d76eaa2b503f845a</a></p>
<p>[9] J. Thickstun, Z. Harchaoui, S. Kakade. “Learning Features of Music from Scratch”. 2017. <a href="https://arxiv.org/abs/1611.09827" rel="nofollow">https://arxiv.org/abs/1611.09827</a></p>
<p>[10] Additional data <a href="https://www.kaggle.com/mousehead/songlyrics">here</a></p>
<p>[11] Even more additional data <a href="http://vooch.narod.ru/midi/midi.htm">here</a></p></div>
    </content>
    <updated>2018-04-11T06:45:55Z</updated>
    <category term="NLP Capstone"/>
    <author>
      <name>Kuikui Liu</name>
    </author>
    <source>
      <id>https://mathstoc.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://mathstoc.wordpress.com/category/nlp-capstone/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://mathstoc.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://mathstoc.wordpress.com/osd.xml" rel="search" title="Mathematical Distractions" type="application/opensearchdescription+xml"/>
      <link href="https://mathstoc.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A recreational (occasionally research) blog on topics in maths or computer science - by Kuikui</subtitle>
      <title>NLP Capstone – Mathematical Distractions</title>
      <updated>2018-05-15T04:00:30Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-3753031463594823927.post-4531878816260312232</id>
    <link href="https://cse481n.blogspot.com/2018/04/blog-post-3.html" rel="alternate" type="text/html"/>
    <title>Blog Post #3</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h1 dir="ltr" id="docs-internal-guid-ea0c9d97-b369-9237-6f13-3675807d7a60" style="line-height: 1.38; margin-bottom: 6pt; margin-top: 20pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 20pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Project Objectives</span></h1><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Single document summarization (SDS) is one of the remaining challenging problems in natural language processing. Novel methods are presented frequently in new papers, but they often do not include specific code allowing for reproducibility and are evaluated on specific datasets that make comparisons between models meaningless and difficult.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">There are many approaches to SDS, but they can be broadly divided into combinatorial approaches and neural approaches. Neural approaches build a neural architecture, such as a seq2seq/encoder-decoder model or single sequence RNNs. Combinatorial approaches will either try to frame the problem as an optimization problem, and then use an ILP solver, or frame the problem as a classic NP-hard problem, like Knapsack or Maximum Coverage. We want to explore both approaches, and compare their performance on the same dataset.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">SDS is comprised of two tasks: extractive summarization and abstractive summarization. Extractive summarization compiles a summary by selecting sentences from the document’s text while abstractive summarization generates text for the summary (sentences that may not have been present in the document’s text). While abstractive summarization might have more intuitive appeal, our project will focus on extractive summarization to enable meaningful comparisons between neural and combinatorial approaches (combinatorial approaches often must be extractive).</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">In this project, we plan to implement at least one neural and one combinatorial model for extractive single document summarization. We hope to establish some meaningful ways to compare the differences between selections made by the different types of models. Our primary goal is to better understand the strengths and weaknesses of neural and combinatorial models for single document summarization - a particular important aspect of SDS given the general roughness of existing evaluation metrics. We will gauge our progress based on reaching acceptable performance on commonly-used evaluation metrics when we implement models.</span></div><h1 dir="ltr" style="line-height: 1.38; margin-bottom: 6pt; margin-top: 20pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 20pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Methodology</span></h1><h3 dir="ltr" style="line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 13.999999999999998pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Minimal Viable Action Plan</span></h3><ol style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Build our data set using existing data. Specifically, convert data better suited for training abstractive summarization models into data that can be used for extractive summarization..</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Implement a simple combinatorial model (for example, we can do a simple maximum coverage problem, where we set up the “universe” to be the vocabulary of the document, and treat the sentences as sets of words).</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Implement a simple neural model (just treat the problem as a generic binary classification problem).</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Train models on identical data sets and do a baseline comparison -- how well does a simple neural model do vs. a simple combinatorial model? This doesn’t tell us much about the relative strengths of the two approaches (we can’t quantify “simple”), but with some error analysis, we might be able to see what sentences neural models are misidentifying vs. what sentences combinatorial models are misidentifying.</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Build at least one state-of-the-art combinatorial model (adapting from a recent paper). We have two candidate papers: Hirao et al.’s Tree Knapsack approach and Durrett et al.’s Compression/Anaphoricity</span></div></li></ol><br/><h3 dir="ltr" style="line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 13.999999999999998pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Stretch Goals</span></h3><ol style="margin-bottom: 0pt; margin-top: 0pt;"><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Design our own model that is a combination of the strong points of the combinatorial and neural models. Ideally, our model would be as good as or better than the existing models we implemented on the quantitative and qualitative metrics we use.</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Alternatively, we can use ideas from one domain to improve an aspect of a SOTA model in the other domain. For example, we might learn that neural models are great at dealing with named entities, and so incorporate a neural layer in a combinatorial model (perhaps by allowing the output of the neural layer to determine the weights of named entities).</span></div></li><li dir="ltr" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;"><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Design a common system for comparing performance of extractive summarization models. Rather than a differentiable evaluation metric, we think it may be useful to choose a set of “tough” documents to summarize and bundle them together with specific reasons for their difficulty, so that researchers may more easily identify weaknesses in models they are working on.</span></div></li></ol><h1 dir="ltr" style="line-height: 1.38; margin-bottom: 6pt; margin-top: 20pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 20pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Available Resources</span></h1><h3 dir="ltr" style="line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 13.999999999999998pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Dataset/Evaluation</span></h3><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">For this problem, we will be using the DailyMail/CNN dataset. From our initial research, this seems to be the standard dataset for both document summarization as well as basic reading comprehension. The dataset has 400,000 articles, and includes both the full text of the article as well as bullet point “highlights”. For reading comprehension, an important word is omitted from the highlights and the machine is asked to fill in the blank. For text summarization, the bullet points are considered the “gold standard” summaries -- machine generated summaries are evaluated against the bullet points, typically</span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 700; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;"> </span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">using ROUGE metrics</span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 700; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;"> </span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">(Lin, 2004). While this works fine for abstractive summarization, this training corpus is not annotated enough for extractive summarization. More specifically, extractive summarization requires sentence level binary annotations, to indicate whether each sentence does or doesn’t belong in the summary. So we need to first convert the bullet points into more fine grained annotations.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">We’ve looked at two papers which briefly touched on this. Nallapati et. al. used a greedy approach, where they added one sentence at a time to the extractive summary while seeking to maximize the Rouge score with respect to the abstractive summary (the bullet points). They also tried to use an RNN decoder in combination with the abstractive summaries to train the extractive model without using sentence-level annotations. However, this approach was slightly less successful than estimating sentence-level annotations. Cheng and Lapata used a different approach - they created a “rule-based system that determines whether a given sentence matches a highlight...The rules take into account the position of the sentence in the document, the unigram and bigram overlap between document sentences and highlights, [and] the number of entities appearing in the highlight and in the document sentence”. It’s not 100% clear what rules the authors used, but according to Nallapati et. al., the rule-based approach found a better “ground-truth” than the greedy approach.</span></div><h3 dir="ltr" style="line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 13.999999999999998pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">GitHub Repositories</span></h3><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Some researchers publish the code they used in their paper on GitHub. We can use repos for quick comparisons or to see how they design their code.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><a href="https://github.com/abisee/pointer-generator" style="text-decoration: none;"><span>https://github.com/abisee/pointer-generator</span></a><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">: This repo is for See et al.’s Pointer-Generator neural model.</span></div><br/><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><a href="https://github.com/cheng6076/NeuralSum" style="text-decoration: none;"><span>https://github.com/cheng6076/NeuralSum</span></a><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">: This repo is for Cheng and Lapata’s neural model, that combines a sentence level RNN with a word level CNN.</span></div><h1 dir="ltr" style="line-height: 1.38; margin-bottom: 6pt; margin-top: 20pt;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 20pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Related Work and References</span></h1><br/><div dir="ltr"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Cheng, J., &amp; Lapata, M. (2016). Neural Summarization by Extracting Sentences and Words. </span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">arXiv:1603.07252 [Cs]</span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">. Retrieved from http://arxiv.org/abs/1603.07252</span></div><div dir="ltr"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Durrett, G., Berg-Kirkpatrick, T., &amp; Klein, D. (2016). Learning-Based Single-Document Summarization with Compression and Anaphoricity Constraints. </span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">arXiv:1603.08887 [Cs]</span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">. Retrieved from http://arxiv.org/abs/1603.08887</span></div><div dir="ltr"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Hirao, T., Yoshida, Y., Nishino, M., Yasuda, N., &amp; Nagata, M. (2013). Single-Document Summarization as a Tree Knapsack Problem. In </span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing</span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;"> (pp. 1515–1520). Seattle, Washington, USA: Association for Computational Linguistics. Retrieved from http://www.aclweb.org/anthology/D13-1158</span></div><div dir="ltr"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Lin, C.-Y. (2004). ROUGE: A Package for Automatic Evaluation of Summaries. In S. S. Marie-Francine Moens (Ed.), </span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Text Summarization Branches Out: Proceedings of the ACL-04 Workshop</span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;"> (pp. 74–81). Barcelona, Spain: Association for Computational Linguistics.</span></div><div dir="ltr"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">Nallapati, R., Zhai, F., &amp; Zhou, B. (2016). SummaRuNNer: A Recurrent Neural Network based Sequence Model for Extractive Summarization of Documents. </span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">arXiv:1611.04230 [Cs]</span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">. Retrieved from http://arxiv.org/abs/1611.04230</span></div><div dir="ltr"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">See, A., Liu, P. J., &amp; Manning, C. D. (2017). Get To The Point: Summarization with Pointer-Generator Networks. </span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">arXiv:1704.04368 [Cs]</span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;">. Retrieved from http://arxiv.org/abs/1704.04368</span></div></div>
    </summary>
    <updated>2018-04-11T06:33:00Z</updated>
    <author>
      <name>Ron &amp;amp; Aditya</name>
      <email>noreply@blogger.com</email>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-3753031463594823927</id>
      <author>
        <name>Ron &amp;amp; Aditya</name>
        <email>noreply@blogger.com</email>
      </author>
      <link href="https://cse481n.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="https://cse481n.blogspot.com/feeds/posts/default?alt=rss" rel="self" type="application/rss+xml"/>
      <title>PrimeapeNLP</title>
      <updated>2018-05-15T04:00:28Z</updated>
    </source>
  </entry>

  <entry>
    <id>tag:blogger.com,1999:blog-9203775015655831448.post-5878905571398539101</id>
    <link href="https://teamoverfit.blogspot.com/2018/04/3-project-proposal.html" rel="alternate" type="text/html"/>
    <title>#3 Project Proposal</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h2 style="height: 0px;"><span>Team Overfit</span></h2><h3><span><br/></span></h3><h3><span>Project repo: <span style="font-size: 18.72px;"><a href="https://github.com/pinyiw/nlpcapstone-teamoverfit">https://github.com/pinyiw/nlpcapstone-teamoverfit</a></span></span></h3><h4><span>Team members: Dawei Shen, Pinyi Wang, Xukai Liu</span></h4><span><br/></span><br/><div/><span><br/></span><br/><div style="text-align: start; text-indent: 0px;"><div style="margin: 0px;"><div><span><b>Blog Post: #3: 04/10/2018</b></span></div><div><span><span><b><br/></b></span></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Social Media Predicts Stock Price (StartUp Mode)</span></div><div><span><span><b id="docs-internal-guid-213a19db-b353-3e4c-1df6-5dd289daeb8b" style="font-weight: normal;"><br/></b></span></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>There are vast amount of new information related to companies listed on the stock market appears instantly, with immediate impact on stock prices. Our project is for monitoring those text on the social media platform and extract the key information that have impact on the stock prices and predict its future.</span><br/><span><br/></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Background and Project objectives </span></div><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><span><a href="https://www.investopedia.com/terms/s/stockmarket.asp">Stock Market</a> refers to the collection of markets and exchanges where the issuing and trading of equities, bonds and other sorts of securities takes place.</span></li><li><span>Social media, such as Twitter, often reflects how people think about a company and therefore can be used as an indicator of the changes of stock price in the near future.</span></li><li><span>Traditionally, analytics use statistical model built on past stock prices and recent news to forecast stock prices. We would like apply Machine Learning and Natural Language Processing models on social media to see if it has enough information for us to make good prediction of future stock price.</span></li></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"/><div><span><span><b style="font-weight: normal;"><br/></b></span></span></div><span><b>Proposed methodologies</b><span style="white-space: pre;"><b><br/></b></span></span><br/><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><b><span>Dataset:</span></b></li><ul><li><span><span style="background-color: white; color: black; vertical-align: baseline; white-space: pre;">Twitter data: </span><span style="background-color: white; color: #1155cc; vertical-align: baseline; white-space: pre;"><a href="https://developer.twitter.com/en/docs">https://developer.twitter.com/en/docs</a></span></span></li></ul></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><ul style="margin-bottom: 0pt; margin-top: 0pt;"><ul><li><span>Preprocess twitter data:</span></li></ul></ul><ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><ul><li><span>Tokenization</span></li></ul></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><ul><li><span>Stemming</span></li></ul></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><ul><li><span>Lemmatization</span></li></ul></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><ul style="margin-bottom: 0pt; margin-top: 0pt;"/></ul><li><span><span style="background-color: white; color: black; vertical-align: baseline; white-space: pre;">Bloomberg financial news dataset: </span><span style="background-color: white; color: #1155cc; vertical-align: baseline; white-space: pre;"><a href="https://github.com/philipperemy/financial-news-dataset">https://github.com/philipperemy/financial-news-dataset</a></span></span></li></ul></ul><span><b>Minimal viable action plan</b></span><br/><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><span>Forecast companies’ stock price changes (UP, DOWN, STAY) </span></li></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><b><span>Model</span></b></li></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><span>N-gram with appropriate smoothing as baseline</span></li></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><span>Use RNN/LSTM/GRU as model</span></li></ul><li><b><span>User Interface</span></b></li></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><span>Command line REPL</span></li></ul></ul><span><b>Stretch goals</b></span><br/><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><span>We could implement LSTM/GRU model to extract important information from the text in the preprocess</span></li></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><span>Forecast the approximate future stock price for a company given a future date</span></li></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><span>Auto trader bot that can take streaming tweets from twitter api and update the model prediction </span></li></ul><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><span>Fusion with 8-K reports to elevate the accuracy</span></li></ul><span><b>Evaluation plan</b></span><br/><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><span>F-1 score for (UP/DOWN)</span></li><li><span>Loss functions for comparing predictions and expectations.</span></li><li><span>Evaluate on time required to do a prediction.</span></li></ul></div><div style="margin: 0px;"><span><b style="white-space: pre;">Reference</b></span><br/><ul style="margin-bottom: 0pt; margin-top: 0pt;"><li><span><span style="background-color: white; color: black; vertical-align: baseline; white-space: pre;">On the Importance of Text Analysis for Stock Price Prediction: </span><a href="https://nlp.stanford.edu/pubs/lrec2014-stock.pdf"><span style="background-color: white; color: #1155cc; vertical-align: baseline; white-space: pre;">https://nlp.stanford.edu/pubs/lrec2014-stock.pdf</span></a></span></li><li><span><span style="color: black; vertical-align: baseline; white-space: pre-wrap;">Stock Trend Prediction Using News Sentiment Analysis: </span><span style="color: #1155cc; vertical-align: baseline; white-space: pre-wrap;"><a href="https://arxiv.org/pdf/1607.01958.pdf">https://arxiv.org/pdf/1607.01958.pdf</a></span></span></li></ul><div style="font-family: times;"/></div></div></div>
    </summary>
    <updated>2018-04-11T06:10:00Z</updated>
    <author>
      <name>Team Overfit</name>
      <email>noreply@blogger.com</email>
    </author>
    <source>
      <id>tag:blogger.com,1999:blog-9203775015655831448</id>
      <author>
        <name>Team Overfit</name>
        <email>noreply@blogger.com</email>
      </author>
      <link href="https://teamoverfit.blogspot.com/" rel="alternate" type="text/html"/>
      <link href="https://teamoverfit.blogspot.com/feeds/posts/default?alt=rss" rel="self" type="application/rss+xml"/>
      <title>NLP Capstone</title>
      <updated>2018-05-15T04:00:30Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/43368563cf97</id>
    <link href="https://medium.com/nlp-capstone-blog/machine-dictionary-43368563cf97?source=rss----9ba3897b6688---4" rel="alternate" type="text/html"/>
    <title>Machine Dictionary</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>We have decided to call our project, the Machine Dictionary. Formally, the goal of this project is to use a large corpus of data to generate definitions for technical terms that are consistent with how those terms are explored in the corpus.</p><h4>Motivation</h4><p>Our aim is to explore novel text generation approaches and apply them to the specific task of generating definitions. One of these techniques includes a specific approach we have termed “Connecting the Dots”. This approach will allow us to loosely structure the definitions such that they contain meaningful content but also keep the model general enough to generate appropriate context. We will discuss this approach further down. Another large motivation is the amount of research paper data we have from the AI2 Semantic Scholar corpus. This will allow us to use domain specific corpora to support definitions.</p><h4>Prior Work</h4><p>Although text generation has been a hot topic in NLP research for a while, we did not discover any prior attempts to generate definitions for technical terms. That said, the text generation task has itself been explored in great detail by many others.</p><p>In <a href="https://arxiv.org/pdf/1707.05501.pdf"><strong>this paper</strong> (Jain et al., 2017)</a>, the authors explore the task of generating short stories given a sequence of independent short descriptions. They approach the problem by using an Encoder-Decoder model to connect the descriptions and the short stories. This method might help us generate short text, but in our case, the input would be a large amount of data in the domain.</p><p>In this <a href="https://pdfs.semanticscholar.org/9dad/f5bb0a2182b1509c5ea60d434bb35d4701c1.pdf?_ga=2.15851958.1083977791.1523309085-1136887644.1523309085">other paper (Ghazvininejad et. al, 2016)</a>, the authors explore generating poetry based on topics. This paper is relevant to our project for several reasons. For instance, the paper generates poems based on a given topic, much like our goal which is to generate definitions based on a given term. In addition, the authors generate poetry by taking advantage of the structure of Shakespearean sonnets such as the unique rhyme scheme and the iambic pentameter cadence. We can use the techniques proposed in the paper to selectively choose information from the training corpus, based on the term we are asked to define and how we believe definitions should be structured.</p><h4>Minimum Viable Plan</h4><p>To reiterate, our model should be able to generate definitions that are based on context received from a large corpus. In this MVP, we can make the simplification that our model should generate definitions of a fixed length (for example, 5 sentences). These definitions should be grammatical and technically correct.</p><h4>Baseline Approach and Evaluation</h4><p>Andrej Karpathy, a former PhD student at Stanford, explores the incredible effectiveness of RNNs in in his blog. The article, <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">The Unreasonable Effectiveness of RNNs</a>, essentially claims that RNNs have an uncanny ability to learn the structure of training data, such as Wikipedia Articles, Shakespeare, and even code. In our baseline approach, we take advantage of this ability by training an RNN language model on the training data. At testing time, we can provide the term we seek to define as a seed to the RNN, which can then generate text until we hit a word limit or the RNN generates the &lt;STOP&gt; character. We can evaluate this approach by using perplexity, to ensure that we have a good language model. We can also cross-check definitions with other sources like Wikipedia articles. Finally, it might also be prudent to have humans evaluate the definitions.</p><h4>Target Approach I and Evaluation</h4><p>We propose two different target approaches to this model. In this first approach, we utilize techniques from work done previously in abstractive summarization. Given a term, we could filter the input data on all sentences associated with that term. We could obtain all the sentences that contain the data and a few sentences in the nearby surroundings, which could capture the context for the data. We would then use these sentences to generate a summary, which we would call the definition of the term. In this approach, we might use an attention mechanism to focus on the most important parts of the input. In terms of evaluation, we would use the cross referencing method from above, where we take the produced definition and the “correct definition” as determined by an external source and compare the number of common words.</p><h4>Target Approach II and Evaluation</h4><p>In this second approach, we explore a concept we have chosen to call “Connecting the Dots”. In this approach, we structure the definition generation by using key words. To elaborate, each term might be closely connected to a certain number of other words which could influence the definition of the term greatly. Consider the term <strong>osteoporosis</strong>. This term might be closely associated with the words <strong>bones, degrade, bone degradation, fractures, </strong>and <strong>women. </strong>We could use these words to structure a definition for <strong>osteoporosis </strong>as a fill in the blank task.</p><p><strong>Osteoporosis is … bones … degrade … bone degradation … fractures … women.</strong></p><p>In the above structure, we would rely on the model to appropriately and grammatically fill in the context between each keyword. As a result, we might generate the following definition:</p><p><strong>Osteoporosis </strong>is a disease that cause <strong>bones </strong>to <strong>degrade.</strong> <strong>Bone degradation </strong>often leads to <strong>fractures.</strong> <strong>Osteoporosis </strong>most commonly affects <strong>women.</strong></p><p>It’s important to note that when we fill in the context between keywords, we must condition on the original term that we are defining. For example, between the words <strong>fracture </strong>and <strong>women</strong>, there might be several sentences we could generate, but we must keep in mind how the keywords are related given that they are about <strong>osteoporosis.</strong></p><p>In this approach, we will build on the neural network model and add task-specific architecture to capture relationships between words. We hope that the model can learn how to define keywords associated with terms and use those terms to structure a definition.</p><p>In terms of evaluation, we introduce another technique. In this evaluation method we take a paragraph in which the technical term appears and omit the term. If we rephrase the problem as a classification task and ask the model to predict the omitted term, we would be able to conclude whether the model has a contextual understanding of the technical term. This evaluation technique would be a good supplement to the human evaluation method where we request users to rank how correct and readable the definitions are.</p><h4>Stretch Goals</h4><p>The ideal goal would be to generate text without any constraints on length, order, or keyword usage. This would be a more “hands-off” approach to text generation and could also allow us to train on different domain based corpora. We might be able to achieve this stretch goal if we perform well on the goals outlined in the Minimum Viable Plan.</p><p>Another stretch goal has to do with ontology matching, whereby we compare two definitions to determine whether they describe the same concept. We could extend this example to generate definitions for all technical terms across a body of research papers, determine which terms are defined similarly in different papers, and unify the terminology across all papers. This goal is definitely a stretch goal, but if we can perfect the architecture for generating definitions, we see this as a future application of our project.</p><h4>Data</h4><p>We plan to use the Semantic Scholar Open Research Corpus for this project. This corpus consists of over 20 million research papers classified into two domains (Computer Science and Medicine). Depending on the approach we take to solve this task, we would filter the data and train accordingly.</p><h4>Resources and Literature Survey</h4><p>We have mentioned several resources above that were the most useful for formulating the project proposal. Here are those resources and a few other resources that we think might be useful in the future.</p><p><strong>Text Generation Techniques</strong></p><p><a href="https://pdfs.semanticscholar.org/797d/7d968b88d5b5dd7c3271d08acd7296950d41.pdf?_ga=2.73597202.1083977791.1523309085-1136887644.1523309085">Using Lexical Chains for Text Summarization (Barzilay et. al, 1997)<br/></a><a href="https://pdfs.semanticscholar.org/9dad/f5bb0a2182b1509c5ea60d434bb35d4701c1.pdf?_ga=2.15851958.1083977791.1523309085-1136887644.1523309085">Generating Topical Poetry (Ghazvininejad et. al, 2016)</a></p><p><a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">The Unreasonable Effectiveness of RNNs</a></p><p><a href="https://arxiv.org/pdf/1707.05501.pdf">Story Generation from Sequence of Independent Short Descriptions (Jain et al., 2017)</a></p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=43368563cf97" width="1"/><hr/><p><a href="https://medium.com/nlp-capstone-blog/machine-dictionary-43368563cf97">Machine Dictionary</a> was originally published in <a href="https://medium.com/nlp-capstone-blog">NLP Capstone Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></div>
    </content>
    <updated>2018-04-11T06:03:31Z</updated>
    <category term="projects"/>
    <category term="machine-learning"/>
    <author>
      <name>Karishma Mandyam</name>
    </author>
    <source>
      <id>https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4</id>
      <logo>https://cdn-images-1.medium.com/proxy/1*TGH72Nnw24QL3iV9IOm4VA.png</logo>
      <link href="https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/nlp-capstone-blog" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>A Journey Through CSE 481N, the Natural Language Processing Capstone Course at the University of Washington - Medium</subtitle>
      <title>NLP Capstone Blog - Medium</title>
      <updated>2018-05-15T04:00:25Z</updated>
    </source>
  </entry>

  <entry xml:lang="en-US">
    <id>http://cse481n-capstone.azurewebsites.net/?p=37</id>
    <link href="http://cse481n-capstone.azurewebsites.net/2018/04/10/formal-proposal/" rel="alternate" type="text/html"/>
    <title>Formal Proposal</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Motivations: We want to create novel models for determining if the text is offensive, and why that text is offensive. To do this we want to create a new dataset that makes this task easier. We hope that our dataset and models pave the way for further innovations by others, as well as better trained … <a class="more-link" href="http://cse481n-capstone.azurewebsites.net/2018/04/10/formal-proposal/">Continue reading<span class="screen-reader-text"> "Formal Proposal"</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h3><span style="font-weight: 400;">Motivations:</span></h3>
<p><span style="font-weight: 400;">We want to create novel models for determining if the text is offensive, and why that text is offensive. To do this we want to create a new dataset that makes this task easier. We hope that our dataset and models pave the way for further innovations by others, as well as better trained conversational agents that have a better understanding of what they should or should not say. We’re going to teach them how to watch their language!</span></p>
<p><span style="font-weight: 400;">We would like to correctly classify sentences that keywords matching cannot achieve. For example:</span></p>
<p><b><i>What do you call an adult that has imaginary friends? Religious</i></b></p>
<p><span style="font-weight: 400;">And we would like to tell the reason why the sentence above is bad as well.</span></p>
<h3><span style="font-weight: 400;">Minimal Viable Plan:</span></h3>
<p><span style="font-weight: 400;">By comparing the similarity of content phrases found in r/MeanJokes posts and posts all over Reddit, we hope to create a large, high-quality dataset for training models to detect offensive text. We want to create this dataset and use crowdsourcing to label it. The labels should say if the text was offensive, and if it was then was it an attack against a particular group, what group that was, as well as the reasoning for why the labeler labeled the text this way. </span></p>
<p><span style="font-weight: 400;">While we wait for our data to be labeled, we want to start by creating baseline models on existing datasets, such as Twitter Hate Speech, Wiki Detox, and Stanford Politeness. We think that these datasets are similar enough to begin work on classifiers that don’t make use of deep annotation. After this, we can start work on improving performance on these datasets up until our crowdsourcing completes. We will explore novel models on existing datasets and try to improve their performance. </span></p>
<h3><span style="font-weight: 400;">Stretch Goals:</span></h3>
<p><span style="font-weight: 400;">Once our new Reddit dataset is fully labeled, we want to test the existing models that we made on the other datasets and continue improving them. We also want to use the new data to experiment with Q&amp;A or Deep Annotation models for creating a model that knows why a particularly offensive post is offensive. </span></p>
<p><span style="font-weight: 400;">In case if we can’t receive labeled dataset on time, we will continue to make improvements to novel models on existing datasets.</span></p>
<h3><span style="font-weight: 400;">Evaluation Plan: </span></h3>
<p><span style="font-weight: 400;">Classifier Models: Precision, Recall, F1 score</span></p>
<p><span style="font-weight: 400;">Rationale Models: deeper comparison to crowdsourced label explanations</span></p>
<p><span style="font-weight: 400;">Dataset: Random Sampling + Human Judgement</span></p>
<h3><span style="font-weight: 400;">Existing Work: </span></h3>
<h5><span style="font-weight: 400;">Previous Capstone Project: </span></h5>
<h5><a href="https://michael0x2a.github.io/nlp-capstone/"><span style="font-weight: 400;">Team Inverted Cat</span></a></h5>
<h5><span style="font-weight: 400;">Datasets: </span></h5>
<p><a href="https://github.com/ZeerakW/hatespeech"><span style="font-weight: 400;">Hate Speech Twitter Annotations</span></a><span style="font-weight: 400;"> (Waseem et al. 2016)</span></p>
<p><a href="https://github.com/t-davidson/hate-speech-and-offensive-language"><span style="font-weight: 400;">Hate Speech and Offensive language dataset </span></a><span style="font-weight: 400;"> (Davidson et al. 2017)</span></p>
<p><a href="https://meta.wikimedia.org/wiki/Research:Detox/Data_Release"><span style="font-weight: 400;">Wikipedia Talk Corpus </span></a><span style="font-weight: 400;"> (Wulczyn et al. 2017)</span></p>
<p><a href="http://www.cs.cornell.edu/~cristian//Politeness.html"><span style="font-weight: 400;">Stanford Politeness Corpus</span></a></p>
<p><a href="https://www.frontgatemedia.com/a-list-of-723-bad-words-to-blacklist-and-how-to-use-facebooks-moderation-tool/"><span style="font-weight: 400;">A list of bad words</span></a></p>
<p><span style="font-weight: 400;">Pre-trained word embeddings: GloVe, Facebook FastText, Google Word2Vec</span></p>
<h5><span style="font-weight: 400;">Papers: </span></h5>
<p><a href="https://www.semanticscholar.org/paper/Hateful-Symbols-or-Hateful-People%3F-Predictive-for-Waseem-Hovy/df704cca917666dace4e42b4d3a50f65597b8f06"><span style="font-weight: 400;">Waseem, Zeerak and Dirk Hovy. “Hateful Symbols or Hateful People? Predictive Features for Hate Speech Detection on Twitter.” SRW@HLT-NAACL (2016).</span></a></p>
<p><a href="https://www.semanticscholar.org/paper/Automated-Hate-Speech-Detection-and-the-Problem-of-Davidson-Warmsley/6ccfff0d7a10bf7046fbfd109b301323293b67da"><span style="font-weight: 400;">Davidson, Thomas J et al. “Automated Hate Speech Detection and the Problem of Offensive Language.” ICWSM (2017).</span></a></p>
<p><a href="https://www.semanticscholar.org/paper/Hate-Speech-Detection-with-Comment-Embeddings-Djuric-Zhou/c9948f7213167d65db79b60381d01ea71d438f94"><span style="font-weight: 400;">Djuric, Nemanja et al. “Hate Speech Detection with Comment Embeddings.” </span><i><span style="font-weight: 400;">WWW</span></i><span style="font-weight: 400;">(2015).</span></a></p>
<p><a href="https://www.semanticscholar.org/paper/Using-Convolutional-Neural-Networks-to-Classify-Gamb%C3%A4ck-Sikdar/0dca29b6a5ea2fe2b6373aba9fe0ab829c06fd78"><span style="font-weight: 400;">Gambäck, Björn and Utpal Kumar Sikdar. “Using Convolutional Neural Networks to Classify Hate-Speech.” (2017).</span></a></p>
<p><a href="https://www.semanticscholar.org/paper/Abusive-Language-Detection-in-Online-User-Content-Nobata-Tetreault/e39b586e561b36a3b71fa3d9ee7cb15c35d84203"><span style="font-weight: 400;">Nobata, Chikashi et al. “Abusive Language Detection in Online User Content.” </span><i><span style="font-weight: 400;">WWW</span></i><span style="font-weight: 400;">(2016).</span></a></p>
<p><a href="https://www.semanticscholar.org/paper/Ex-Machina%3A-Personal-Attacks-Seen-at-Scale-Wulczyn-Thain/4a7204431900338877c738c8f56b10a71a52e064"><span style="font-weight: 400;">Wulczyn, Ellery et al. “Ex Machina: Personal Attacks Seen at Scale.” </span><i><span style="font-weight: 400;">WWW</span></i><span style="font-weight: 400;"> (2017).</span></a></p></div>
    </content>
    <updated>2018-04-10T22:37:31Z</updated>
    <category term="Weekly blog"/>
    <author>
      <name>Team Watch Your Language!</name>
    </author>
    <source>
      <id>http://cse481n-capstone.azurewebsites.net</id>
      <link href="http://cse481n-capstone.azurewebsites.net/feed/" rel="self" type="application/rss+xml"/>
      <link href="http://cse481n-capstone.azurewebsites.net" rel="alternate" type="text/html"/>
      <subtitle>Spring2018 CSE481N Capstone</subtitle>
      <title>Team Watch Your Language!</title>
      <updated>2018-05-15T04:00:21Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/a1903faeadb7</id>
    <link href="https://medium.com/@ryanp97/project-proposal-neural-machine-translation-with-semantic-transfer-a1903faeadb7?source=rss-6378d85d3a9b------2" rel="alternate" type="text/html"/>
    <title>Project Proposal — Neural Machine Translation with Semantic Transfer</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>State-of-the-art neural machine translation does not currently utilize much, if any, semantic information, meaning it misses out on a large amount of potentially useful information indirectly embedded in the sentence. This project aims to explore the benefits that semantic transfer could offer to neural machine translation.</p><p>In particular, this project will focus on Dependency Minimal Recursion Semantics and translation between English DMRS and Japanese DMRS. Currently, I’m working on this project alone under the supervision of Jan Buys.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*AlAZF1O2uYt4b12hCu7ajA.png"/>An example of English and Japanese DMRS graphs for the above sentence. Note the sentences have the same meaning.</figure><h4>Minimal Viable Action Plan</h4><ol><li>Obtain a parallel corpus.</li><li>Parse DMRS graphs from the parallel corpus</li><li>Simplify graphs (and be able to recover them in a robust manner to handle the model’s output)</li><li>Train a seq2seq model to predict a Japanese DMRS graph given an English DMRS graph as well as the required embeddings</li></ol><p>I’ve chosen the <a href="http://www.edrdg.org/wiki/index.php/Tanaka_Corpus">Tanaka Corpus</a> as my parallel corpus and cleaned it such that the only remaining sentences are English and Japanese sentences which belong to a translation pair. From there, I’ve parsed the corresponding DMRS graphs. For further details on how I cleaned the corpus and parsed the graphs, refer to my <a href="https://medium.com/@ryanp97/project-logistics-and-package-exploration-3d3651220219">last</a> blog post.</p><p>Currently, I’m working on how to simplify and recover the graphs robustly. Simplifying the graph seems fairly easy; however, I made some incorrect assumptions about the graphs, so recovery is currently a work in progress. Furthermore, I have yet to handle the robustness aspect. In general, I need to handle the cases where the model does not output a valid “simplified” graph. This includes, but is not limited to: handling mismatched/missing parentheses.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LdgExRT9YoJ-UwxYxwJfsA.png"/>On the left is the English DMRS and on the right is the Japanese DMRS. Each example is labeled with a sentence ID and the original sentence (prefixed with `#` which Smatch ignores). The model will not have to predict these comments. However, in the future, we’d like to extend the model such that it would be able to recover the original sentence after generating a DMRS graph in the target language.</figure><p>From then, the last step in the minimal viable action plan is to train and evaluate model. Ideally, we would train the embeddings for the tokens in the graphs and the seq2seq model end-to-end with <a href="https://amr.isi.edu/eval/smatch/tutorial.html">Smatch</a> as the objective function, though I am still working with Jan on how I should piece this model together.</p><h4>Stretch Goals</h4><ol><li>Explore alternatives to standard seq2seq models (i.e. TreeLSTMs, custom architecture, etc.)</li><li>Expand/supplement dataset with <a href="https://alaginrc.nict.go.jp/WikiCorpus/index_E.html">Kyoto Corpus</a></li></ol><p>Since we are expecting the model to learn and generate graphs, it would be ideal if we were able to use a tree-like structure that would more accurately represent the data. If I am able to finish the minimal viable action plan with enough time left over, I would like to experiment and test out different architectures and see how that affects the model’s performance. There are a couple different packages for TreeLSTMs (such as <a href="https://github.com/dasguptar/treelstm.pytorch">this</a> one) that would potentially make this task not too difficult. Though, eventually I would like to customize an architecture for this task.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/496/1*omSJj6AYg7TDPUW0XPY6ew.png"/>A figure of a TreeLSTM grabbed from the <a href="https://arxiv.org/pdf/1503.00075.pdf">original</a> paper on TreeLSTMs.</figure><p>Each example in the Tanaka Corpus is a single sentence, making it easy to work with in terms of development and debugging. However, if I have extra time, I would like to supplement the Tanaka Corpus with the Kyoto Corpus which is comprised of translated Wikipedia articles. The corpus has much longer examples and provides a much more complex and realistic setting. An issue is that the documentation is in Japanese, and it is not entirely clear which of the different translations is “correct” as each example has a “primary,” “secondary,” and “check” translation. You can read more about it on the Kyoto Corpus website, hyperlinked above.</p><h4>Evaluation Plan</h4><p>There is not really a good statistical model, nor are there results that are very comparable due to the scope of the project. Since the scope of the project does not include recovering the sentence from a generated DMRS graph, comparisons between this project and papers that do tree-to-tree machine translations don’t really make much sense.</p><p>I expect to have some time leftover to explore different architectures, so I hope to make the seq2seq results the baseline for comparison for other architectures I have time to try.</p><h4>Related Work</h4><p><a href="https://arxiv.org/pdf/1704.08381.pdf">Neural AMR: Sequence-to-Sequence Models for Parsing and Generation</a> is fairly relevant to this project in the sense that it has similar motivations for working with semantics in NLP. The paper covers how they overcame a lack of labeled data, achieved competitive results for both parsing AMR graphs and generating text from AMR graphs, as well as extensive ablation studies and analysis. Their graph preprocessing steps are extremely relevant to this project, and I will likely be referencing their paper and <a href="https://github.com/sinantie/NeuralAmr">codebase</a> often as I work on cleaning and preprocessing the Tanaka Corpus.</p><p><a href="https://arxiv.org/pdf/1503.00075.pdf">Improved Semantic Representations From Tree-Structured LSTMs</a> provides a good basis for my stretch goals. The Child-Sum TreeLSTM units seem like a good option to test for representing the DMRS graph as any given node can take any number of children. These children can be used to represent dependencies as outlined in the paper, but it seems it might be possible to have the properties of a head word as children of the corresponding node as well. There’s a couple other useful ideas that come from the paper, but for the sake of brevity, we’ll leave it at this.</p><p><a href="https://arxiv.org/pdf/1603.06075.pdf">Tree-to-Sequence Attention Neural Machine Translation</a> is a slight glimpse at the future of this project. If this project is successfully able to transfer semantic information between languages, the next step would make the model complete the entire cycle, sequence-to-graph-to-graph-to-sequence, in hopes of achieving better results than statistical machine translation.</p><p>Additionally, here is a short list of other relevant papers:</p><ul><li><a href="https://arxiv.org/pdf/1409.0473.pdf">Neural Machine Translation by Jointly Learning to Align and Translate</a></li><li><a href="https://arxiv.org/pdf/1704.07092.pdf">Robust Incremental Neural Semantic Graph Parsing</a></li><li><a href="http://www.aclweb.org/anthology/P13-2131">Smatch: an Evaluation Metric for Semantic Feature Structures</a></li></ul><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a1903faeadb7" width="1"/></div>
    </content>
    <updated>2018-04-10T05:31:27Z</updated>
    <category term="machine-learning"/>
    <author>
      <name>Ryan Pham</name>
    </author>
    <source>
      <id>https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*83KfTWByl5pPq7A8_E8ApA.gif</logo>
      <link href="https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@ryanp97" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Ryan Pham on Medium</subtitle>
      <title>Stories by Ryan Pham on Medium</title>
      <updated>2018-05-15T04:00:06Z</updated>
    </source>
  </entry>
</feed>
