<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/" xmlns:indexing="urn:atom-extension:indexing" indexing:index="no"><access:restriction xmlns:access="http://www.bloglines.com/about/specs/fac-1.0" relationship="deny"/>
  <title>NLP Capstone Spring 2018</title>
  <updated>2018-08-15T00:04:34Z</updated>
  <generator uri="http://intertwingly.net/code/venus/">Venus</generator>
  <author>
    <name>Nelson Liu</name>
    <email>nfliu[at]cs.washington.edu</email>
  </author>
  <id>https://nlpcapstone.github.io/atom.xml</id>
  <link href="https://nlpcapstone.github.io/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://nlpcapstone.github.io/" rel="alternate"/>

  <entry>
    <id>https://medium.com/p/b7c31ac45ecc</id>
    <link href="https://medium.com/@halden.lin/nlp-capstone-09-any-summary-b7c31ac45ecc?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone | 09: Any Summary</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><em>previous posts: </em><a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5"><em>01</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5"><em>02</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3"><em>03</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7"><em>04</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a"><em>05</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0"><em>06</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-07-formalizing-a2d837ecf66b"><em>07</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-08-human-summaries-33072535817f"><em>08</em></a></p><p>In my last post, I stated a main goal of mine was to visualization <strong>human summaries</strong>. After talking with Prof. Jeff Heer this past week, I’ve developed a more concrete goal for this segment of my project.</p><p>If we are able to develop a method for approximating human ‘attention’ between source and summary, we can use it in the following ways.</p><ol><li><strong>Evaluation tool.</strong> Current evaluation requires reading article, summary, and thinking critically to map between the two in order to determine whether or not the summary is ‘good’.</li><li><strong>Enable cross-model comparison and analysis.</strong> How do different models produce summaries for the same article? Automatic measures, such as Rouge and Meteor, are generally poor indicators of proper quality. Currently, one may read summaries and source text and attempt to qualify proper coverage of key ideas. By introducing a visualization that can be generated from <strong>any</strong> source-summary pair, we can enable more principled analysis.</li><li><strong>Enable model to human comparison and analysis.</strong> This I discussed in the previous post. What do human summaries have that our models are missing? Missing coverage? Missing entities? This visualization tool could answer these questions.</li></ol><p><strong>In general, this tool would allow researchers to gain insights about both human and machine summaries.</strong></p><p>With this in mind, I’ll go into the approaches I’ve been experimenting with in the past week.</p><h4>Hierarchical Similarity</h4><p>Last week, I attempted token-on-token similarity. The results can be seen the gif below. The weight between input and output token <em>x </em>and <em>y</em>, respectively, can be described as so:</p><p><em>a(x, y) = similarity(x, y)</em></p><p>Where similarity is calculated using a standard word embedding API (in this case, <a href="https://spacy.io/">spaCy</a>). The issue with this approach was that context is lost, and so a word will often attend to nearly the entire document with no regard to the ideas coming out of each portion (in summaries, we expect a sentence or phrase to summarize a specific part or few parts of the original document).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*-ganHe0RsisBYzaPKOuHhA.gif"/>Token-on-token similarity pays no heed to context — problematic.</figure><p>In attempt to remedy this, I added a factor to each weight that represents the similarity of the tokens’ respective sentences. That is, the weight of a given <em>x, y</em> pair is determined by the similarity of the sentence of <em>x </em>and the sentence of <em>y</em>, multiplied by the similarity of the tokens themselves. To both normalize weights (over output token) and exaggerate salient pairs, I also add a soft-max transformation for each similarity score. The equation below describes this formula.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*WE0z9rPYF_Nb_X4Y."/></figure><p>The <em>theta</em> terms here are important in properly exaggerating salient pairs, and so require some tuning.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*QJFNJ0ty3NimB1nBAnTdXg.gif"/>Hierarchical Similarity shows some promise, but has a few issues.</figure><p>This approach shows some promise. Context is taken into account, at least at a sentence-by-sentence level. However, there are a few shortcomings that become apparent with more abstractive summaries. In particular:</p><ul><li><strong>Context is better but far from perfect.</strong> Sometimes ideas span multiple sentences, difficult to model. Additionally, repeating words in a sentence get equal ‘attention’ even though one may make more sense from a token-by-token generation standpoint.</li></ul><p>I’ll be exploring this approach further in the next week, but I have concerns about its ability to generalize well, per issues described above.</p><h4>Hidden Markov Model</h4><p>At a high level, we can imagine ‘attention’ as the words and phrases from the source text to that one would draw from to write a portion of a summary. This makes sense: we tend to focus on specific areas of a document at a time when writing summaries. Breaking this into token-by-token time-steps, summary token is <strong>conditioned</strong> on the ‘attention’ vector for that time-step.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/151/1*6wNP-KSn13tGSSwDjmDXxw.png"/>Summary tokens are conditioned on attention vectors over the source text.</figure><p>Further, we can reason that attention vectors change from time-step to time-step, dependent on the previous attention vector.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/361/1*krjZPlauErnawaKymE5LAA.png"/>Attention vectors are conditioned on each other.</figure><p>This of course is an simplification — the way our minds work is likely far more complex — but it allows us to model the ‘attention’ between source and summary as a Hidden Markov Model (HMM).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/611/1*3wfXRV8pMJZQ74Ux1OGjDA.png"/>Source to summary modeled as a Hidden Markov Model.</figure><p>We can then use this model to predict attention vectors at each time-step (e.g. Viterbi, Forward-Backward). This is similar to how HMMs are used to predict part-of-speech tags (where POS tags are conditioned on each other and tokens are conditioned on those tags). Emissions (the edge weight going from distribution to summary token) can be defined by token similarity, but there are still a challenges here.</p><ol><li>How to define transition probabilities?</li><li>Treat attention states as distributions or single tokens (e.g. argmax in vector)?</li></ol><p>I’ll need to consider this approach further to see if I can work out these kinks.</p><h4>POS Tags</h4><p>I’ve also been slowly improving the visualization tool itself. I’ll briefly describe my progress on this front.</p><p>Using <a href="https://www.nltk.org/">NLTK</a>, I was able to part-of-speech tag machine-generated summaries. At the top right of the visualization, users are presented a panel of the POS Tags used by the <a href="https://catalog.ldc.upenn.edu/ldc99t42">Penn Tree Bank</a>, which NLTK sources from. Non-present tags are greyed-out.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*i87AaOJBtCzk4h_G5b5z9A.gif"/>Users can highlight tokens to view the corresponding tag, or mouse over tags to highlight all corresponding tokens.</figure><p>This should allow more in-depth analysis of the attention vectors produced by the machine. Eventually I’d like to work towards highlighting named entities in the source / summary to allow users to identify present / missing ideas centered on important entities.</p><h4>Upcoming Work</h4><ol><li>Continue working on visualizing source-summary alignment.</li><li>Continue improving visualization.</li></ol><p>I have lots, lots, lots to do. Until next time!</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b7c31ac45ecc" width="1"/></div>
    </content>
    <updated>2018-05-23T06:43:01Z</updated>
    <category term="data-visualization"/>
    <category term="computer-science"/>
    <category term="machine-learning"/>
    <category term="nlp"/>
    <category term="visualization"/>
    <author>
      <name>Halden Lin</name>
    </author>
    <source>
      <id>https://medium.com/@halden.lin?source=rss-2759d54493c0------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*Hzu2ZqgloT0I1F6Kwg8OPA.jpeg</logo>
      <link href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@halden.lin" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Halden Lin on Medium</subtitle>
      <title>Stories by Halden Lin on Medium</title>
      <updated>2018-08-15T00:02:15Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://mathstoc.wordpress.com/?p=339</id>
    <link href="https://mathstoc.wordpress.com/2018/05/17/nlp-capstone-post-8-training-challenges/" rel="alternate" type="text/html"/>
    <title>NLP Capstone Post #8: Training challenges</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Challenges with training TSL model In our previous post we proposed a three-model system that would allow us to take advantage of a larger corpus of higher quality lyrics data for the production of lyrics. We also finally tackle the alignment task with a simple approach of determining whether a lyric token should be produced … <a class="more-link" href="https://mathstoc.wordpress.com/2018/05/17/nlp-capstone-post-8-training-challenges/">Continue reading <span class="screen-reader-text">NLP Capstone Post #8: Training challenges</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h1><span style="font-weight: 400;">Challenges with training TSL model</span></h1>
<p><span style="font-weight: 400;">In our previous post we proposed a three-model system that would allow us to take advantage of a larger corpus of higher quality lyrics data for the production of lyrics. We also finally tackle the alignment task with a simple approach of determining whether a lyric token should be produced at each timestep. This seems sensible since we have begun dividing the MIDIs into pianorolls with a constant frequency.</span></p>
<p><span style="font-weight: 400;">Unfortunately, even after several bugs bashed, we’ve been still unable to produce even sensible timings. We find the RNN collapses to repeatedly generating 0 (for no lyric event), even though a randomly initialized RNN will repeatedly generate 1 (and perform better with respect to classification accuracy).</span></p>
<p> </p>
<h1><span style="font-weight: 400;">Future direction</span></h1>
<p><span style="font-weight: 400;">If we are able to produce something reasonable from our existing architecture, we would like to move on to a second model that structures the problem as machine translation. We have decided to focus on the paper Attention is All You Need by Vaswani et al. [1] for our presentation in two weeks. The structure of our problem is straightforward to apply to translation as converting pianoroll format into english sentences. Incorporating attention has shown promising results in the literature, though that is no guarantee that our noisy dataset would be able to take advantage of this proposed architecture.</span></p>
<p> </p>
<h1><span style="font-weight: 400;">References</span></h1>
<p><span style="font-weight: 400;">[1] </span><a href="https://arxiv.org/abs/1706.03762"><span style="font-weight: 400;">https://arxiv.org/abs/1706.03762</span></a></p></div>
    </content>
    <updated>2018-05-17T05:55:03Z</updated>
    <category term="NLP Capstone"/>
    <author>
      <name>Nicholas Ruhland</name>
    </author>
    <source>
      <id>https://mathstoc.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://mathstoc.wordpress.com/category/nlp-capstone/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://mathstoc.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://mathstoc.wordpress.com/osd.xml" rel="search" title="Mathematical Distractions" type="application/opensearchdescription+xml"/>
      <link href="https://mathstoc.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A recreational (occasionally research) blog on topics in maths or computer science - by Kuikui</subtitle>
      <title>NLP Capstone – Mathematical Distractions</title>
      <updated>2018-08-15T00:03:58Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/33072535817f</id>
    <link href="https://medium.com/@halden.lin/nlp-capstone-08-human-summaries-33072535817f?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone | 08: Human Summaries</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><em>previous posts: </em><a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5"><em>01</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5"><em>02</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3"><em>03</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7"><em>04</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a"><em>05</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0"><em>06</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-07-formalizing-a2d837ecf66b"><em>07</em></a></p><p>I’ll keep this blogpost short — my current undertakings are in-progress and it might be a week or more before they are realized. To preface:</p><ol><li>Visualizing human summaries</li><li>Improving the visualization.</li></ol><h3>Visualizing Human Summaries</h3><p>When I was presenting my project update last week, Prof. Choi asked a very interesting question. What if we could use this visualization tool to not only understand how the model is generating summaries, but also how human summaries are produced and how the two compare?</p><p>I’ll briefly explain the thought behind this.</p><p>Visualizations provide a mapping from raw data (in this case, attention weights and input / output tokens) to visual encodings. These visual encodings are valuable in that they allow us as humans to perceive the data in a meaningful way. For example, the attention visualizer I am working on allows us to identify overall patterns in the attention of the model.</p><p>How do we interpret human written summaries, i.e. their relation to the source text? Perhaps we scan the document and attempt to match paragraphs or sentences to sentences in the summary. This can be compared to the ‘attention’ our minds use to generate the summary. If we can visualize this mapping, perhaps in a more refined and detailed manner (i.e. token by token) then we should be able to compare the human summaries with the machine generated summaries, right? And then one may be able to identify what the human summaries have that the machine summaries do not, or visa versa. The hope is that if we can enable this kind of comparison, researchers may be better equipped to improve their models by using these insights.</p><p>So far, I’ve experimented with two methods for generating this ‘attention’ from human summary to source text.</p><h4>Word Similarity</h4><p>The first approach that sprung to mind was to use word similarity as a proxy for ‘attention’. To do this, I used <a href="https://nlp.stanford.edu/projects/glove/">pre-trained GloVe embeddings</a> and the <a href="https://radimrehurek.com/gensim/">Gensim API</a> to calculate word similarities between each input token / output token pair. <a href="https://spacy.io/">SpaCy</a> was used to tokenize the sequences. The result is a matrix of weights, similar to attention distribution, albeit not normalized per output token (with attention, for a given output token the aggregate over all input tokens is 1). As the example below shows, this method falls flat, as output tokens are matched to input tokens regardless of context. This means it makes little sense to compare these weights to attention.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*D6pMsnZjlNiz1XJyN5xcBQ.png"/>The word ‘the’ is matched with nearly every token in the input sequence, likely a result of its extreme commonness and proximity to most words in embedding space.</figure><h4>Summarization Model</h4><p>The second method I considered was one suggested by Ari. Here, we use the same model used to generate the machine summaries. The difference is that at each decoder time-step, instead of feeding in the previous <strong>predicted</strong> token, we feed in the previous <strong>actual</strong> token. This means that instead of having a decoding pipeline that looks like this:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*N-til0kZzQeAVI3zkoDKVg.jpeg"/></figure><p>Where y-hats represent predicted output tokens, we have one that looks like this:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*H7nMlelojnzNkfthS2ljAg.jpeg"/></figure><p>Where y (no hat) represents true output token (the token from the human summary). This is a process similar to the one taken during training of generative encoder-decoder models.</p><p>By grabbing attention distributions just as we had with the machine summaries, we hope to get an approximation of the attention distributions for the human summaries — we are essentially feeding the model the answer. However, there is a catch, and an important one. Because attention weights are used to create a context vector that is then fed into the <strong>next</strong> decoder unit to predict the <strong>next </strong>word, we run into an issue when the next word is predicted incorrectly. Turns out, this happens often under the model being used (from <a href="https://github.com/abisee/pointer-generator">See et al.</a>). This actually makes sense, as the model has been shown to produce largely <strong>extractive </strong>summaries, and so one would expect the model to, at each time-step, attempt to produce the next word in the source text that follows the word fed to it. With <strong>abstractive</strong> summaries, this is not often the optimal choice. This results in attention weights that make little sense, as seen below.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*c5KuVp0qzjkcQxNAJSfYLw.png"/>According to this, ‘manager’ was the focal point of attention when producing the word ‘were’. It would seem that the model intended to predict ‘manager’, and so when we map this attention weight to the human token, we run into an issue.</figure><p>Here’s the problem. The model is trained to use attention weights to <strong>generate </strong>an output token. What we want is the opposite. We want the attention <strong>given</strong> an output token — use the output token to generate the attention weights. This poses a significant challenge.</p><h4>So How Else?</h4><p>So neither of these methods seem to produce anything meaningful. I’m not ready to give up though — this is an intriguing problem. In the next week I’ll be brainstorming other methods. One that might have some traction is to use a few heuristics to approximate ‘attention’ using word similarities in conjunction with context. For example, by imposing a penalty on the weight if the context of the output token is dissimilar to the word ‘attended’ to in the source text. Much more work to be done here.</p><h3>Improving the visualization</h3><p>This section will be short. There are a few problems I looked into in the past week.</p><ol><li>Implement divided edge bundling, as produced by <a href="http://vis.stanford.edu/files/2011-DividedEdgeBundling-InfoVis.pdf">Selassie et al. (2011)</a>. I described this briefly in my previous blog post. The obstacle here is that there is not available d3 implementation of the algorithm. In fact, the only implementation I could find available was <a href="https://github.com/kakearney/divedgebundle-pkg">one for Matlab</a>, produced by <a href="http://kellyakearney.net/">Kelly Kearny (University of Washington)</a>. This might prove more difficult than the remaining time in this quarter allows, but I’ve started the process anyways and will see where it takes me.</li><li>Highlighting extraction. That is, making it apparent in the visualization when the model is simply copying. I’ve been playing around with things such as color to encode this, but haven’t settled on anything I like.</li></ol><p>More work to come!</p><h4>References</h4><ol><li><a href="https://arxiv.org/pdf/1704.04368.pdf">See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” <em>ACL</em> (2017).</a></li><li><a href="http://vis.stanford.edu/files/2011-DividedEdgeBundling-InfoVis.pdf">Selassie, David et al. “Divided Edge Bundling for Directional Network Data.” <em>IEEE Transactions on Visualization and Computer Graphics</em> 17 (2011): 2354–2363.</a></li></ol><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=33072535817f" width="1"/></div>
    </content>
    <updated>2018-05-16T06:58:49Z</updated>
    <category term="computer-science"/>
    <category term="visualization"/>
    <category term="nlp"/>
    <category term="machine-learning"/>
    <category term="data-visualization"/>
    <author>
      <name>Halden Lin</name>
    </author>
    <source>
      <id>https://medium.com/@halden.lin?source=rss-2759d54493c0------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*Hzu2ZqgloT0I1F6Kwg8OPA.jpeg</logo>
      <link href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@halden.lin" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Halden Lin on Medium</subtitle>
      <title>Stories by Halden Lin on Medium</title>
      <updated>2018-08-15T00:02:25Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://mathstoc.wordpress.com/?p=335</id>
    <link href="https://mathstoc.wordpress.com/2018/05/10/nlp-capstone-post-7-tsl-pipeline/" rel="alternate" type="text/html"/>
    <title>NLP Capstone Post #7: TSL Pipeline</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">  Modeling issues As seen in our results last week, the RNN architecture we have been training has not been able to produce any coherent series of tokens based on the music data provided in the clean Lakh dataset. To analyze the poor results of this model, we have considered various features of the quality … <a class="more-link" href="https://mathstoc.wordpress.com/2018/05/10/nlp-capstone-post-7-tsl-pipeline/">Continue reading <span class="screen-reader-text">NLP Capstone Post #7: TSL Pipeline</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p> </p>
<h2><span style="font-weight: 400;">Modeling issues</span></h2>
<p><span style="font-weight: 400;">As seen in our results last week, the RNN architecture we have been training has not been able to produce any coherent series of tokens based on the music data provided in the clean Lakh dataset. To analyze the poor results of this model, we have considered various features of the quality of the data. To simplify the issue of timing the lyric tokens, this model attempts to predict a lyric token at every timestep. Between each token we have summed all the musical data, producing a piano roll that looks approximately like the following image.</span></p>
<p><img alt="Screen Shot 2018-05-09 at 4.31.53 PM" class="  wp-image-331 aligncenter" height="303" src="https://mathstoc.files.wordpress.com/2018/05/screen-shot-2018-05-09-at-4-31-53-pm.png?w=501&amp;h=303" width="501"/></p>
<p><span style="font-weight: 400;">In the event that two lyrics occur at exactly the same time step, we end up with a gap in the notes, here highlighted in red.</span></p>
<p><img alt="Screen Shot 2018-05-09 at 4.31.53 PM" class="  wp-image-334 aligncenter" height="302" src="https://mathstoc.files.wordpress.com/2018/05/screen-shot-2018-05-09-at-4-31-53-pm1.png?w=500&amp;h=302" width="500"/></p>
<p><span style="font-weight: 400;">At first we expected this problem to occur in only a small number of cases, but it is often the result of the newline character appearing in a message simultaneously with the first lyric of the next sentence. This processing poses several problems to the task of learning the lyrical content based on the structure of the music. First, the large number of musical gaps may be confounding the model due to the large variety in lyrics that will be seen at those time steps. Additionally, we lose all information about the song timing since all regions without lyrics are compressed into a single time step. In theory, gaps in lyrics could hint to the model that the next section should start a new verse or chorus.</span></p>
<h2><span style="font-weight: 400;">The TSL Pipeline</span></h2>
<p><span style="font-weight: 400;">As suggested in the previous blogpost, we would like to be able to augment the results of the musical model with a higher quality lyrical dataset. The Kaggle lyrics dataset has shown promising results in previous blogposts at the quality of the lyric sequences it has been able to produce.</span></p>
<p><span style="font-weight: 400;">The TSL Pipeline is a combination of three models: Timing, Seed, and Lyrics. The architecture may look something like the following diagram:</span></p>
<p><img alt="Training" class="  wp-image-333 aligncenter" height="221" src="https://mathstoc.files.wordpress.com/2018/05/training.png?w=531&amp;h=221" width="531"/></p>
<p><span style="font-weight: 400;">During training, each pianoroll will be separated into data representing the timing, notes and lyrics. These get passed into respective models to learn timing and “seed” information. Additional lyrics information from the Kaggle dataset is used to train a lyrical model.</span></p>
<p><img alt="Evaluation" class="  wp-image-332 aligncenter" height="220" src="https://mathstoc.files.wordpress.com/2018/05/evaluation.png?w=538&amp;h=220" width="538"/></p>
<p><span style="font-weight: 400;">At evaluation time, the lyrics from the original pianoroll are not passed into the Seed model. Instead, the Seed model attempts to predict some seed based on the musical content, and will pass its result into the lyrics model. The combination of these lyrics and timing information constitute the complete description of our karaoke output.</span></p>
<h2><span style="font-weight: 400;">Timing Model</span></h2>
<p><span style="font-weight: 400;">In all previous posts we ignored the issue of lyrics timing in the interest of creating a reasonable lyrical model. Our current timing model is similar to our previous model attempt, but the data is generated differently. Instead of computing a pianoroll sample at each lyrical timestep, we us a constant sampling frequency of 10 timesteps per second. We then annotate each timestep with a 1 or 0 based on if a lyric was annotated at that step. The model will then attempt to predict for each step of a given pianoroll the probability there should be a lyric at that time.</span></p>
<h2><span style="font-weight: 400;">Seed Model</span></h2>
<p><span style="font-weight: 400;">The seed model will be a simplified version of the poorly performing model from before. Instead of predicting all lyrics, it will attempt to predict a small subset of the initial lyrics. This would also allow us to create a dataset with more training examples by splitting each song into smaller samples.</span></p>
<h2><span style="font-weight: 400;">Lyrics Model</span></h2>
<p><span style="font-weight: 400;">The lyrics model will be similar to the one described in the second blog post, which is a character level RNN for generating lyrics. This will take the first few words predicted by the seed model and generate the remainder of the lyrics. Since it’s trained on the large Kaggle dataset the quality seems to be much higher than what our MIDI training has produced.</span></p>
<h2>Results</h2>
<p>As of this blog post, we are still testing various hyperparameters and waiting for models to converge.  Additional results will follow once we can examine the various output.</p></div>
    </content>
    <updated>2018-05-10T06:56:01Z</updated>
    <category term="NLP Capstone"/>
    <author>
      <name>Nicholas Ruhland</name>
    </author>
    <source>
      <id>https://mathstoc.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://mathstoc.wordpress.com/category/nlp-capstone/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://mathstoc.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://mathstoc.wordpress.com/osd.xml" rel="search" title="Mathematical Distractions" type="application/opensearchdescription+xml"/>
      <link href="https://mathstoc.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A recreational (occasionally research) blog on topics in maths or computer science - by Kuikui</subtitle>
      <title>NLP Capstone – Mathematical Distractions</title>
      <updated>2018-08-15T00:03:53Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/a2d837ecf66b</id>
    <link href="https://medium.com/@halden.lin/nlp-capstone-07-formalizing-a2d837ecf66b?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone | 07: Formalizing</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><em>previous posts: </em><a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5"><em>01</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5"><em>02</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3"><em>03</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7"><em>04</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a"><em>05</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0"><em>06</em></a></p><p>A couple of developments since I last posted:</p><ol><li>I’m now more formally receiving guidance from Kanit (Ham) Wongsuphasawat and Tongshuang (Sherry) Wu of the Interactive Data Lab. Special thanks to them for helping me thus far!</li><li><a href="https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0">Last week</a> I was uncertain as to the future direction of this project. After much deliberation and several conversations, I’ve decided to remain on the tool-based approach originally conceived. There are a couple reasons for this. First, the user study I proposed has, at least from an NLP perspective, limited novelty. What’s more, learning from the study by modifying the underlying model would require time that would likely fall outside of the quarter. Second, carrying out this study would involve significant logistical work (again, a time constraint). Finally, in beginning to formalize this visualization tool, I’ve become more excited in its potential as a useful part of a researcher’s debugging pipeline. In any case, any model modifications I may make as part of the user study would difficult without a similar tool.</li><li>As mentioned, I’ve been formalizing this tool in a React application, iterating on the exploration I’ve done with prototypes in the weeks previous. The rest of this post will describe my work here.</li></ol><h4>Starting with Text</h4><p>First things first: text brushing is critical in understanding the attention each output token, or a series of output tokens, pays to the source text. In the gif below, the left side holds the source text (along with a mini-map to prevent the need of scrolling to understand the overall distribution of attention), while the right holds the summary. Selection and brushing have been implemented, as in the prototypes of last week, albeit cleaned up.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/999/1*LKOEMB1cwvp2qXRy58_-4w.gif"/>Cleaned up selection and brushing, in addition to a minimap for long input sequences.</figure><h4><strong>Challenges with Text (Future Work):</strong></h4><ol><li>Sentence / paragraph level structure is lost via tokenizing. This is an artifact of the tokenization process performed prior to feeding text into models.</li><li>Lowercase and always-on spacing between tokens makes text difficult to read. For now, I’ve been dealing this with a few hand-coded rules. For example, removing spaces before punctuation, and capitalizing the first word after end of sentence punctuation.</li></ol><p>I’ll need to keep brainstorming to find methods for addressing these issues.</p><h4>How do we enable identification of patterns?</h4><p>While selection and brushing over the text is valuable in allowing users to understand attention for specific words or phrases, it falls short in enabling big-picture identification of patterns. Without brushing over each token and / or sentence (and memorizing coverage along the way), the closest users may get is the aggregate view (when nothing is selected) in which <strong>what</strong> is being attended to is apparent, but not <strong>how.</strong> That is to say, it is not apparent which tokens / phrases in the summary attend to which tokens / phrases in the source text. In particular, below is a growing list of goals for this visualization.</p><ol><li><strong>Enable identification of coverage</strong>. For words / phrases / sentences, where is the attention being paid, and by what?</li><li><strong>Enable identification of missing coverage</strong>. What is being unattended to that should be?</li><li><strong>Enable identification of extraction vs abstraction</strong>. Where is copying occuring? Where is true abstraction occuring?</li></ol><p>If this tool can accomplish these items, I believe it will be a good start in proving its value.</p><p>With this in mind, we need some sort of visualization to accompany the two blocks of text. As previously mentioned, heat-maps may not be the best solution.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Kd4lr3ZZmOZ6ffMdp82PJg.gif"/>Interactive heat-map, as prototyped previously.</figure><p>Lag is apparent (likely a result of the large number of elements drawn), and even ignoring this, the tiles become extremely small as the input / output sequences grow, making it difficult to pick out even high attention weights. More visual weight is needed for significant attention weights, which is difficult to accomplish as x and y space is already taken by the input / output token position.</p><p><strong>So where else can we look?</strong></p><h4>Flowmaps</h4><p>Looking back at my project proposal, I saw this visualization made by Rikters et al. (2017).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*uP_-gGiPkv6YMFYz."/>An example of a flow-map from machine translation [Rikters et al. 2017].</figure><p>I thought this might be worth exploring, so I attempted to create something similar.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*SxZUaHFYssV5JtXo."/>A flowmap displaying all edges is problematic. This doesn’t scale either.</figure><p>Unsurprisingly, there are far too many edges to display without significant overlap and occlusion. Summarization rears its head again as a challenge with its large input sequences.</p><p><strong>How do we remedy this?</strong></p><p>One observation is that high attention weights are fairly sparse (as evident by the aggregate on the source text above). What if we filtered out these insignificant weights? A naive approach is to take the top <em>k </em>percent of weights and display only those.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*I4jiiM98R88ZfMKz."/>A flowmap showing only the top 1% of weights.</figure><p>The above example is displaying only the top 1% of attention weights. Edges have both their width and opacity scaled by their weight within this 1% domain. Significant (wide) weights are clearly identifiable. Thinner lines, faint (or nearly invisible) lines can also be seen, indicating that the much more significant weights have been preserved. Four distinct ‘rays’ can be seen, seemingly corresponding to the four sentence of the summary.</p><p>Selection and brushing seemed like intuitive follow-ups for interaction to enable more detailed / accurate pattern identification.</p><p><strong>Selection</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*U8_42zGX24nN8iB7Wo-zPw.gif"/>Selection over the flowmap, both over the output nodes as well as the output text.</figure><p>Selection allows users to orient themselves in the flowmap, picking out which edges correspond to which input / output tokens.</p><p><strong>Brushing</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*1t7BRJX9g2k80B67IFQ4lw.gif"/>Brushing over the flowmap allows for windowed pattern identification.</figure><p>Brushing enables accurate pattern identification. In the example above, brushing over the distinct rays allows us to see the almost entirely extractive nature of the summary — there is a clear 1:1 mapping from input to output that is implied by the clean structure of the rays, and confirmed upon inspecting the corresponding input / output tokens for these rays.</p><h4><strong>Challenges with Flowmaps (Future Work):</strong></h4><ol><li><strong>Selecting a top k% is not ideal — it does not generalize well.</strong> In the pathological case, where attention is evenly distributed for all tokens, we lose a lot of valuable information. A potential band-aid to this is to allow users to select the percentage of weights displayed, but this may be dangerous as high percentages can crash the browser. Perhaps a more elegant solution would be to perform clustering on the weights. I’ll need to do more research here.</li><li><strong>Overlapping paths can make reading the flowmap difficult.</strong> The example shown above is fairly clean, direction flows, for the most part, in a single direction. You could imagine, however that if a summary is extremely abstractive, pulling from all over the source, there might be significant overlap in edges, decreasing legibility. A potential solution to this is edge bundling, where edges going in similar directions are pulled together to preserve pattern recognition.</li></ol><p>A good starting point for exploration here is the paper <a href="http://vis.stanford.edu/files/2011-DividedEdgeBundling-InfoVis.pdf"><em>Divided Edge Bundling for Directional Network Data</em></a> by Selassie, Heller, &amp; Heer (2011). In this, the authors describe a method for bundling, divided edge bundling, that holds characteristics I believe are important for my own visualization.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Ma6OlxvATqGNHbyu."/>Different techniques applied to a network of GitHub contributions along the west coast of the United States [Selassie, Heller, &amp; Heer 2011].</figure><p>In the coming weeks I hope to dive into these techniques and explore their impact on the flowmap I’ve developed thus far.</p><h4>In Summary</h4><p>Still a lot of work to do! Here are my goals for the next week.</p><ol><li>Improve flowmap visualization.</li><li>Find examples that cover the problem space (e.g. low coverage, abstraction, extraction).</li><li>Keep brainstorming.</li><li>Optimize code.</li></ol><p>Things are getting interesting!</p><h4>References</h4><ol><li><a href="https://ufal.mff.cuni.cz/pbml/109/art-rikters-fishel-bojar.pdf">Rikters, Matīss, Mark Fishel, and Ondřej Bojar. “Visualizing neural machine translation attention and confidence.” <em>The Prague Bulletin of Mathematical Linguistics</em> 109.1 (2017): 39–50.</a></li><li><a href="http://vis.stanford.edu/files/2011-DividedEdgeBundling-InfoVis.pdf">Selassie, David et al. “Divided Edge Bundling for Directional Network Data.” <em>IEEE Transactions on Visualization and Computer Graphics</em> 17 (2011): 2354–2363.</a></li></ol><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a2d837ecf66b" width="1"/></div>
    </content>
    <updated>2018-05-09T06:48:30Z</updated>
    <category term="machine-learning"/>
    <category term="computer-science"/>
    <category term="nlp"/>
    <category term="data-visualization"/>
    <category term="visualization"/>
    <author>
      <name>Halden Lin</name>
    </author>
    <source>
      <id>https://medium.com/@halden.lin?source=rss-2759d54493c0------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*Hzu2ZqgloT0I1F6Kwg8OPA.jpeg</logo>
      <link href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@halden.lin" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Halden Lin on Medium</subtitle>
      <title>Stories by Halden Lin on Medium</title>
      <updated>2018-08-15T00:02:43Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/6f773ae418d0</id>
    <link href="https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone | 06: Uncertainty</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>previous posts: <a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5">01</a> <a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5">02</a> <a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3">03</a> <a href="https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7">04</a> <a href="https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a">05</a></p><p>I’ve begun to realize I may not be getting as much out of the project I chose I had hoped. My initial motivation for my project was a hope of expanding my knowledge and developing insights on the NLP front by leveraging the familiarity of Visualization. While I am certainly learning a lot by reading papers on Attention and Neural Networks as a whole (especially through my in-class paper presentation), I feel the work I am doing in building a tool for visualizing and debugging attention models may not be providing me the space to explore NLP that I had hoped for. While the tool will certainly <strong>enable </strong>exploration, my concern is that this exploration will not occur until after the tool is completed at the end of the quarter.</p><p>The good news is that there have been two recent developments that, while increasing my uncertainty, offer potential for greater depth in exploration along the NLP front.</p><h4>1. Potential Pivot</h4><p>I voiced these concerns with Prof. Choi this past week and was given a good amount of valuable advice. Per her suggestion, the beginning of my last cycle began with three tasks.</p><ol><li>Read <a href="https://dl.acm.org/citation.cfm?id=2470718"><em>The Efficacy of Human Post-editing for Language Translation</em></a><em>, </em>authored by<em> </em>Spence Green, Jeff Heer, and Christopher Manning. This paper is unique in that it presents the value of Visualization and HCI within Natural Language Processing, but not as a window into a model. Rather, the authors explore a specific task integral to the Language Translation pipeline and present suggestions for future work in improving Language Translation.</li><li>Do in-depth human error-analysis of existing summarization models. I used examples from See et al.’s paper <em>Get To The Point: Summarization with Pointer-Generator Networks </em>(2017).This was helpful gaining a better intuition as to the problem space and the challenges currently posed by machine summarization.</li><li>Think about how summarization as a task, whether that be the development of models, the model’s task itself, or end-user tasks that use the model, can be re-framed in order to leverage Visualization. This was especially time consuming, as it was difficult for me, but it helped immensely in taking a step back to understand the purpose of these models. This, in turn, helped me understand how my work can fit into this purpose.</li></ol><p>The next few days consisted largely of brainstorming pivots for my project. The most promising direction that came out of these sessions is very briefly outlined below.</p><p><strong>Assisted Cognitive Document Abstraction</strong></p><p>Machine-generated document summaries, even the state-of-the-art, are infrequently used in practice because their summaries are quite poor. Perhaps we can leverage existing models to, rather than produce definite summaries which may be error-prone or difficult to understand, create visualizations over the source text in order to assist humans in comprehension and abstraction.</p><p>For example, instead of treating attention weights as input for an output of text, as we do in summarization models, we can view them as output for human interpretation. Aggregate attention distributions (in summarization) highlight areas of the input text that are salient for the summary produced. Note that this is potentially more valuable than highlighting extractive summaries in the text because attention could potentially point towards different areas of the text that relate to a summary sequence. In this way, generation of summaries becomes a proxy task for creating salient highlights for text. We could then use this as a starting point from which ‘related’ sections in an article may be highlighted for users upon interaction (e.g. mousing over an attended-to sequence).</p><p>The hope is that these visualizations will increase the speed (over no summarization) or accuracy (over machine summarization) at which readers can abstract / understand key ideas in a document.</p><p>Most excitingly, with this re-framing of the task for these models, from sequence output to highlighting, perhaps the models can be modified by adding or removing constraints and mechanisms in order to improve performance for this new task.</p><p>Upon presenting this idea (in longer form) to Prof. Choi, I was encouraged to (1) think more about weaknesses of removing summaries altogether and (2) push for more novelty in the approach — is there any meaningful insight about attention models or summarization as a task that can be gleamed from this pivot, and if not, how can I work towards that. While I do not yet have answers to these concerns, the next development may result in a few.</p><h4>2. Related work, here at the Allen School</h4><p>It was just recently brought to my attention that a Tongshuang (Sherry) Wu, a PhD student in the Interactive Data Lab (in which I am currently working), is also working on visualizations for understanding attention models in NLP. As a part of her project, she and a few of her peers have developed a preliminary visualization tool for an attentive QA model (on the SQuAD dataset).She and my mentor, Kanit (Ham) Wongsuphasawat (whom I have been bouncing ideas off recently), have kindly offered to meet and discuss her work and insights on the problem space. Perhaps collaboration is a possibility — this is exciting! In any case, I suspect talking with Sherry and Ham will provide me the insight and guidance to make a decision on the direction of my project.</p><h4><strong>Future Work</strong></h4><p>I hope to make another blog post in the coming few days as I iron out a future direction. Before this, however, future work is unclear. Until next time!</p><h4>In the meanwhile (supplementary material)</h4><p>I’ve also been playing around with my visualization prototypes, even as I am uncertain as to whether or not they will be relevant to my project after this week. Here’s what I’ve discovered and implemented in that time.</p><ol><li>Interactive heat-maps likely won’t work.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_bVKvDPn6jBADKwFU9VG3g.gif"/>Interactive heat-maps result in a large degree of lag between input and visual update. This is likely due to the extremely large size of the attention matrix in summarization (24,000 individual squares in the heat-map).</figure><p>This is unfortunate, but browser limitations are limitations that must be worked around.</p><p>2. Selection over output text.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/999/1*KfMQd6YnDzdH9dZOyjVEIw.gif"/>Mousing over words in the summary results in a view of the attention distribution over the article for that decoder time-step.</figure><p>This is similar to the interactive visualizations presented by See et al. in their <a href="http://www.abigailsee.com/2017/04/16/taming-rnns-for-better-summarization.html">blogpost</a>.</p><p>3. Brushing over output text.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*nwGIF3VgNDeuFxRml8gGzg.gif"/>Brushing over the summary results in an aggregate attention distribution (i.e. coverage) over the article for the selected decoder time-steps.</figure><p>This is an interaction technique I have yet to see in work involving attention analysis, so this is exciting! It looks to be somewhat useful in identifying sections of input text that are salient to an <strong>idea</strong> rather than a <strong>single word</strong> in the output text.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6f773ae418d0" width="1"/></div>
    </content>
    <updated>2018-05-02T06:59:16Z</updated>
    <category term="visualization"/>
    <category term="data-visualization"/>
    <category term="nlp"/>
    <category term="machine-learning"/>
    <category term="computer-science"/>
    <author>
      <name>Halden Lin</name>
    </author>
    <source>
      <id>https://medium.com/@halden.lin?source=rss-2759d54493c0------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*Hzu2ZqgloT0I1F6Kwg8OPA.jpeg</logo>
      <link href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@halden.lin" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Halden Lin on Medium</subtitle>
      <title>Stories by Halden Lin on Medium</title>
      <updated>2018-08-15T00:02:58Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/306dca636d3a</id>
    <link href="https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone | 05: Experimenting</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><em>previous posts: </em><a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5"><em>01</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5\"><em>02</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3"><em>03</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7"><em>04</em></a></p><p>Hi! Here’s what I’ve been up to in the past week.</p><h4>Progress on the TensorBoard Plugin</h4><p>Real data collection and the backend are functioning!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*l6M8uMcswVoaEtL0_HGt0w.png"/>Architecture of the Attention Plugin.</figure><p>At this point last week, I had implemented the nodes in green above. These were the operators / functions required to produce Summary protobufs that are in turn saved to disk.</p><p>This week, I completed a number of tasks to produce a bare-bones functioning plugin (sans visualizations).</p><p>First, I modified the source code for <a href="https://github.com/abisee/pointer-generator">See et al.’s (2017) attentional models</a> to use the Attention Plugin API to save input text, output text, and attention distributions during evaluation.</p><p>Next, I implemented the Attention Plugin’s back-end, which is used to fulfill requests made by the front-end. This service currently offers two services:</p><ol><li>tags This route returns all tags associated for each run in the log. This should include 3 tags for each run: one for each of the input, output, and attention tensors.</li><li>attention This route returns a list values associated with the given tag (including time and step stamps). This can be used by the front-end to acquire each of the input, output, and attention lists (converted from tensors) by passing the corresponding tag (retrieved using the tags route).</li></ol><p>Finally, as a proof of concept, I modified the front-end provided in the <a href="https://github.com/tensorflow/tensorboard-plugin-example">TensorBoard Plugin Example</a> to consume this back-end, showing it is able to retrieve summaries. Now we just need some visualizations to consume the data!</p><h4>Visualization Prototyping Begins</h4><p>While data collection and back-end development has been wrapping up, I’ve begun to prototype static visualizations for the plugin. To do this, I used data produced by <a href="https://github.com/abisee/pointer-generator">See et al.’s (2017) pre-trained attentional models</a> (produced only at decode time without the Attention Plugin). Through this process, I hope to gain two things in particular.</p><ol><li>A idea of what will/won’t work as visualizations for summarization tasks.</li><li><strong>A better understanding of the behavior of attentive models</strong>, and through that a better idea of how static and/or interactive visualizations can further interpretability and understanding.</li></ol><p>The first idea I decided to pursue was that of a <strong>condensed heat-map</strong>. You may recall the conventional heat-map used for attention visualizations described in <a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5">my first blog post</a>.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/612/1*_sq2Vy_Py7hEXp2tWBBXxg.png"/>Rikters et al. (2017). A heat-map with relatively large cells, allowing for display of text along the axes.</figure><p>The issues I noted with this visualization pattern are as follows:</p><ol><li>It is difficult to fit the words (as seen above) on the x-axis, harming readability.</li><li>This does not scale well with large input or output (e.g. summarization)</li><li>We do not read single-tokens at a time (i.e. y-axis), and input and output are generally not in this format either.</li></ol><p>To address the point (2), scalability, I decided to try producing a heat-map with no text labels, and thus each cell could be as small as a single pixel.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WOlVYgmeZ0DmutTZkDXn2g.png"/>A prototype of a condensed heat-map, where x-axis represents input and y-axis represents output.</figure><p>The color scale is a discrete scale, where each step is determined by the quantiles of the weight distribution. The x-axis represents the input text, and the y-axis represents the output text, with each cell representing the amount of attention paid for that pair (output paid to input). The good news here is that the attention distribution is relatively easy to understand at a quick glance. The downside is that cells that are not part of a larger trend (you may notice a lone red spot near the top of the heat-map, approximately a quarter of the way through the x-axis) are harder to make out, as the cells are so small. Further, the distribution is contextless — we don’t know the structure of the input text or what words these high weights are associated with. In the example above, we understand that the model focused primarily on the beginning of the article, but we can’t tell whether that is good or bad without seeing the text.</p><p>To remedy this, I decided to also display the input text, with the input text highlighted according to the maximum of the weights it received. This also solves concerns (1) and (3) for the conventional heat-map.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dJXS9s_391dACPuUwAgPmA.png"/>The input text corresponding to the heat-map above, where each token is highlighted according to its max attention weight received.</figure><p>By putting these two together (along with the output text for reference), we can gain a better understanding of how the model arrived at its summary. A viewer can now map the attention distribution shown in the heat-map to text in the input sequence by looking for patches of similar color intensity.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dMqdcl01Za5U4nYrXpye6g.png"/>A prototype static visualization including both heat-map and highlighted text.</figure><p>To get a better sense of how this visualization pattern would play out, I built a light web-page that allows users to cycle through different input / output examples. The gif below shows several of these.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*_ACE44hvUSrwfE3F04gslg.gif"/>The described visualization pattern over several input / output sequences.</figure><p>More exploration (inside and outside of this pattern) will need to occur, but this seems promising!</p><h4>What’s Next</h4><p>Lots to get done this next week. Here’s what’s in my plan:</p><ol><li>Continue working on data collection and cleaning up the TensorBoard plug-in. Move beyond the proof-of-concept front-end and show that meaningful visualizations (perhaps extremely basic ones) can be generated using the plugin back-end as a data source.</li><li>Read more into the model provided by See et al. (2017), as well as related work, to gain a better understanding of the architecture and function/behavior of attention. A closer study of the works cited in my <a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5">second blog post</a> will be a good starting point. The better I understand this mechanism the more equipped I’ll be to create meaningful visualizations.</li><li>Continue prototyping static visualizations, move on to interactive visualizations. Acquire feedback from peers for both.</li></ol><p>Thanks for reading!</p><h4>Works Cited</h4><ul><li><a href="https://arxiv.org/pdf/1704.04368.pdf">See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” <em>ACL</em> (2017).</a></li><li><a href="https://ufal.mff.cuni.cz/pbml/109/art-rikters-fishel-bojar.pdf">Rikters, Matīss, Mark Fishel, and Ondřej Bojar. “Visualizing neural machine translation attention and confidence.” <em>The Prague Bulletin of Mathematical Linguistics</em> 109.1 (2017): 39–50.</a></li></ul><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=306dca636d3a" width="1"/></div>
    </content>
    <updated>2018-04-25T06:48:23Z</updated>
    <category term="visualization"/>
    <category term="machine-learning"/>
    <category term="data-visualization"/>
    <category term="nlp"/>
    <category term="computer-science"/>
    <author>
      <name>Halden Lin</name>
    </author>
    <source>
      <id>https://medium.com/@halden.lin?source=rss-2759d54493c0------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*Hzu2ZqgloT0I1F6Kwg8OPA.jpeg</logo>
      <link href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@halden.lin" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Halden Lin on Medium</subtitle>
      <title>Stories by Halden Lin on Medium</title>
      <updated>2018-08-15T00:02:53Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://mathstoc.wordpress.com/?p=323</id>
    <link href="https://mathstoc.wordpress.com/2018/04/25/nlp-capstone-post-5-a-new-hope/" rel="alternate" type="text/html"/>
    <title>NLP Capstone Post #5: A New Hope</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Dataset Improvements Last time, on Music NLP. We ran into many midi data parsing issues. Since then, we have discovered a new dataset called the Lakh MIDI Dataset (http://colinraffel.com/projects/lmd/) that comes with reasonably well-formed midi files. Using the “Clean MIDI Subset”, we found thousands of midi files with their associated song names and songwriters. From … <a class="more-link" href="https://mathstoc.wordpress.com/2018/04/25/nlp-capstone-post-5-a-new-hope/">Continue reading <span class="screen-reader-text">NLP Capstone Post #5: A New Hope</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h1><span style="font-weight: 400;">Dataset Improvements</span></h1>
<p><i><span style="font-weight: 400;">Last time, on Music NLP.</span></i><span style="font-weight: 400;"> We ran into many midi data parsing issues. Since then, we have discovered a new dataset called the Lakh MIDI Dataset (</span><a href="http://colinraffel.com/projects/lmd/"><span style="font-weight: 400;">http://colinraffel.com/projects/lmd/</span></a><span style="font-weight: 400;">) that comes with reasonably well-formed midi files. Using the “Clean MIDI Subset”, we found thousands of midi files with their associated song names and songwriters. From these midi files, we extracted all with nonempty “lyric” fields when parsed via the pretty_midi package (which, incidentally, is also developed by Colin Raffel). After this step, we were left with ~1200 midi files that contain lyrics.</span></p>
<p><span style="font-weight: 400;">We currently clean the lyrical content by removing all unusual symbols and setting all characters to lowercase. We leave all lyrical tokens as is, which typically means syllable. Due to the inconsistent quality of the MIDI annotations, many songs are tokenized instead to characters, words, or even sentences. We will explore other methods for processing data if this is not sufficient for our results.</span></p>
<p><span style="font-weight: 400;">It is unfortunate we did not find this dataset sooner, because most of our challenges up to this point have been dealing with the poor quality of the gathered data.</span></p>
<h1><span style="font-weight: 400;">Alignment</span></h1>
<p><span style="font-weight: 400;">For our task of producing karaoke style output, there are two main tasks we have to solve. The first task is the generation of plausible lyrics, and the second is to align the lyrics to the proper time along the musical data. The alignment task has been studied extensively, but specifically aligning lyrical content to MIDI has not been covered in literature we have found. The most common alignment task is lyrics to audio data, as opposed to MIDI. The other common task is to align audio data to the notes defined in a MIDI file. In [1], they show a method that takes a MIDI file with annotated lyrics and uses this to align the lyrics to the raw audio. Unfortunately this is not our task, because we are trying to generate the annotated MIDI.</span></p>
<p><span style="font-weight: 400;">This week, we have decided to ignore the alignment task and focus primarily on making a reasonable lyrical model. We will return to alignment next week.</span></p>
<p><span style="font-weight: 400;">The next step was to align the lyrics with pianoroll. Fortunately, well-formed midi data parsed into PrettyMIDI objects come with a “get_piano_roll” function that takes as input a list of “times” which correspond to where in time pretty_midi will attempt to sample the music. As each syllable in the lyrics comes with a start time for when the singer enunciates it, we can pass in these start times to produce pianoroll that is aligned (up to small error) with the lyrics.</span></p>
<p><span style="font-weight: 400;">For some implementation reasons that are difficult to explain in English, it is possible for “get_piano_roll” to produce NaN entries, which we have replaced with zeros. Due to this and the potential for other such problems, we have forked the pretty_midi package and will be able to modify the code for our needs. For example, as pointed out in [2], “in a given MIDI file there is no reliable way of determining which instrument is a transcription of the vocals in a song”. As such, there are many choices for how to do alignment; pretty_midi has implemented just one. It is an interesting task to see how different alignment methods help or hurt our models.</span></p>
<h1><span style="font-weight: 400;">Lyric prediction</span></h1>
<p><span style="font-weight: 400;">Now that we have aligned pianoroll to lyrics data, we can begin engineering the model. Last time, we used an LSTM to generate lyrics given starting characters. Here, we will again use LSTMs, but instead, work at the syllable level and take as input the pianoroll of a song. As each column of a pianoroll is a time slice, each input vector to the LSTM is a single time slice. Each time slice is a 128-dimensional vector, with each entry representing the activation of an instrument; there are 128 midi recognized “instruments”.</span></p>
<p> </p>
<p><span style="font-weight: 400;">All that is left is to play with the architecture. </span></p>
<p><img alt="RNN model" class="alignnone size-full wp-image-322" src="https://mathstoc.files.wordpress.com/2018/04/rnn-model1.png?w=676"/></p>
<p><span style="font-weight: 400;">At the moment, our pipeline looks like what is shown in the diagram. At each iteration, we take a song, extract the lyrics and the corresponding pianoroll data. We then feed each time slice of the pianoroll data through an encoder unit, then through an LSTM unit, then through a decoder unit, and finally through a softmax to produce the prediction. Our loss is the negative log-likelihood (negative logarithm of the RNN softmax probability of the true syllable).</span></p>
<p><span style="font-weight: 400;">We will compare our final model to this baseline with respect to the loss on a held-out validation set. We will also experiment with loss functions other than cross entropy to see how it affects the actual lyrical output.</span></p>
<h1><span style="font-weight: 400;">Model results</span></h1>
<p><span style="font-weight: 400;">We have so far only trained our model for a single iteration over the training set. For an empirical evaluation on the current model quality, we ran a single MIDI through the input and computed the argmax word for each output. This produced a result in which every predicted lyric was an empty message, which is the most common string in the training set. We will explore methods to handle this class imbalance as our next task.</span></p>
<h1>References</h1>
<p><span style="font-weight: 400;">[1] Müller, Meinard &amp; Kurth, Frank &amp; Damm, David &amp; Fremerey, Christian &amp; Clausen, Michael. (2007). Lyrics-Based Audio Retrieval and Multimodal Navigation in Music Collections. 4675. 112-123. 10.1007/978-3-540-74851-9_10.</span><br/>
<span style="font-weight: 400;">[2] </span><span style="font-weight: 400;">Raffel, Colin and Daniel P. W. Ellis. “Extracting Ground-Truth Information from MIDI Files: A MIDIfesto.” </span><i><span style="font-weight: 400;">ISMIR</span></i><span style="font-weight: 400;"> (2016). </span><span style="font-weight: 400;"> </span></p></div>
    </content>
    <updated>2018-04-25T04:44:57Z</updated>
    <category term="NLP Capstone"/>
    <author>
      <name>Nicholas Ruhland</name>
    </author>
    <source>
      <id>https://mathstoc.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://mathstoc.wordpress.com/category/nlp-capstone/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://mathstoc.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://mathstoc.wordpress.com/osd.xml" rel="search" title="Mathematical Distractions" type="application/opensearchdescription+xml"/>
      <link href="https://mathstoc.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A recreational (occasionally research) blog on topics in maths or computer science - by Kuikui</subtitle>
      <title>NLP Capstone – Mathematical Distractions</title>
      <updated>2018-08-15T00:03:48Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://mathstoc.wordpress.com/?p=314</id>
    <link href="https://mathstoc.wordpress.com/2018/04/18/nlp-capstone-post-3-baseline-and-midi-frustration/" rel="alternate" type="text/html"/>
    <title>NLP Capstone Post #4: Baseline and MIDI Frustration</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Baseline model Our baseline approach is taken from Daniil Pakhomov’s excellent blog post[1]. In this post, two separate RNNs are trained as generators: one for lyrical content and one for music content (in piano roll format). We will begin by using his trained lyrical model, and attempt to do conditional sampled character generation given a … <a class="more-link" href="https://mathstoc.wordpress.com/2018/04/18/nlp-capstone-post-3-baseline-and-midi-frustration/">Continue reading <span class="screen-reader-text">NLP Capstone Post #4: Baseline and MIDI Frustration</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h1><b>Baseline model</b></h1>
<p><span style="font-weight: 400;">Our baseline approach is taken from Daniil Pakhomov’s excellent blog post[1]. In this post, two separate RNNs are trained as generators: one for lyrical content and one for music content (in piano roll format). We will begin by using his trained lyrical model, and attempt to do conditional sampled character generation given a starting sequence of characters. We loaded the already trained models from the blog post and generated lyrics according to the style of a given songwriter and with a given seed word. The lyrics are generated via a character-level LSTM and generates the next character conditioned on the preceding characters and choice of songwriter. The model is trained on a corpus of song lyrics, where naturally the “correct” character to generate is the next character in the lyrics. Essentially the same mechanism is applied to the musical note generation.</span></p>
<p><span style="font-weight: 400;">The characters are encoded as a one-hot vector over all letters in the English alphabet plus space, comma, etc. Piano rolls already come in an encoding amenable to feeding into RNNs, modulo additional zero padding to ensure every time slice of every piano role has the same dimension. In particular, at each time step (discretized in an appropriately fine-grained way), we have an indicator 0-1 vector on which notes are currently activated.</span></p>
<p><span style="font-weight: 400;">Here is a song generated in the style of “Queen” with the starting seed sequence of characters “Music”:</span></p>
<blockquote>
<p style="text-align: center;"><i>Music savor valerite – yah  </i></p>
<p style="text-align: center;"><i>Imabribot, bind me – I – well  </i></p>
<p style="text-align: center;"><i>All going down to L</i></p>
<p style="text-align: center;"><i>At the eyes of the universe  </i></p>
<p style="text-align: center;"><i>Agree, five to the Slim  </i></p>
<p style="text-align: center;"><i>I just want to convincide  </i></p>
<p style="text-align: center;"><i>We wash stars and quiet Ich  </i></p>
<p style="text-align: center;"><i>You had a dirty old baby  </i></p>
<p style="text-align: center;"><i>We won’t  </i></p>
<p style="text-align: center;"><i>We does nothing no one ezy? follohin?  </i></p>
<p style="text-align: center;"><i>Sometimes we get down and ooh  </i></p>
<p style="text-align: center;"><i>Nothing do you see all night  </i></p>
<p style="text-align: center;"><i>  </i></p>
<p style="text-align: center;"><i>This is my pries  </i></p>
<p style="text-align: center;"><i>  </i></p>
<p style="text-align: center;"><i>Joyful the world  </i></p>
<p style="text-align: center;"><i>Does their beams  </i></p>
<p style="text-align: center;"><i>Surgeon makes the scule la beat  </i></p>
<p style="text-align: center;"><i>Walking out on my pocket ride  </i></p>
<p style="text-align: center;"><i>My faulty power  </i></p>
<p style="text-align: center;"><i>I wear from the ston</i></p>
</blockquote>
<p><span style="font-weight: 400;">Eventually, since we are actually interested in converting the musical information into plausible lyrics, we will need to modify this baseline in the natural way to take as input time slices of the musical instrumentation in piano roll format and predict characters (or syllables) that are to be enunciated simultaneously with the played notes. In this manner, the lyrics come already aligned in a natural way, and the words can be extracted by compressing the letters occurring between spaces.</span></p>
<h1><b>Dataset parsing</b></h1>
<p><span style="font-weight: 400;">The MIDI format has an unfortunate number of unexpected caveats. We have spent a majority of our time so far cleaning the data and attempting to use it in existing Python libraries that handle MIDI. A brief description of MIDI[2] covers some of the challenges:</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">MIDI is made up of a series of messages, such as notes, instruments, and tempo changes. Additional metadata messages exist called meta messages, which can contain text content such as the song title (and lyrics!). In our dataset, lyrics are provided either as “text” messages or as “lyrics” messages.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Messages are grouped into different tracks, often representing separate instruments. Metadata sometimes is located in its own track, and lyrics are sometimes found in a different track from the rest of the metadata.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Durations in the MIDI format are specified as a delta-time relative to the most recent frame. Delta times are in a unit called a tick. Ticks are defined in the file header as a division of the quarter note. The header also defines the number of ticks per frame, which is what the deltas are relative to. Beats per minute (bpm) messages adjust the speed of playback throughout the song.</span></li>
</ul>
<p><span style="font-weight: 400;">The most promising library so far is PrettyMIDI[3], which handles most of the unexpected behavior of the basic MIDI format. This library wraps MIDI messages into structured python objects, and provides a conversion from MIDI into piano roll format. Piano roll in this case is a numpy array of shape (num_notes, num_frames). This allows us to input the musical data directly into an RNN. The units are also converted into absolute seconds, as opposed to relative durations. PrettyMIDI can additionally handle embedded lyrics, but this has proven to be a challenge due to the variety of annotation styles in our dataset. About 200 of our 900 files have parsed lyric data properly, so continuing to clean our data is a high priority.</span></p>
<h1><strong>U</strong>pd<strong>ate</strong></h1>
<p><span style="font-weight: 400;">Unfortunately, we have found the Kara1k dataset[4] to be inapplicable to our project, as the raw sequence of musical notes and lyrical content are not provided, only metadata that the dataset developers have extracted.</span></p>
<h1>References</h1>
<p><span style="font-weight: 400;">[1] </span><a href="http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/"><span style="font-weight: 400;">http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/</span></a></p>
<p><span style="font-weight: 400;">[2] </span><a href="http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html"><span style="font-weight: 400;">http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html</span></a></p>
<p><span style="font-weight: 400;">[3] </span><a href="http://craffel.github.io/pretty-midi/"><span style="font-weight: 400;">http://craffel.github.io/pretty-midi/</span></a></p>
<p><span style="font-weight: 400;">[4] </span><a href="http://yannbayle.fr/karamir/kara1k.php"><span style="font-weight: 400;">http://yannbayle.fr/karamir/kara1k.php</span></a></p></div>
    </content>
    <updated>2018-04-18T04:58:56Z</updated>
    <category term="NLP Capstone"/>
    <author>
      <name>Nicholas Ruhland</name>
    </author>
    <source>
      <id>https://mathstoc.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://mathstoc.wordpress.com/category/nlp-capstone/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://mathstoc.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://mathstoc.wordpress.com/osd.xml" rel="search" title="Mathematical Distractions" type="application/opensearchdescription+xml"/>
      <link href="https://mathstoc.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A recreational (occasionally research) blog on topics in maths or computer science - by Kuikui</subtitle>
      <title>NLP Capstone – Mathematical Distractions</title>
      <updated>2018-08-15T00:03:39Z</updated>
    </source>
  </entry>

  <entry>
    <id>https://medium.com/p/96fb908765f5</id>
    <link href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
    <title>NLP Capstone | 02: Getting Started</title>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p><a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5">previous post</a></p><p>Alright, it’s been only 2 days since my last entry, so this will be a relatively short post. The direction I proposed in <strong>Option 1 </strong>of that post was towards a more robust, interpretable, and informative visualization of attention, particularly in the context of text summarization. A quick recap:</p><blockquote>Perhaps interaction can be used to create a more insightful and interpretable visualization framework for understanding attention. For example, text heat-maps are already used widely to visualize sentiment analysis.</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lsgeuBXGGBog4YkuQNgJVw.png"/>Lin et al. (2017) [6]. Visualization of sentiment analysis on a token-by-token basis.</figure><blockquote>In a static context, using this method for attention would require repeat of the same input sequence for each word in the output sequence. Using interaction, however, a model creator could brush over single or sequences of words in the output sequence to view corresponding soft-alignment in the input sequence. Aggregate visualizations could be shown to supplement this view (either aggregates over a particular input / output sequence, or aggregates over all input / output sequences).</blockquote><p>I’m currently working on laying out the groundwork for such a project. Task 1: implement a model. Without one, there’s no data to visualize!</p><p>With that in mind, here’s what I’ve been up to:</p><h4>Finding a Text Summarization Dataset</h4><p>A quick survey of recent research papers [1–5] on text summarization points, as well as online forums, points to three commonly used datasets.</p><ol><li><a href="https://cs.nyu.edu/~kcho/DMQA/">CNN/Daily Mail Corpus</a>. A collection of articles and their bullet point summaries, with each bullet split for Q/A purposes. <a href="https://github.com/abisee/cnn-dailymail">A script</a> [1] can be ran over the original dataset to restore the original bullet point summaries, to be used as a summarization corpus.</li><li><a href="https://www-nlpir.nist.gov/projects/duc/data.html">DUC Corpus</a>. In particular, DUC 2003 and DUC 2004. These contain a collection of documents, each accompanied by a short (~10 word) summary. There is also a longer summary for each cluster of documents.</li><li><a href="https://catalog.ldc.upenn.edu/ldc2003t05">Gigaword Corpus</a>. An annotated collection of millions of documents. The summarization task here would be to predict the headline of each [5]</li></ol><p>The accessibility of the <strong>CNN/Daily Mail Corpus</strong> (a process is required for the other two), in addition to the prevalence of projects that used it as a primary dataset [1, 2, 4], made it the most attractive option. The relatively longer summaries (~4 bullet points as opposed a short blurb in the other two datasets) also lends itself conveniently to the case of an interactive visualization with multi-token selection (e.g. select a whole bullet point and see where it attended). For a baseline, this will be my dataset!</p><h4>Identifying a Baseline Model</h4><p>See et al. (2017) [1] lay out a seq2seq attentional model as their baseline (a bidirectional LSTM). I’ll be using this as a baseline model with which to obtain data.</p><h4>Getting Some Code Up</h4><p>I’ll be using <a href="http://pytorch.org/">PyTorch</a> and the <a href="http://allennlp.org/">AllenNLP</a> toolkit [7] to implement my NN models. These are both ready to go on both my machine and Azure. I’m currently in the process of writing a DatasetReader for the dataset described above.</p><h3>Next Steps</h3><ul><li>Finish writing the DatasetReader for the CNN/Daily Mail Corpus.</li><li>Begin work on a baseline seq2seq attentional model, as described in <strong>Identifying a Baseline Model</strong></li></ul><h4>Works Cited</h4><p>[1] <a href="https://arxiv.org/pdf/1704.04368.pdf">See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” <em>ACL</em> (2017).</a></p><p>[2] <a href="https://arxiv.org/pdf/1712.06100.pdf">Hasselqvist, Johan et al. “Query-Based Abstractive Summarization Using Neural Networks.” <em>CoRR</em> abs/1712.06100 (2017): n. pag.</a></p><p>[3] <a href="https://arxiv.org/pdf/1602.06023.pdf">Nallapati, Ramesh et al. “Abstractive Text Summarization using Sequence-to-sequence RNNs and Beyond.” <em>CoNLL</em> (2016).</a></p><p>[4] <a href="https://arxiv.org/pdf/1705.04304.pdf">Paulus, Romain et al. “A Deep Reinforced Model for Abstractive Summarization.” <em>CoRR</em> abs/1705.04304 (2017): n. pag.</a></p><p>[5] <a href="https://arxiv.org/pdf/1509.00685.pdf">Rush, Alexander M. et al. “A Neural Attention Model for Abstractive Sentence Summarization.” <em>EMNLP</em> (2015).</a></p><p>[6] <a href="https://arxiv.org/pdf/1703.03130.pdf">Lin, Zhouhan, <em>et al.</em>, “A structured self-attentive sentence embedding.”<em>arXiv preprint arXiv:1703.03130</em> (2017).</a></p><p>[7] <a href="https://pdfs.semanticscholar.org/a550/2187140cdd98d76ae711973dbcdaf1fef46d.pdf?_ga=2.150901366.1370831839.1522970228-1363309632.1522194596">Gardner, Matt et al. “AllenNLP: A Deep Semantic Natural Language Processing Platform.” (2017).</a></p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=96fb908765f5" width="1"/></div>
    </content>
    <updated>2018-04-06T06:53:32Z</updated>
    <category term="computer-science"/>
    <category term="visualization"/>
    <category term="machine-learning"/>
    <category term="data-visualization"/>
    <category term="nlp"/>
    <author>
      <name>Halden Lin</name>
    </author>
    <source>
      <id>https://medium.com/@halden.lin?source=rss-2759d54493c0------2</id>
      <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*Hzu2ZqgloT0I1F6Kwg8OPA.jpeg</logo>
      <link href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" rel="alternate" type="text/html"/>
      <link href="https://medium.com/feed/@halden.lin" rel="self" type="application/rss+xml"/>
      <link href="http://medium.superfeedr.com" rel="hub" type="text/html"/>
      <subtitle>Stories by Halden Lin on Medium</subtitle>
      <title>Stories by Halden Lin on Medium</title>
      <updated>2018-08-15T00:02:20Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://mathstoc.wordpress.com/?p=304</id>
    <link href="https://mathstoc.wordpress.com/2018/04/06/milestone-2-music-as-a-natural-language-task/" rel="alternate" type="text/html"/>
    <title>Milestone #2: Music as a Natural Language Task</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Framing the problem The focus of Natural Language Processing relies on patterns in the structure of language and models that find ways to encode the complexities of these structures. Many forms of music also have large amounts of structure which could potentially be discovered using similar models as a standard natural language. Music datasets for … <a class="more-link" href="https://mathstoc.wordpress.com/2018/04/06/milestone-2-music-as-a-natural-language-task/">Continue reading <span class="screen-reader-text">Milestone #2: Music as a Natural Language Task</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><h3>Framing the problem</h3>
<p>The focus of Natural Language Processing relies on patterns in the structure of language and models that find ways to encode the complexities of these structures. Many forms of music also have large amounts of structure which could potentially be discovered using similar models as a standard natural language.</p>
<p>Music datasets for machine learning purposes have recently become available through projects like MusicNet in 2016 [1]. This music is primarily classical, and provided as both audio and MIDI.</p>
<h3>Project ideas</h3>
<p>For our project we are interested in music with lyrical content – both for the potential to create a creative demo and for the interest of making this a language task. The current direction we are most interested in is the generation of lyrics for a song, given its nonlyrical content. This will be broken up into subtasks depending on the feasible scale of the project. Not all of the following points will necessarily be parts of our project, but we will use them as as starting point as we see the success of our models.</p>
<ul>
<li>Creating a machine learning model for MIDI music</li>
<li>Translating MIDI into specific artists or styles</li>
<li>Creating models for the lyrical content of specific artists or styles of music</li>
<li>Generating lyrics given an artist or style</li>
<li>Seq2seq conversion of MIDI into lyrical content</li>
<li>GANs for either side of the conversion – MIDI encoding or lyrical generating</li>
</ul>
<h3>Using MIDIs in RNNs</h3>
<p>Work by Pakhomov [2] has already used RNNs to create models for lyrics. In his <a href="http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/">blog post</a> he additionally discusses a method for forming any MIDI into piano roll format. This is essentially a matrix where each column represents a different time step, and each row represents a different note. Having a 1 corresponds to that note sounding at that time. The individual time vectors can be used as the inputs to an RNN at each time step to create a model representing the various songs.</p>
<p>One possible data source for our project is karaoke data available from various sources online. If available in large enough quantities this could be extremely convenient because it already contains many pairings of MIDI music to their lyrics.</p>
<h3>Azure</h3>
<p>We intend to use PyTorch to train our models, and have begun setting up an instance on Microsoft Azure.</p>
<h3>Relevant work</h3>
<p>[1] <a href="https://homes.cs.washington.edu/~thickstn/musicnet.html" rel="nofollow">https://homes.cs.washington.edu/~thickstn/musicnet.html</a></p>
<p>[2] <a href="http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/" rel="nofollow">http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/</a></p>
<p>[3] Dong, Hao-Wen. 2017. MuseGAN: Multi-track Sequential Generative Adversarial Networks for Symbolic Music Generation and Accompaniment. <a href="https://arxiv.org/pdf/1709.06298" rel="nofollow">https://arxiv.org/pdf/1709.06298</a></p>
<p>[4] Yu, Lantao. 2016. SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient. <a href="https://arxiv.org/abs/1609.05473" rel="nofollow">https://arxiv.org/abs/1609.05473</a></p>
<p>[5] Lee, Sang-gil. 2017. A SeqGAN for Polyphonic Music Generation. <a href="https://arxiv.org/abs/1710.11418" rel="nofollow">https://arxiv.org/abs/1710.11418</a></p></div>
    </content>
    <updated>2018-04-06T06:30:14Z</updated>
    <category term="NLP Capstone"/>
    <author>
      <name>Nicholas Ruhland</name>
    </author>
    <source>
      <id>https://mathstoc.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://mathstoc.wordpress.com/category/nlp-capstone/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://mathstoc.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://mathstoc.wordpress.com/osd.xml" rel="search" title="Mathematical Distractions" type="application/opensearchdescription+xml"/>
      <link href="https://mathstoc.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A recreational (occasionally research) blog on topics in maths or computer science - by Kuikui</subtitle>
      <title>NLP Capstone – Mathematical Distractions</title>
      <updated>2018-08-15T00:03:43Z</updated>
    </source>
  </entry>

  <entry xml:lang="en">
    <id>http://mathstoc.wordpress.com/?p=277</id>
    <link href="https://mathstoc.wordpress.com/2018/04/04/nlp-capstone-post-1-ideation/" rel="alternate" type="text/html"/>
    <title>NLP Capstone Post #1: Ideation</title>
    <summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">In this post, I’d like to briefly discuss three different ideas I have for my capstone project. UPDATE (04/05/2018): I am fortunate to be joined by a fellow student, Nicholas Ruhland, for this capstone project. A Theoretical Analysis of RNNs (Research Mode): A recent paper of Professor Naftali Tishby provided some useful observations on the … <a class="more-link" href="https://mathstoc.wordpress.com/2018/04/04/nlp-capstone-post-1-ideation/">Continue reading <span class="screen-reader-text">NLP Capstone Post #1: Ideation</span></a></div>
    </summary>
    <content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>In this post, I’d like to briefly discuss three different ideas I have for my capstone project.</p>
<p>UPDATE (04/05/2018): I am fortunate to be joined by a fellow student, Nicholas Ruhland, for this capstone project.</p>
<h1>A Theoretical Analysis of RNNs (Research Mode):</h1>
<p> A recent <a href="https://arxiv.org/abs/1703.00810">paper of Professor Naftali Tishby</a> provided some useful observations on the behavior of feedforward neural networks, and proposed a promising approach to understanding their performance. Earlier empirical work done in the vision community showed that when a convolutional neural network is trained, layers closer to the input learn lower level features (such as edges and corners) and layers closer to the output learn higher level features (“this part of the image resembles a nose, and this other part resembles an eye”). One might expect similar behavior to occur with general feedforward neural networks: that earlier layers learn lower level features of the input and later levels learn higher level features of the input. The key insight here was to think of each layer of a neural network as a Markov chain, where each layer <img alt="L_{i}" class="latex" src="https://s0.wp.com/latex.php?latex=L_%7Bi%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="L_{i}"/> is a (vector-valued) random variable that is conditionally independent of <img alt="L_{j}" class="latex" src="https://s0.wp.com/latex.php?latex=L_%7Bj%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="L_{j}"/> for all <img alt="j &lt; i - 1" class="latex" src="https://s0.wp.com/latex.php?latex=j+%3C+i+-+1&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="j &lt; i - 1"/> given <img alt="L_{i-1}" class="latex" src="https://s0.wp.com/latex.php?latex=L_%7Bi-1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" title="L_{i-1}"/>. In this way, information flowing forward in the network can be quantified via notions of entropy from traditional information theory.</p>
<p>The paper contains some empirical work, observing that there are generally two phases to learning artificial neural networks via stochastic gradient descent: the fitting phase, and the compression phase. The fitting phase is the shorter phase, where the model is quickly tuning itself to minimize the empirical loss function. At the end of this phase, we don't necessarily have a model that will generalize to new data. The compression phase is where the model begins to learn the relevant features in the input, with the intuition that there are many irrelevant parts of the input (I don't need to know every atom in an object to identify it). </p>
<p>The goal of this project would be to perform a similar theoretical analysis and empirical work for RNN architectures (whose "natural" Markov chain isn't as simple, as there are cycles) on some traditional NLP task, such as Machine Translation, with the goal of studying the flow of information in an RNN architecture, rather than performing comparably to state-of-the-art Machine Translation models (although this can be a stretch goal).</p>
<p>The relevant steps in this project will likely look like the following:<br/>
1. Reading up on the relevant work by Tishby et. al. (and any other theoretical papers on deep learning).<br/>
2. Understand basic and traditional RNN architectures.<br/>
3. Learning PyTorch.<br/>
4. Implementing several of these architectures and testing (for example, to see if learning also comes in two distinct phases: fitting and compression)<br/>
5. Using these empirical observations, and information theory to analyze these architectures.<br/>
6. Time permitted, play around with new RNN architectures.</p>
<h1>Musical Style Learning from Musical Scores (Research/Start-Up Mode):</h1>
<p> This idea lies somewhat outside traditional NLP in that it tackles the language of music. While the alphabet of a musical score consist chiefly of the 12 musical notes, there is added challenge in that several notes may be played simultaneously, especially if there are several instruments involved or simply the two hands of a pianist. Furthermore, the exact timing of each note played matters, note merely the ordering of the notes.</p>
<p>The idea here is simply to, given the score of a musical piece, represented as a sequence of notes at each time, predict the era (Baroque, Classical, Romantic, etc.) or even, the composer of the piece (Bach, Beethoven, Brahms, etc.) There are several problems to be solved step by step for this project.</p>
<p>1. Data collection from a large library of musical scores (ex: <a href="http://imslp.org/">IMSLP</a>)<br/>
2. Data formatting so as to be usable.<br/>
3. Model selection.<br/>
4. Model implementation (PyTorch).<br/>
5. Model testing.</p>
<p>There are also several extensions that can be viewed as stretch goals. For these, the first two can be reused.</p>
<h3>Musical Score Generation:</h3>
<p> Now, we learn how to compose a piece that “sounds” similar to a given composer. This will involve learning from the pieces written by a given input composer, and outputting a new piece. One core challenge here is ensuring that the output is syntactically correct.</p>
<h1>Story Illustration (Start-Up Mode):</h1>
<p> Given a short story and a specific scene (or place in the text), produce an image that is representative of the scene. This project combines aspects of NLP and vision. This project may also explore generative adversarial methods. One well-known challenge here is convergence.</p>
<p>Here are the general steps for this project:<br/>
1. Data collection (image captioning dataset can be helpful)<br/>
2. Model selection.<br/>
3. Model implementation (PyTorch).<br/>
4. Model testing.</p>
<p>As an extension, one can also generate several frames to form a short “movie”. Another can be comic book pane generation.</p></div>
    </content>
    <updated>2018-04-04T06:53:35Z</updated>
    <category term="NLP Capstone"/>
    <category term="Uncategorized"/>
    <author>
      <name>Kuikui Liu</name>
    </author>
    <source>
      <id>https://mathstoc.wordpress.com</id>
      <logo>https://s0.wp.com/i/buttonw-com.png</logo>
      <link href="https://mathstoc.wordpress.com/category/nlp-capstone/feed/" rel="self" type="application/rss+xml"/>
      <link href="https://mathstoc.wordpress.com" rel="alternate" type="text/html"/>
      <link href="https://mathstoc.wordpress.com/osd.xml" rel="search" title="Mathematical Distractions" type="application/opensearchdescription+xml"/>
      <link href="https://mathstoc.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/>
      <subtitle>A recreational (occasionally research) blog on topics in maths or computer science - by Kuikui</subtitle>
      <title>NLP Capstone – Mathematical Distractions</title>
      <updated>2018-08-15T00:03:33Z</updated>
    </source>
  </entry>
</feed>
