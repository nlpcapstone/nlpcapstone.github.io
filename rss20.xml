<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
	<title>NLP Capstone Spring 2018</title>
	<link>https://nlpcapstone.github.io/</link>
	<language>en</language>
	<description>NLP Capstone Spring 2018 - https://nlpcapstone.github.io/</description>
	<atom:link rel="self" href="https://nlpcapstone.github.io/rss20.xml" type="application/rss+xml"/>

<item>
	<title>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde: Last Update</title>
	<guid isPermaLink="true">http://sarahyu.weebly.com/cse-481n/last-update</guid>
	<link>http://sarahyu.weebly.com/cse-481n/last-update</link>
	<description>&lt;div class=&quot;paragraph&quot;&gt;The final update for the project! Unfortunately, there is not as much to report on results as usual and not as many fun visualizations. For the 2nd Advanced Model, my plan was to begin on the stretch goals I had initially outlined and train a neural model for Reddit Post classification and Generation. The idea took cue from the Affect-LM paper. Basically it would be similar to this model&lt;/div&gt;  &lt;div&gt;&lt;div class=&quot;wsite-multicol&quot;&gt;&lt;div class=&quot;wsite-multicol-table-wrap&quot;&gt; 	&lt;table class=&quot;wsite-multicol-table&quot;&gt; 		&lt;tbody class=&quot;wsite-multicol-tbody&quot;&gt; 			&lt;tr class=&quot;wsite-multicol-tr&quot;&gt; 				&lt;td class=&quot;wsite-multicol-col&quot; style=&quot;width: 13.331751602564%; padding: 0 15px;&quot;&gt; 					 						  &lt;div class=&quot;wsite-spacer&quot; style=&quot;height: 50px;&quot;&gt;&lt;/div&gt;   					 				&lt;/td&gt;				&lt;td class=&quot;wsite-multicol-col&quot; style=&quot;width: 68.227199377828%; padding: 0 15px;&quot;&gt; 					 						  &lt;div&gt;&lt;div class=&quot;wsite-image wsite-image-border-none &quot; style=&quot;padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;&quot;&gt; &lt;a&gt; &lt;img alt=&quot;Picture&quot; src=&quot;http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-05-29-at-9-42-04-am_orig.png&quot; style=&quot;width: auto;&quot; /&gt; &lt;/a&gt; &lt;div style=&quot;display: block; font-size: 90%;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;   					 				&lt;/td&gt;				&lt;td class=&quot;wsite-multicol-col&quot; style=&quot;width: 18.441049019608%; padding: 0 15px;&quot;&gt; 					 						  &lt;div class=&quot;wsite-spacer&quot; style=&quot;height: 50px;&quot;&gt;&lt;/div&gt;   					 				&lt;/td&gt;			&lt;/tr&gt; 		&lt;/tbody&gt; 	&lt;/table&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;  &lt;div class=&quot;paragraph&quot;&gt;which has inputs of the context words, on which to build up the rest of the sentence from; the Affect category which is chosen beforehand to generate the desired output; and an Affect strength to determine the intensity of the affect category defined. &lt;br /&gt;&lt;br /&gt;My model would be similar to this, but instead look more like the following where we take out the strength factor and choose the mental category  to be fed into the Mental LM.&lt;/div&gt;  &lt;div&gt;&lt;div class=&quot;wsite-multicol&quot;&gt;&lt;div class=&quot;wsite-multicol-table-wrap&quot;&gt; 	&lt;table class=&quot;wsite-multicol-table&quot;&gt; 		&lt;tbody class=&quot;wsite-multicol-tbody&quot;&gt; 			&lt;tr class=&quot;wsite-multicol-tr&quot;&gt; 				&lt;td class=&quot;wsite-multicol-col&quot; style=&quot;width: 24.666352941176%; padding: 0 15px;&quot;&gt; 					 						  &lt;div class=&quot;wsite-spacer&quot; style=&quot;height: 50px;&quot;&gt;&lt;/div&gt;   					 				&lt;/td&gt;				&lt;td class=&quot;wsite-multicol-col&quot; style=&quot;width: 56.902274509804%; padding: 0 15px;&quot;&gt; 					 						  &lt;div&gt;&lt;div class=&quot;wsite-image wsite-image-border-none &quot; style=&quot;padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;&quot;&gt; &lt;a&gt; &lt;img alt=&quot;Picture&quot; src=&quot;http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/published/screen-shot-2018-05-29-at-10-56-19-pm.png?1527659857&quot; style=&quot;width: auto;&quot; /&gt; &lt;/a&gt; &lt;div style=&quot;display: block; font-size: 90%;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;   					 				&lt;/td&gt;				&lt;td class=&quot;wsite-multicol-col&quot; style=&quot;width: 18.43137254902%; padding: 0 15px;&quot;&gt; 					 						  &lt;div class=&quot;wsite-spacer&quot; style=&quot;height: 50px;&quot;&gt;&lt;/div&gt;   					 				&lt;/td&gt;			&lt;/tr&gt; 		&lt;/tbody&gt; 	&lt;/table&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;  &lt;div class=&quot;paragraph&quot;&gt;My current model seems to have some issues generating posts containing any language beyond the exact topic of the mental category itself (i.e. using the word depressed for the F30 category), with the model using the cross entropy loss. &lt;br /&gt;&lt;br /&gt;At this point, the game plan is to fix the bugs and get a working model to test out the post generation. The results will be interesting to see in and of themselves, but I will also compare the language model of the generated posts against the metrics we hav seen throughout the quarter (vennclouds, idp). &lt;/div&gt;</description>
	<pubDate>Tue, 29 May 2018 17:35:14 +0000</pubDate>
</item>
<item>
	<title>Aaron Johnston, Lynsey Liu &lt;br/&gt; Team Viterbi Or Not To Be: Advanced Model #2, Part 2</title>
	<guid isPermaLink="false">https://medium.com/p/d4957f6e802</guid>
	<link>https://medium.com/@viterbi.or.not/advanced-model-2-part-2-d4957f6e802?source=rss-c522ef075bb3------2</link>
	<description>&lt;p&gt;Now that we’ve finished our minimum viable product, for Part 2 we’re focusing on further analysis and improvement of our advanced model, working on a demo to showcase our results, and drawing up a final action plan to wrap up the project!&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Demo&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;One of the big things that we have been working on in the past week is a demo to illustrate a possible use case for our model. Our goal for the demo is ultimately to provide an interface in which users can simulate having a conversation or opening a long conversation and subsequently being able to access a useful summary of the topics and ideas that were discussed.&lt;/p&gt;&lt;p&gt;While coming up with our concept for the demo, we had to first make a choice about the input format that would be presented to users. After much discussion, we decided that the interface would have the most impact if it could operate on “live” data — that is, rather than simply uploading an existing conversation, if users could interact with a summary in realtime during a conversation it would help show exactly how our model works. Furthermore, although we set out to explore this project mainly for its technical merit and to understand both the universal features of language and the techniques used in summarization, we believe that our findings would be most directly useful as an augmentation for an application that already handles conversations. That way, a user has the opportunity to get immediate assistance after falling behind in a group conversation, and to explore their records of conversations via summaries rather than perusing the entire conversation.&lt;/p&gt;&lt;p&gt;All of these requirements, from the realtime interaction to the use case as an augmentation to an existing app, pointed us toward using chat data for the demo. We ultimately decided to create a simplistic chat interface that would allow users to stage a conversation and generate summaries directly from that — our idea being that generating the summary, chatting more in the conversation, and then seeing how the summary changes would be the most effective feedback loop for allowing users to understand what our model is doing.&lt;/p&gt;&lt;p&gt;As it currently exists, our demo is extremely bare-bones and serves as a proof of concept more than anything else. Users can chat in realtime, and summaries can be requested using an API call to pull the summary from a pre-trained model in our backend. We are currently working on improving the interface to be more usable, and on hosting the demo so that people can give it a try in more situations than just locally from within our repository.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Plans for Demo Expansion: Summary Visualization&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;In order to make the summary more usable, we want to “weave” it into the conversation so that it can serve as an augmentation rather than a totally separate feature. After all, because our model currently produces only extractive summaries, it makes sense to tie the exact sentences chosen for extraction back to the conversation. Right now, we are working on making the summary interactive in the sense that a user can click the sentences in the summary in one pane and jump to those points in the conversation, using the summary almost as a table of contents. We believe this design showcases our summary effectively and uses it as a convenient entry point for the user while still allowing them to get more detailed information if needed.&lt;/p&gt;&lt;p&gt;Another possibility would be to allow the user to adjust the compression ratio used in the summary, to specify if they want the summary to be only 10% of the conversation or 50%. This has the possibility of making it more user-friendly because they can create a summary for a specific use case, such as an extremely high-level summary being more useful for someone’s records as a simple reminder of a conversation they have already read, while a more in-depth summary might serve better in the use case of catching up on a conversation that has had many messages since the user last visited. However, there is also a downside to this option — by allowing users to specify a hard and fast percentage, our model loses the ability to dynamically adapt the length of the summary based on what is important. In other words, if there are n sentences available in the summary and n+1 nearly equally important sentences to fully capture the thread’s meaning, enforcing the n sentences would cause the summary to lose value while using an absolute threshold would make the summary longer if there is truly more content to display.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Plans for Expansion: Feature Visualization&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;One additional thing we have been exploring is the option for users to visualize the factors that lead to a sentence being selected for the summary. This would be a more technical option than those described above, because it would expose the actual features our model uses. To make this work, we would need to come up with a reliable way to calculate the “basis” for each sentence’s classification, which is a somewhat nebulous concept and therefore something we are still discussing. In general, it is possible to determine the weight that our model places on each of the features, but we would need to also understand the boundary used for each feature in order to provide useful information about a specific sentence. For example, consider a feature like the intensity of the sentiment score for a given sentence: we might be able to determine that our model places a higher-than-average weight on this feature, but we would need information about whether a higher or lower sentiment score is more likely to lead to classification as part of the summary in order to display to the user whether or not that had led to the specific sentence’s labelling. In addition, the high number of features we have in our feature set threatens to overwhelm any interface we include them in.&lt;/p&gt;&lt;p&gt;If individual features for sentences cannot be applied, another approach we have considered is displaying information such as the topic segmentation that has been applied or which sentences have been modified based on our preprocessing. Doing so would allow the user of our demo to easily understand how our model responds to certain types of data, which would also allow us to potentially debug our model as we make improvements over the next few weeks.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Process of Chat Integration&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Because a large part of our overall project plan is to incorporate both chatlog and email data, a lot of our effort over the past few weeks has been in standardizing our feature set and project pipeline to be able to support chat data. While a big portion of that has been focused on parsing and preprocessing in order to be able to train and evaluate on chat data, this past week we have been running tests to understand the differences between the different types of data and the limitations of using the enormous chatlog dataset.&lt;/p&gt;&lt;p&gt;In particular, we noticed that despite having so much data available, the chatlog dataset was effectively unusable as a training set when using a Naive Bayes model. Although that model had previously been most effective for almost all of our feature sets, we noticed that when applied to the chatlog data it had the distinct tendency to produce summaries in which 0 (or very, very few) sentences were selected. This problem did not show up using Decision Trees, which had decent results based on both ROUGE scores and human evaluation.&lt;/p&gt;&lt;p&gt;Although we are still not entirely sure about the cause of the issue with Naive Bayes, one possible explanation is that the number of sentences included in the reference summary for each training thread is so small that the model ended up having the best chance of classifying a sentence correctly by simply discluding every sentence. It is possible that the structural differences between the Naive Bayes and Decision Tree models caused the latter model to create trees of such a depth that they were able to learn the difference between included and excluded sentences even with so few examples. We definitely have more analysis to do in the coming weeks to understand this disparity better, but more than anything else it alerted us to the fact that the vastness of the chatlog data is a double-edged sword — although it provides more data on which to train, it also brings a new problem of extremely sparse reference summaries.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Fixing using Regression SVM&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Normally, using Decision Trees over Naive Bayes would not be a major setback, because although Naive Bayes performed slightly better for most applications in the email dataset they were relatively comparable. However, with the introduction of the compression ratio that we discussed in last week’s blog post, we found that additional work was necessary to use the compression ratio with the chatlog data. Because the Naive Bayes regression implementation we had been using never labelled sentences as being part of the summary during our testing, we eventually decided to incorporate SKLearn’s SVM Regression model in order to provide regression functionality for the chatlog data and enable us to manually tune the compression ratio.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Participant Tracking&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;In an effort to capture more conversation-specific aspects of the data, we added a feature to take into account the author of a sentence when vectorizing. The author frequency feature is calculated by taking the count of contributions from the sentence’s author to the thread and normalizing it by the total number of sentences. This measure represents the amount of weight a participant has in a conversation which can translate to indicating how important the contributions of specific participants are.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Discourse Tracking&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;To track conversation flow, we also added a feature to give more conversational context to the current sentence. The previous TF-ISF feature is the TF-ISF score of the chunk that the sentence is in reply to, giving it more information about the conversation up to the current point. If a sentence is in reply to an important chunk, it may indicate that the sentence should also be included in the summary.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Plans for Abstractive Summarization&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;To tackle our stretch goal of generating abstractive summaries, we would most likely take the approach of using the extracted sentences along with corresponding metadata as a starting point as we have mentioned before. More specifically, we would like to capture the authors of each sentence so we can create sentences that do a better job of describing the conversation (for example, “Person A said &amp;lt;extracted content&amp;gt;. Person B then replied…” and so on).&lt;/p&gt;&lt;p&gt;We have also thought about various strategies to generate more natural text from the extracted sentences. These include training and using a language model on the abstractive summary annotations that some of our datasets have, looking at techniques for sentence compression, and applying tense correction.&lt;/p&gt;&lt;p&gt;Sentence compression would help us progress beyond needing to use direct quotes from the corpus in our summary by being able to get a short and sweet version of the sentence that still retains its main meaning and purpose. This could mean, for example, reducing a sentence like “I would really like to have a delicious cup of coffee” to simply “I want coffee.”&lt;/p&gt;&lt;p&gt;Applying tense correction would partner with the idea of including who said what in the abstractive summary. For example, if Person A says “I want coffee” adding the author attribution would result in a sentence like “Person A said I want coffee.” To make this a more natural sentence, we can correct the first person “I” to a third person “they” — resulting in “Person A said they want coffee” which would read better in an abstractive summary.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Plans for Semantic Features&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Something we have noticed about our current feature set is that it does not include any features based off of semantic properties of the sentences. Being able to determine the purpose of a sentence within a chunk or thread would be really helpful information for deciding its importance to the conversation. For example, sentences in an email can be broken down into categories like ‘Greeting,’ ‘Background / Context,’ ‘Problem,’ ‘Elaboration,’ ‘Solution,’ and ‘Sign-off.’ Some of the more obvious uses of these categories would be inferring that Greeting and Sign-off are not meaningful content in the conversation and should not be included in a summary.&lt;/p&gt;&lt;p&gt;To do this, we would like to look more into incorporating Rhetorical Structure Theory (RST), particularly in reference to the relations between sentences in a chunk, to identify the category of a sentence. We can also approach this feature by looking for certain cue words (perhaps words like “because,” “if,” “since,” “so”) to categorize the sentence.&lt;/p&gt;&lt;p&gt;Overall, we’ve had a lot of fun (and learned a lot!) working on this model, and we hope you enjoyed reading about it too!&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=d4957f6e802&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 23 May 2018 06:58:26 +0000</pubDate>
</item>
<item>
	<title>Halden Lin &lt;br/&gt; Team undef.: NLP Capstone | 09: Any Summary</title>
	<guid isPermaLink="false">https://medium.com/p/b7c31ac45ecc</guid>
	<link>https://medium.com/@halden.lin/nlp-capstone-09-any-summary-b7c31ac45ecc?source=rss-2759d54493c0------2</link>
	<description>&lt;p&gt;&lt;em&gt;previous posts: &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5&quot;&gt;&lt;em&gt;01&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5&quot;&gt;&lt;em&gt;02&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3&quot;&gt;&lt;em&gt;03&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7&quot;&gt;&lt;em&gt;04&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a&quot;&gt;&lt;em&gt;05&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0&quot;&gt;&lt;em&gt;06&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-07-formalizing-a2d837ecf66b&quot;&gt;&lt;em&gt;07&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-08-human-summaries-33072535817f&quot;&gt;&lt;em&gt;08&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;In my last post, I stated a main goal of mine was to visualization &lt;strong&gt;human summaries&lt;/strong&gt;. After talking with Prof. Jeff Heer this past week, I’ve developed a more concrete goal for this segment of my project.&lt;/p&gt;&lt;p&gt;If we are able to develop a method for approximating human ‘attention’ between source and summary, we can use it in the following ways.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Evaluation tool.&lt;/strong&gt; Current evaluation requires reading article, summary, and thinking critically to map between the two in order to determine whether or not the summary is ‘good’.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Enable cross-model comparison and analysis.&lt;/strong&gt; How do different models produce summaries for the same article? Automatic measures, such as Rouge and Meteor, are generally poor indicators of proper quality. Currently, one may read summaries and source text and attempt to qualify proper coverage of key ideas. By introducing a visualization that can be generated from &lt;strong&gt;any&lt;/strong&gt; source-summary pair, we can enable more principled analysis.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Enable model to human comparison and analysis.&lt;/strong&gt; This I discussed in the previous post. What do human summaries have that our models are missing? Missing coverage? Missing entities? This visualization tool could answer these questions.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;In general, this tool would allow researchers to gain insights about both human and machine summaries.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;With this in mind, I’ll go into the approaches I’ve been experimenting with in the past week.&lt;/p&gt;&lt;h4&gt;Hierarchical Similarity&lt;/h4&gt;&lt;p&gt;Last week, I attempted token-on-token similarity. The results can be seen the gif below. The weight between input and output token &lt;em&gt;x &lt;/em&gt;and &lt;em&gt;y&lt;/em&gt;, respectively, can be described as so:&lt;/p&gt;&lt;p&gt;&lt;em&gt;a(x, y) = similarity(x, y)&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Where similarity is calculated using a standard word embedding API (in this case, &lt;a href=&quot;https://spacy.io/&quot;&gt;spaCy&lt;/a&gt;). The issue with this approach was that context is lost, and so a word will often attend to nearly the entire document with no regard to the ideas coming out of each portion (in summaries, we expect a sentence or phrase to summarize a specific part or few parts of the original document).&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/800/1*-ganHe0RsisBYzaPKOuHhA.gif&quot; /&gt;Token-on-token similarity pays no heed to context — problematic.&lt;/figure&gt;&lt;p&gt;In attempt to remedy this, I added a factor to each weight that represents the similarity of the tokens’ respective sentences. That is, the weight of a given &lt;em&gt;x, y&lt;/em&gt; pair is determined by the similarity of the sentence of &lt;em&gt;x &lt;/em&gt;and the sentence of &lt;em&gt;y&lt;/em&gt;, multiplied by the similarity of the tokens themselves. To both normalize weights (over output token) and exaggerate salient pairs, I also add a soft-max transformation for each similarity score. The equation below describes this formula.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*WE0z9rPYF_Nb_X4Y.&quot; /&gt;&lt;/figure&gt;&lt;p&gt;The &lt;em&gt;theta&lt;/em&gt; terms here are important in properly exaggerating salient pairs, and so require some tuning.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/800/1*QJFNJ0ty3NimB1nBAnTdXg.gif&quot; /&gt;Hierarchical Similarity shows some promise, but has a few issues.&lt;/figure&gt;&lt;p&gt;This approach shows some promise. Context is taken into account, at least at a sentence-by-sentence level. However, there are a few shortcomings that become apparent with more abstractive summaries. In particular:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Context is better but far from perfect.&lt;/strong&gt; Sometimes ideas span multiple sentences, difficult to model. Additionally, repeating words in a sentence get equal ‘attention’ even though one may make more sense from a token-by-token generation standpoint.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I’ll be exploring this approach further in the next week, but I have concerns about its ability to generalize well, per issues described above.&lt;/p&gt;&lt;h4&gt;Hidden Markov Model&lt;/h4&gt;&lt;p&gt;At a high level, we can imagine ‘attention’ as the words and phrases from the source text to that one would draw from to write a portion of a summary. This makes sense: we tend to focus on specific areas of a document at a time when writing summaries. Breaking this into token-by-token time-steps, summary token is &lt;strong&gt;conditioned&lt;/strong&gt; on the ‘attention’ vector for that time-step.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/151/1*6wNP-KSn13tGSSwDjmDXxw.png&quot; /&gt;Summary tokens are conditioned on attention vectors over the source text.&lt;/figure&gt;&lt;p&gt;Further, we can reason that attention vectors change from time-step to time-step, dependent on the previous attention vector.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/361/1*krjZPlauErnawaKymE5LAA.png&quot; /&gt;Attention vectors are conditioned on each other.&lt;/figure&gt;&lt;p&gt;This of course is an simplification — the way our minds work is likely far more complex — but it allows us to model the ‘attention’ between source and summary as a Hidden Markov Model (HMM).&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/611/1*3wfXRV8pMJZQ74Ux1OGjDA.png&quot; /&gt;Source to summary modeled as a Hidden Markov Model.&lt;/figure&gt;&lt;p&gt;We can then use this model to predict attention vectors at each time-step (e.g. Viterbi, Forward-Backward). This is similar to how HMMs are used to predict part-of-speech tags (where POS tags are conditioned on each other and tokens are conditioned on those tags). Emissions (the edge weight going from distribution to summary token) can be defined by token similarity, but there are still a challenges here.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;How to define transition probabilities?&lt;/li&gt;&lt;li&gt;Treat attention states as distributions or single tokens (e.g. argmax in vector)?&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;I’ll need to consider this approach further to see if I can work out these kinks.&lt;/p&gt;&lt;h4&gt;POS Tags&lt;/h4&gt;&lt;p&gt;I’ve also been slowly improving the visualization tool itself. I’ll briefly describe my progress on this front.&lt;/p&gt;&lt;p&gt;Using &lt;a href=&quot;https://www.nltk.org/&quot;&gt;NLTK&lt;/a&gt;, I was able to part-of-speech tag machine-generated summaries. At the top right of the visualization, users are presented a panel of the POS Tags used by the &lt;a href=&quot;https://catalog.ldc.upenn.edu/ldc99t42&quot;&gt;Penn Tree Bank&lt;/a&gt;, which NLTK sources from. Non-present tags are greyed-out.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1000/1*i87AaOJBtCzk4h_G5b5z9A.gif&quot; /&gt;Users can highlight tokens to view the corresponding tag, or mouse over tags to highlight all corresponding tokens.&lt;/figure&gt;&lt;p&gt;This should allow more in-depth analysis of the attention vectors produced by the machine. Eventually I’d like to work towards highlighting named entities in the source / summary to allow users to identify present / missing ideas centered on important entities.&lt;/p&gt;&lt;h4&gt;Upcoming Work&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;Continue working on visualizing source-summary alignment.&lt;/li&gt;&lt;li&gt;Continue improving visualization.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;I have lots, lots, lots to do. Until next time!&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=b7c31ac45ecc&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 23 May 2018 06:43:01 +0000</pubDate>
</item>
<item>
	<title>Ananth Gottumukkala &lt;br/&gt; Team Turing Test: Advanced Model Attempt 2 (Part 2)</title>
	<guid isPermaLink="false">http://deeplearningturingtest.wordpress.com/?p=27</guid>
	<link>https://deeplearningturingtest.wordpress.com/2018/05/23/advanced-model-attempt-2-part-2/</link>
	<description>&lt;p&gt;This week I further tuned my hyperparameters and increased the exploration rate of my model so the slot-filling Q-values were fixed for all my questions. This made sure that my slot filling accuracy is perfect (when there’s no dropout). After tweaking the model, I tested and recorded the number of games it won using both the database it trained on as well as another random database of 100 people.&lt;/p&gt;
&lt;p&gt;Training Database: Model won 90/100 games.&lt;/p&gt;
&lt;p&gt;Validation Database: Model won 87/100 games.&lt;/p&gt;
&lt;p&gt;As expected, the validation accuracy is not too far behind the training accuracy. While the NLU component of the model is just as accurate for both databases, the order of questions is more tailored towards the training database so the sequence of questions might be a bit inefficient for the other database meaning some additional games must have been lost on time. The reference paper I based this model on was trained using speech utterances and that model got about a 92% win rate (although they didn’t specify whether the database they evaluated on was different from the one they trained on). Therefore, my model is not quite as well trained as theirs but it’s still not too far behind in accuracy.&lt;/p&gt;
&lt;p&gt;Now that I have my minimal action plan working, this week I’ll work on my final report and presentation as well as try to make this model work for a more generic dialogue scenario as a possible demo.&lt;/p&gt;</description>
	<pubDate>Wed, 23 May 2018 06:34:21 +0000</pubDate>
</item>
<item>
	<title>Aaron Johnston, Lynsey Liu &lt;br/&gt; Team Viterbi Or Not To Be: Advanced Model #2, Part 1</title>
	<guid isPermaLink="false">https://medium.com/p/29b207b75065</guid>
	<link>https://medium.com/@viterbi.or.not/advanced-model-2-part-1-29b207b75065?source=rss-c522ef075bb3------2</link>
	<description>&lt;p&gt;This week, we started working on our second advanced model attempt! The chatlog data is fully integrated this time, though we are still working on making our model effective across all types of text conversation. In addition to finishing construction of our proposed pipeline, we’ve also upgraded almost all of the previously existing components (pre-processor, feature vectorizer, model) to make the first big steps towards completing our final advanced model.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*FIza3SY9EreLeCf1.&quot; /&gt;Pipeline for integrating different datasets with a common feature set into our model, now completed!&lt;/figure&gt;&lt;h4&gt;&lt;strong&gt;Adding the Chatlog Dataset — For Real This Time!&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Achieving one of our major goals for the advanced model, we have finished integrating chatlog data into our model! This involved a considerable amount more effort than we anticipated because the chat data ended up being much more noisy and varied than the email data, leading to a significant portion of our time being spent re-formatting and parsing the original data files to get it into the same input structure as the email data.&lt;/p&gt;&lt;p&gt;Even in our initial testing, the impact from adding chatlog data has been noticeable. There are two major benefits that we have identified for the importance of incorporating this second data source. The first, and perhaps most obvious, is that it expands the domain in which our model is able to operate — because conversation data in the modern age increasingly happens over both email and chat, it increases the helpfulness of our model to be able to produce summaries for chatlogs as well.&lt;/p&gt;&lt;p&gt;However, the other benefit is that the chatlog dataset has considerably more data points available than the email dataset, perhaps due to the nature of chat as a noisy, casual medium. A single email thread consists of about 80 sentences on average, and we only have 32 email threads to train with when we are using an 80% / 20% split in k-fold cross validation. That means the email data has only about 2500 sentences of training data.&lt;/p&gt;&lt;p&gt;By contrast, the chatlog dataset is considerably larger. Again using 80% of the data as training data, we have 1118 threads of about 1200 sentences each, meaning the chatlog data has about 1,341,600 sentences or approximately 500 times the data points that were previously available. Through the use of this added data, our goal is ultimately to improve the performance of our model on a smaller dataset, such as email, solely by virtue of the massively increased amount of training data that is available by combining different data types.&lt;/p&gt;&lt;p&gt;Of course, to make this arrangement work, it is necessary to use a universal feature set that can apply to any type of data. That way, the model is trained on the same set of features regardless of how the data was originally structured, and it has universal applicability for any future datasets that might be added. One of the more unique aspects of our project is this combination of different text conversation mediums and the utility of our features across all conversation types.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Text Segmentation&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;An interesting challenge we encountered while incorporating both email and chat data was finding analogous parts and features between the two formats. Email threads were easily separated into emails, but chatlogs being one long, unstructured flow of conversation made it more difficult to process. To help with this problem, we added preprocessing of chatlogs into Longest Contiguous Messages (LCM). To capture LCM, we concatenated subsequent messages of the same user and identified a boundary when the user changes or when a period is encountered.&lt;/p&gt;&lt;p&gt;The effect of this incorporation was to create email-like “chunks” of the conversation, which we were then able to use for certain document-dependent features like TF-ISF that rely on having messages segmented into individual documents.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*gW-GdW9aTe7v05OL.&quot; /&gt;A before (left) and after (right) of applying LCM on a chat excerpt, taken from Sood et. al.&lt;/figure&gt;&lt;h4&gt;&lt;strong&gt;Input Structure&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;To improve the context our features are able to operate with, we changed the input format of our data to have one more level of granularity. In our previous iterations of the model, our input structure was a list of threads, each thread being a list of sentences. Our new input format has one more nested layer — each thread is now a list of ‘chunks’ and each chunk is a list of sentences. For emails, a chunk is naturally a single email in the thread. For chatlogs, a chunk is determined by LCM text segmentation, with each chunk consisting of the contiguous messages by a single user.&lt;/p&gt;&lt;p&gt;This changes the sentence position feature to mean the sentence position within a chunk rather than within the whole thread, which we believe is more relevant to the sentence’s importance. This also allows us to add a “position from end of the chunk” feature which is helpful for eliminating ending lines (like sign-offs or parting words) and other features that might depend on chunk granularity context.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Results of Cross-Training&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;In order to examine the efficacy of our multi-dataset training approach, we ran some experiments to look at the ROUGE scores that are produced. Our first attempt was to use the Naive Bayes model in order to try this cross-training approach, as it had generally been the most successful in prior experiments. Unfortunately, we discovered that the Naive Bayes model performed extremely poorly in many combinations — after training on the chat data and evaluating on email data, for example, it would cause the vast majority of the email summaries to be blank after determining that every single sentence sentence should be classified as not being included in the summary. However, we were able to use the Decision Tree model instead to produce promising results. We are still attempting to determine the cause of this discrepancy, although one possibility might be that the Naive Bayes model ascribed too much significance to a certain feature that is significantly different between chat and email, such as sentence length or some quirk of proper punctuation.&lt;/p&gt;&lt;p&gt;The following table shows our results while training using the chat and evaluating using the email data, with self-trained email data provided as a comparison. In order to determine the effect of data size on the ROUGE score, we experimented with varying sizes of chat examples:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*pXyyq6x_CVDaNGxx3DpsSw.png&quot; /&gt;Results of various cross-training configurations using email and chat data&lt;/figure&gt;&lt;p&gt;As can be seen from the above table, from a ROUGE score standpoint, the effect of training on more data is considerably more important than the effect of training on the same type of data as is being used for evaluation. Having 12,000 sentences upon which to train causes the model’s ROUGE scores to shoot up significantly higher than having 2,500 sentences, regardless of the type of data.&lt;/p&gt;&lt;p&gt;Another thing we have been experimenting with is training on both types of data before evaluating on a single type of data. In this case, it would mean training on both email and chat before evaluating on either email or chat data. The theoretical advantage of this approach would be that it maximizes the amount of available data, and if there are significant differences between the types of data, it would be sure to incorporate the type of data that the model will be evaluated on.&lt;/p&gt;&lt;p&gt;However, in practical use, it seems as though training on multiple data sources will not contribute significantly to the success of our model because of the fact that the chatlog dataset so completely eclipses the amount of data available in the email dataset. Therefore, from a numerical perspective, training on both types of data would add only a 0.2% increase in data from training on just the chatlog data. In addition, it stands to reason that having such a numerical disadvantage means any significant benefit from training on the same type of data that the model is being evaluated on would be negligible. We are continuing to develop this capability, but for the time being it seems like a low priority.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Topic Segmentation&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;In addition to segmenting by the author of contiguous chat messages, we also wanted to add a new feature for our model that incorporates the changing of topics throughout a message. The idea behind this feature is to use the changing structure of text to determine the boundaries between different topics through an existing algorithm for topic detection called TextTiling (More detail can be found in the &lt;a href=&quot;http://www.aclweb.org/anthology/J97-1003&quot;&gt;paper describing TextTiling&lt;/a&gt;). We used an implementation of TextTiling found within NLTK.&lt;/p&gt;&lt;p&gt;While the paper we used for our baseline model mentioned using TextTiling, they only used the algorithm as a preliminary attempt to segment the chatlog into different chunks. We found that approach to be ineffective, likely because the chunks in an email thread (emails) are separated by author, while TextTiling topics cover multiple authors but cover a single topic, and therefore the two are largely incomparable. To support our concept of a universal feature set, we instead used TextTiling as a separate feature, offering context for sentences.&lt;/p&gt;&lt;p&gt;Currently, our models are capable of using TextTiling in order to determine the position of a sentence within a topic and incorporate the relative position within the topic as a feature. Unfortunately, we have only been able to successfully run TextTiling for tiny datasets so far due to errors that manifest for noisier data, and as a result we are not ready to report results using it.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Compression Ratio&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;One of the major problems we noted in the summaries our model was generating was that while they scored well in ROUGE metrics, the model seemed to place importance on too many sentences and the summaries themselves often ended up too long to be practical. Indeed, summaries for some threads would be composed of over 50% of the “actual” contents of the thread (the parts that were kept after preprocessing), making our summaries close to general reproductions of the original text.&lt;/p&gt;&lt;p&gt;As a solution, we experimented with using a regression model instead of a classifier, giving each sentence a score rather than a binary 1 or 0 (include in the summary or not). With a regression model, we gain the ability to control the compression ratio by changing the threshold of score we accept to include in the summary.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Results of Compression Ratio&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;With these updates to our model, we experimented with tuning regression the running using the new possible training and validation configurations to get the following results.&lt;/p&gt;&lt;p&gt;We first conducted an experiment with the threshold for our regression model to determine the optimal threshold value:&lt;/p&gt;&lt;pre&gt;python main.py bc3/full --type email --model regression_br --threshold &amp;lt;t value&amp;gt;&lt;/pre&gt;&lt;p&gt;For those following along at home, the above command is what we used to generate the values for the following table.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*cNtKD45MlqM822FrIv3R1w.png&quot; /&gt;Results of experimenting with the threshold value using the regression model&lt;/figure&gt;&lt;p&gt;Based on the results, we chose a threshold of 0.3 to continue with. The following table compares the regression model with the Naive Bayes classifier using the full email dataset:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*dixp1JhnxIxOVdM3DZ97_A.png&quot; /&gt;Comparison between our best regression model and classifier model&lt;/figure&gt;&lt;p&gt;In general, the “best” regression model did not have an enormous impact on the ROUGE scores as compared to the best results from the classification models (Naive Bayes), increasing some ROUGE metrics slightly and decreasing others. However, because the regression model allows configuration of the number of sentences that are output by changing the threshold hyperparameter, it adds an additional capability to the model whereby a user can select an optimal “size” of summary.&lt;/p&gt;&lt;p&gt;We developed this feature in response to the problem of “reproducing” the original text in our summaries, and by human standards it seems to be a big improvement. Consider the following email thread summary, produced using our Naive Bayes classifier model:&lt;/p&gt;&lt;pre&gt;Chris Lilley, Brian Stell and others have been discussing the rash of irate, &amp;amp;quot;get me off this list&amp;amp;quot; mesages the listserv has received, lately.&lt;/pre&gt;&lt;pre&gt;Well, folks: YOU CAN'T UNSUBSCRIBE FROM THIS LIST!&lt;/pre&gt;&lt;pre&gt;I've tried for 2 months to get off this list, I've followed the rules, I've tried variations of the theme, looking for some hidden code--all to no avail.&lt;/pre&gt;&lt;pre&gt;So, the last resort of those who have tried everything else is to post to the list they want to be rid of.&lt;/pre&gt;&lt;pre&gt;PLEASE GET ME OFF THIS LIST@!%$#$/-\%&lt;/pre&gt;&lt;pre&gt;Well, that explains a lot!&lt;/pre&gt;&lt;pre&gt;I've been trying for awhile too, and I can't seem to get off.&lt;/pre&gt;&lt;pre&gt;Please remain calm.&lt;/pre&gt;&lt;pre&gt;Our automated list manager works very well.&lt;/pre&gt;&lt;pre&gt;Sometimes there are problems due to:&lt;/pre&gt;&lt;pre&gt;- you being subscribed under another name/address --&lt;/pre&gt;&lt;pre&gt;this was the case for the first among the two recent messages.&lt;/pre&gt;&lt;pre&gt;Well, after receiving a message that informed me of this, I responded with an unsubscribe e-mail with my unaliased e-mail address, and today received an automated response informing me that your software could not find my name on your list.&lt;/pre&gt;&lt;pre&gt;I am very calm.&lt;/pre&gt;&lt;pre&gt;Thanks for the helpful info, but I just received a message saying that I have been removed from the list.&lt;/pre&gt;&lt;pre&gt;Because I posted my difficulties to the list.&lt;/pre&gt;&lt;pre&gt;Sorry I had to burden you all with my problems, but as you can see, it worked.&lt;/pre&gt;&lt;pre&gt;Sam Berlow&lt;/pre&gt;&lt;pre&gt;UNSUBSCRIBE.SIGROLLY&lt;/pre&gt;&lt;p&gt;By contrast, here is the summary for the same email thread, but using a Bayesian Ridge regression model and incorporating a threshold of 0.55 in order to produce a much smaller summary:&lt;/p&gt;&lt;pre&gt;Chris Lilley, Brian Stell and others have been discussing the rash of irate, “get me off this list” mesages the listserv has received, lately.&lt;/pre&gt;&lt;pre&gt;I've tried for 2 months to get off this list, I've followed the rules, I've tried variations of the theme, looking for some hidden code--all to no avail.&lt;/pre&gt;&lt;pre&gt;Well, after receiving a message that informed me of this, I responded with an unsubscribe e-mail with my unaliased e-mail address, and today received an automated response informing me that your software could not find my name on your list.&lt;/pre&gt;&lt;pre&gt;Thanks for the helpful info, but I just received a message saying that I have been removed from the list.&lt;/pre&gt;&lt;p&gt;The difference is quite pronounced, with almost half the sentences in the former being removed when a regression model and higher threshold is used. However, from a human perspective, the second summary is nearly just as informative, and in fact there are several extraneous sentences in the first summary that are dropped. Because the ROUGE scores are roughly the same in both cases, but the second summary is somewhat better from a human viewpoint, we would consider the use of a compression ratio to be a success in improving our model.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Next Steps&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;So far we’ve trained on single data sources (email or chat) before evaluation since we weren’t quite able to get training on both sources at once working yet in this part 1 attempt. We aim to fix this next week and be able to train on multiple data sources and fine tune the cross-training.&lt;/p&gt;&lt;p&gt;We think there is a lot of potential in features based on topic segmentation, semantic meaning, and the conversation-specific aspect of the authorship of a sentence. So, we also aim to finish our implementation of TextTiling-based feature, a feature that incorporates Rhetorical Structure Theory (RST) output, and feature that includes information from tracking the contributions of different participants throughout the conversation.&lt;/p&gt;&lt;p&gt;After completing these improvements, we would like to take a crack at our stretch goal of generating abstractive summaries and make a demo of our summarizer on a chat interface!&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=29b207b75065&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Thu, 17 May 2018 06:56:06 +0000</pubDate>
</item>
<item>
	<title>Kuikui Liu, Nicholas Ruhland &lt;br/&gt; Team INLP: NLP Capstone Post #8: Training challenges</title>
	<guid isPermaLink="false">http://mathstoc.wordpress.com/?p=339</guid>
	<link>https://mathstoc.wordpress.com/2018/05/17/nlp-capstone-post-8-training-challenges/</link>
	<description>&lt;h1&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Challenges with training TSL model&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;In our previous post we proposed a three-model system that would allow us to take advantage of a larger corpus of higher quality lyrics data for the production of lyrics. We also finally tackle the alignment task with a simple approach of determining whether a lyric token should be produced at each timestep. This seems sensible since we have begun dividing the MIDIs into pianorolls with a constant frequency.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Unfortunately, even after several bugs bashed, we’ve been still unable to produce even sensible timings. We find the RNN collapses to repeatedly generating 0 (for no lyric event), even though a randomly initialized RNN will repeatedly generate 1 (and perform better with respect to classification accuracy).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h1&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Future direction&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;If we are able to produce something reasonable from our existing architecture, we would like to move on to a second model that structures the problem as machine translation. We have decided to focus on the paper Attention is All You Need by Vaswani et al. [1] for our presentation in two weeks. The structure of our problem is straightforward to apply to translation as converting pianoroll format into english sentences. Incorporating attention has shown promising results in the literature, though that is no guarantee that our noisy dataset would be able to take advantage of this proposed architecture.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h1&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;References&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;[1] &lt;/span&gt;&lt;a href=&quot;https://arxiv.org/abs/1706.03762&quot;&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;https://arxiv.org/abs/1706.03762&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;</description>
	<pubDate>Thu, 17 May 2018 05:55:03 +0000</pubDate>
</item>
<item>
	<title>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde: Advanced Model Attempt #2</title>
	<guid isPermaLink="true">http://sarahyu.weebly.com/cse-481n/advanced-model-attempt-2</guid>
	<link>http://sarahyu.weebly.com/cse-481n/advanced-model-attempt-2</link>
	<description>&lt;div class=&quot;paragraph&quot;&gt;Wow, can't believe we're already in week 8! &lt;br /&gt;&lt;br /&gt;This past week, I've worked on shifting my project from not having a neural component, to well, having one. With inspiration from the work of Ghosh et al. in &lt;em&gt;Affect-LM: A Neural Language Model for Customizable Affective Text Generation, &lt;/em&gt;I've extended my project (and am encroaching on stretch goal territory) to include a neural language model for reddit post generation***. The idea would be to train a model on reddit posts out of five categories - F30 (mood [affective] disorders), F40&lt;font color=&quot;#515151&quot;&gt; (Anxiety, dissociative, stress-related, somatoform and other nonpsychotic mental disorders), X71 (Intentional Self Harm), F10 (addiction categories), and neurotypical advice - and use that model for post generation, based on the specified target type, i.e. generate a F30 reddit post. &lt;br /&gt;&lt;br /&gt;&lt;/font&gt;&lt;br /&gt;&lt;/div&gt;</description>
	<pubDate>Wed, 16 May 2018 23:19:31 +0000</pubDate>
</item>
<item>
	<title>Halden Lin &lt;br/&gt; Team undef.: NLP Capstone | 08: Human Summaries</title>
	<guid isPermaLink="false">https://medium.com/p/33072535817f</guid>
	<link>https://medium.com/@halden.lin/nlp-capstone-08-human-summaries-33072535817f?source=rss-2759d54493c0------2</link>
	<description>&lt;p&gt;&lt;em&gt;previous posts: &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5&quot;&gt;&lt;em&gt;01&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5&quot;&gt;&lt;em&gt;02&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3&quot;&gt;&lt;em&gt;03&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7&quot;&gt;&lt;em&gt;04&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a&quot;&gt;&lt;em&gt;05&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0&quot;&gt;&lt;em&gt;06&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-07-formalizing-a2d837ecf66b&quot;&gt;&lt;em&gt;07&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;I’ll keep this blogpost short — my current undertakings are in-progress and it might be a week or more before they are realized. To preface:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Visualizing human summaries&lt;/li&gt;&lt;li&gt;Improving the visualization.&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;Visualizing Human Summaries&lt;/h3&gt;&lt;p&gt;When I was presenting my project update last week, Prof. Choi asked a very interesting question. What if we could use this visualization tool to not only understand how the model is generating summaries, but also how human summaries are produced and how the two compare?&lt;/p&gt;&lt;p&gt;I’ll briefly explain the thought behind this.&lt;/p&gt;&lt;p&gt;Visualizations provide a mapping from raw data (in this case, attention weights and input / output tokens) to visual encodings. These visual encodings are valuable in that they allow us as humans to perceive the data in a meaningful way. For example, the attention visualizer I am working on allows us to identify overall patterns in the attention of the model.&lt;/p&gt;&lt;p&gt;How do we interpret human written summaries, i.e. their relation to the source text? Perhaps we scan the document and attempt to match paragraphs or sentences to sentences in the summary. This can be compared to the ‘attention’ our minds use to generate the summary. If we can visualize this mapping, perhaps in a more refined and detailed manner (i.e. token by token) then we should be able to compare the human summaries with the machine generated summaries, right? And then one may be able to identify what the human summaries have that the machine summaries do not, or visa versa. The hope is that if we can enable this kind of comparison, researchers may be better equipped to improve their models by using these insights.&lt;/p&gt;&lt;p&gt;So far, I’ve experimented with two methods for generating this ‘attention’ from human summary to source text.&lt;/p&gt;&lt;h4&gt;Word Similarity&lt;/h4&gt;&lt;p&gt;The first approach that sprung to mind was to use word similarity as a proxy for ‘attention’. To do this, I used &lt;a href=&quot;https://nlp.stanford.edu/projects/glove/&quot;&gt;pre-trained GloVe embeddings&lt;/a&gt; and the &lt;a href=&quot;https://radimrehurek.com/gensim/&quot;&gt;Gensim API&lt;/a&gt; to calculate word similarities between each input token / output token pair. &lt;a href=&quot;https://spacy.io/&quot;&gt;SpaCy&lt;/a&gt; was used to tokenize the sequences. The result is a matrix of weights, similar to attention distribution, albeit not normalized per output token (with attention, for a given output token the aggregate over all input tokens is 1). As the example below shows, this method falls flat, as output tokens are matched to input tokens regardless of context. This means it makes little sense to compare these weights to attention.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*D6pMsnZjlNiz1XJyN5xcBQ.png&quot; /&gt;The word ‘the’ is matched with nearly every token in the input sequence, likely a result of its extreme commonness and proximity to most words in embedding space.&lt;/figure&gt;&lt;h4&gt;Summarization Model&lt;/h4&gt;&lt;p&gt;The second method I considered was one suggested by Ari. Here, we use the same model used to generate the machine summaries. The difference is that at each decoder time-step, instead of feeding in the previous &lt;strong&gt;predicted&lt;/strong&gt; token, we feed in the previous &lt;strong&gt;actual&lt;/strong&gt; token. This means that instead of having a decoding pipeline that looks like this:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*N-til0kZzQeAVI3zkoDKVg.jpeg&quot; /&gt;&lt;/figure&gt;&lt;p&gt;Where y-hats represent predicted output tokens, we have one that looks like this:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*H7nMlelojnzNkfthS2ljAg.jpeg&quot; /&gt;&lt;/figure&gt;&lt;p&gt;Where y (no hat) represents true output token (the token from the human summary). This is a process similar to the one taken during training of generative encoder-decoder models.&lt;/p&gt;&lt;p&gt;By grabbing attention distributions just as we had with the machine summaries, we hope to get an approximation of the attention distributions for the human summaries — we are essentially feeding the model the answer. However, there is a catch, and an important one. Because attention weights are used to create a context vector that is then fed into the &lt;strong&gt;next&lt;/strong&gt; decoder unit to predict the &lt;strong&gt;next &lt;/strong&gt;word, we run into an issue when the next word is predicted incorrectly. Turns out, this happens often under the model being used (from &lt;a href=&quot;https://github.com/abisee/pointer-generator&quot;&gt;See et al.&lt;/a&gt;). This actually makes sense, as the model has been shown to produce largely &lt;strong&gt;extractive &lt;/strong&gt;summaries, and so one would expect the model to, at each time-step, attempt to produce the next word in the source text that follows the word fed to it. With &lt;strong&gt;abstractive&lt;/strong&gt; summaries, this is not often the optimal choice. This results in attention weights that make little sense, as seen below.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*c5KuVp0qzjkcQxNAJSfYLw.png&quot; /&gt;According to this, ‘manager’ was the focal point of attention when producing the word ‘were’. It would seem that the model intended to predict ‘manager’, and so when we map this attention weight to the human token, we run into an issue.&lt;/figure&gt;&lt;p&gt;Here’s the problem. The model is trained to use attention weights to &lt;strong&gt;generate &lt;/strong&gt;an output token. What we want is the opposite. We want the attention &lt;strong&gt;given&lt;/strong&gt; an output token — use the output token to generate the attention weights. This poses a significant challenge.&lt;/p&gt;&lt;h4&gt;So How Else?&lt;/h4&gt;&lt;p&gt;So neither of these methods seem to produce anything meaningful. I’m not ready to give up though — this is an intriguing problem. In the next week I’ll be brainstorming other methods. One that might have some traction is to use a few heuristics to approximate ‘attention’ using word similarities in conjunction with context. For example, by imposing a penalty on the weight if the context of the output token is dissimilar to the word ‘attended’ to in the source text. Much more work to be done here.&lt;/p&gt;&lt;h3&gt;Improving the visualization&lt;/h3&gt;&lt;p&gt;This section will be short. There are a few problems I looked into in the past week.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Implement divided edge bundling, as produced by &lt;a href=&quot;http://vis.stanford.edu/files/2011-DividedEdgeBundling-InfoVis.pdf&quot;&gt;Selassie et al. (2011)&lt;/a&gt;. I described this briefly in my previous blog post. The obstacle here is that there is not available d3 implementation of the algorithm. In fact, the only implementation I could find available was &lt;a href=&quot;https://github.com/kakearney/divedgebundle-pkg&quot;&gt;one for Matlab&lt;/a&gt;, produced by &lt;a href=&quot;http://kellyakearney.net/&quot;&gt;Kelly Kearny (University of Washington)&lt;/a&gt;. This might prove more difficult than the remaining time in this quarter allows, but I’ve started the process anyways and will see where it takes me.&lt;/li&gt;&lt;li&gt;Highlighting extraction. That is, making it apparent in the visualization when the model is simply copying. I’ve been playing around with things such as color to encode this, but haven’t settled on anything I like.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;More work to come!&lt;/p&gt;&lt;h4&gt;References&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1704.04368.pdf&quot;&gt;See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” &lt;em&gt;ACL&lt;/em&gt; (2017).&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://vis.stanford.edu/files/2011-DividedEdgeBundling-InfoVis.pdf&quot;&gt;Selassie, David et al. “Divided Edge Bundling for Directional Network Data.” &lt;em&gt;IEEE Transactions on Visualization and Computer Graphics&lt;/em&gt; 17 (2011): 2354–2363.&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=33072535817f&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 16 May 2018 06:58:49 +0000</pubDate>
</item>
<item>
	<title>Ananth Gottumukkala &lt;br/&gt; Team Turing Test: Advanced Model Attempt 2 (Part 1)</title>
	<guid isPermaLink="false">http://deeplearningturingtest.wordpress.com/?p=25</guid>
	<link>https://deeplearningturingtest.wordpress.com/2018/05/16/advanced-model-attempt-2-part-1/</link>
	<description>&lt;p&gt;This week I was able to greatly improve upon the results from last week. Last week my average reward got to about -23 at best, but this week by tweaking my reward function I was able to greatly speed up convergence and bump my model up to about +70 reward on average. I made my reward function more strict about interpreting the user response correctly by giving a +6 reward for correct interpretation, -6 reward for the opposite interpretation and 0 reward for interpreting as unknown (model is unsure).&lt;/p&gt;
&lt;p&gt;One way I tried to improve over last week was reducing my CNN architecture to simplify the state representation, but surprisingly this had the opposite effect of underfitting on the user responses and misinterpreting them more. In fact, I later found out that my reward function was the main reason my model didn’t converge and in the end I actually ended up increasing the number of filters in my CNN architecture.&lt;/p&gt;
&lt;p&gt;At this point, my model is able to win between 3 and 4 out of 5 games on average because there is 1 out of my 31 questions for which it learned the wrong Q values, probably due to insufficient exposure to the right answer, so I’ll increase the amount of exploration the model takes until these values are straightened out and the model wins 5 out of 5 games. Then I’ll evaluate the model performance on a separate database of 100 different people. While I expect the end result to be the same (winning 100% of games), I expect the model to take longer to win on average because the order of questions it asks to eliminate people is tailored towards the training database.&lt;/p&gt;
&lt;p&gt;My goals for this week are reporting more exact quantitative results of model performance in terms of games won and reward gained, both on the training database and a validation database of 100 different people. Furthermore, I’ll experiment with a slightly more complicated dialogue scenario but I probably won’t go too deep considering I only have about a week left.&lt;/p&gt;</description>
	<pubDate>Wed, 16 May 2018 06:55:57 +0000</pubDate>
</item>
<item>
	<title>Kuikui Liu, Nicholas Ruhland &lt;br/&gt; Team INLP: NLP Capstone Post #7: TSL Pipeline</title>
	<guid isPermaLink="false">http://mathstoc.wordpress.com/?p=335</guid>
	<link>https://mathstoc.wordpress.com/2018/05/10/nlp-capstone-post-7-tsl-pipeline/</link>
	<description>&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Modeling issues&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;As seen in our results last week, the RNN architecture we have been training has not been able to produce any coherent series of tokens based on the music data provided in the clean Lakh dataset. To analyze the poor results of this model, we have considered various features of the quality of the data. To simplify the issue of timing the lyric tokens, this model attempts to predict a lyric token at every timestep. Between each token we have summed all the musical data, producing a piano roll that looks approximately like the following image.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;Screen Shot 2018-05-09 at 4.31.53 PM&quot; class=&quot;  wp-image-331 aligncenter&quot; height=&quot;303&quot; src=&quot;https://mathstoc.files.wordpress.com/2018/05/screen-shot-2018-05-09-at-4-31-53-pm.png?w=501&amp;amp;h=303&quot; width=&quot;501&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;In the event that two lyrics occur at exactly the same time step, we end up with a gap in the notes, here highlighted in red.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;Screen Shot 2018-05-09 at 4.31.53 PM&quot; class=&quot;  wp-image-334 aligncenter&quot; height=&quot;302&quot; src=&quot;https://mathstoc.files.wordpress.com/2018/05/screen-shot-2018-05-09-at-4-31-53-pm1.png?w=500&amp;amp;h=302&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;At first we expected this problem to occur in only a small number of cases, but it is often the result of the newline character appearing in a message simultaneously with the first lyric of the next sentence. This processing poses several problems to the task of learning the lyrical content based on the structure of the music. First, the large number of musical gaps may be confounding the model due to the large variety in lyrics that will be seen at those time steps. Additionally, we lose all information about the song timing since all regions without lyrics are compressed into a single time step. In theory, gaps in lyrics could hint to the model that the next section should start a new verse or chorus.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;The TSL Pipeline&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;As suggested in the previous blogpost, we would like to be able to augment the results of the musical model with a higher quality lyrical dataset. The Kaggle lyrics dataset has shown promising results in previous blogposts at the quality of the lyric sequences it has been able to produce.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;The TSL Pipeline is a combination of three models: Timing, Seed, and Lyrics. The architecture may look something like the following diagram:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;Training&quot; class=&quot;  wp-image-333 aligncenter&quot; height=&quot;221&quot; src=&quot;https://mathstoc.files.wordpress.com/2018/05/training.png?w=531&amp;amp;h=221&quot; width=&quot;531&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;During training, each pianoroll will be separated into data representing the timing, notes and lyrics. These get passed into respective models to learn timing and “seed” information. Additional lyrics information from the Kaggle dataset is used to train a lyrical model.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;Evaluation&quot; class=&quot;  wp-image-332 aligncenter&quot; height=&quot;220&quot; src=&quot;https://mathstoc.files.wordpress.com/2018/05/evaluation.png?w=538&amp;amp;h=220&quot; width=&quot;538&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;At evaluation time, the lyrics from the original pianoroll are not passed into the Seed model. Instead, the Seed model attempts to predict some seed based on the musical content, and will pass its result into the lyrics model. The combination of these lyrics and timing information constitute the complete description of our karaoke output.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Timing Model&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;In all previous posts we ignored the issue of lyrics timing in the interest of creating a reasonable lyrical model. Our current timing model is similar to our previous model attempt, but the data is generated differently. Instead of computing a pianoroll sample at each lyrical timestep, we us a constant sampling frequency of 10 timesteps per second. We then annotate each timestep with a 1 or 0 based on if a lyric was annotated at that step. The model will then attempt to predict for each step of a given pianoroll the probability there should be a lyric at that time.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Seed Model&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;The seed model will be a simplified version of the poorly performing model from before. Instead of predicting all lyrics, it will attempt to predict a small subset of the initial lyrics. This would also allow us to create a dataset with more training examples by splitting each song into smaller samples.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Lyrics Model&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;The lyrics model will be similar to the one described in the second blog post, which is a character level RNN for generating lyrics. This will take the first few words predicted by the seed model and generate the remainder of the lyrics. Since it’s trained on the large Kaggle dataset the quality seems to be much higher than what our MIDI training has produced.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Results&lt;/h2&gt;
&lt;p&gt;As of this blog post, we are still testing various hyperparameters and waiting for models to converge.  Additional results will follow once we can examine the various output.&lt;/p&gt;</description>
	<pubDate>Thu, 10 May 2018 06:56:01 +0000</pubDate>
</item>
<item>
	<title>Ananth Gottumukkala &lt;br/&gt; Team Turing Test: Advanced Model Attempt 1 (Part 2)</title>
	<guid isPermaLink="false">http://deeplearningturingtest.wordpress.com/?p=23</guid>
	<link>https://deeplearningturingtest.wordpress.com/2018/05/09/advanced-model-attempt-1-part-2/</link>
	<description>&lt;p&gt;This week I completely finished the model end-to-end and programmed the rules of the dialogue/game. The input to the model is created as follows: the user response is broken up into individual words and converted into a matrix of word embeddings. That matrix is run through a CNN before being fed into the LSTM and finally the policy networks to compute the Q values for user actions (questions to the user) and hypothesis actions (updates to the database). The model I created closely follows the one in this paper: &lt;a href=&quot;https://arxiv.org/abs/1606.02560&quot; rel=&quot;nofollow&quot;&gt;https://arxiv.org/abs/1606.02560&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I was able to run the simulation on my computer and debug a few issues with the model before starting the actual training session. Furthermore, I moved the model to Azure, set up the SQL database on the remote computer, and am currently running the simulation on tensorflow-gpu.&lt;/p&gt;
&lt;p&gt;The initial results are not too great but somewhat promising. The model assigns +30 reward for winning, -30 for losing, -5 for bad guesses and +1 if it correctly understands the user response and performs the right action on the database. My model started out with an average of -30 reward for an entire game (it almost never took the same action that the user said and then abruptly lost) and after about 100,000 time steps that average has decreased to -23. This tells me the model is eventually learning how to understand the user responses but the convergence is still a lot slower than I expected.&lt;/p&gt;
&lt;p&gt;As a side note, while it seems silly to try classifying user responses into buckets like ‘Yes’, ‘No’, ‘Unknown’ instead of training a separate classifier, the goal is to build a model that can be generalized to more complex dialogue types where there are more nuanced actions that heavily depend on dialogue state, not just the current user response.&lt;/p&gt;
&lt;p&gt;The main difference between my model and the model in the paper (barring any bugs I am unaware of) is how the user response is represented. In both models, the model tries to combine NLU and dialog state tracking into one end-to-end model and the user response sentence representation is crucial in determining the dialogue state at any given time step. The paper creates a very short bag of bigrams feature vector (of about 30 features) from the sentence whereas I create glove vectors (embedding dimension = 50) for each word and run them through a CNN to get an output of 250-300 features.&lt;/p&gt;
&lt;p&gt;The paper made it sound like they got the model to converge and play the game well after about 120000 time steps. To play the game well, the model needs to correctly understand what action should be done on the database based on the user response. My guess is their model converges much faster and can learn to make the right action much faster than mine because of their simpler state representation. Once the model learns how to correctly interpret the user response, it becomes much easier to learn how to win from any given dialogue state. This allows the model to generalize to people it hasn’t seen because the model only learns what actions to take based on the dialogue state, not on the attributes of any given person.&lt;/p&gt;
&lt;p&gt;My goal for next week is to try tuning my model to converge faster. My main plan will be to shorten and simplify the state representation to be more like the paper’s (although it will still be different since the paper used utterance embeddings for speech, not word embeddings). If the model somehow works well after tuning, I will look into trying to train the model on more complex user responses where the set of actions to take are more qualitative than yes and no.&lt;/p&gt;</description>
	<pubDate>Wed, 09 May 2018 06:58:16 +0000</pubDate>
</item>
<item>
	<title>Halden Lin &lt;br/&gt; Team undef.: NLP Capstone | 07: Formalizing</title>
	<guid isPermaLink="false">https://medium.com/p/a2d837ecf66b</guid>
	<link>https://medium.com/@halden.lin/nlp-capstone-07-formalizing-a2d837ecf66b?source=rss-2759d54493c0------2</link>
	<description>&lt;p&gt;&lt;em&gt;previous posts: &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5&quot;&gt;&lt;em&gt;01&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5&quot;&gt;&lt;em&gt;02&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3&quot;&gt;&lt;em&gt;03&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7&quot;&gt;&lt;em&gt;04&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a&quot;&gt;&lt;em&gt;05&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0&quot;&gt;&lt;em&gt;06&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;A couple of developments since I last posted:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;I’m now more formally receiving guidance from Kanit (Ham) Wongsuphasawat and Tongshuang (Sherry) Wu of the Interactive Data Lab. Special thanks to them for helping me thus far!&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0&quot;&gt;Last week&lt;/a&gt; I was uncertain as to the future direction of this project. After much deliberation and several conversations, I’ve decided to remain on the tool-based approach originally conceived. There are a couple reasons for this. First, the user study I proposed has, at least from an NLP perspective, limited novelty. What’s more, learning from the study by modifying the underlying model would require time that would likely fall outside of the quarter. Second, carrying out this study would involve significant logistical work (again, a time constraint). Finally, in beginning to formalize this visualization tool, I’ve become more excited in its potential as a useful part of a researcher’s debugging pipeline. In any case, any model modifications I may make as part of the user study would difficult without a similar tool.&lt;/li&gt;&lt;li&gt;As mentioned, I’ve been formalizing this tool in a React application, iterating on the exploration I’ve done with prototypes in the weeks previous. The rest of this post will describe my work here.&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;Starting with Text&lt;/h4&gt;&lt;p&gt;First things first: text brushing is critical in understanding the attention each output token, or a series of output tokens, pays to the source text. In the gif below, the left side holds the source text (along with a mini-map to prevent the need of scrolling to understand the overall distribution of attention), while the right holds the summary. Selection and brushing have been implemented, as in the prototypes of last week, albeit cleaned up.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/999/1*LKOEMB1cwvp2qXRy58_-4w.gif&quot; /&gt;Cleaned up selection and brushing, in addition to a minimap for long input sequences.&lt;/figure&gt;&lt;h4&gt;&lt;strong&gt;Challenges with Text (Future Work):&lt;/strong&gt;&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;Sentence / paragraph level structure is lost via tokenizing. This is an artifact of the tokenization process performed prior to feeding text into models.&lt;/li&gt;&lt;li&gt;Lowercase and always-on spacing between tokens makes text difficult to read. For now, I’ve been dealing this with a few hand-coded rules. For example, removing spaces before punctuation, and capitalizing the first word after end of sentence punctuation.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;I’ll need to keep brainstorming to find methods for addressing these issues.&lt;/p&gt;&lt;h4&gt;How do we enable identification of patterns?&lt;/h4&gt;&lt;p&gt;While selection and brushing over the text is valuable in allowing users to understand attention for specific words or phrases, it falls short in enabling big-picture identification of patterns. Without brushing over each token and / or sentence (and memorizing coverage along the way), the closest users may get is the aggregate view (when nothing is selected) in which &lt;strong&gt;what&lt;/strong&gt; is being attended to is apparent, but not &lt;strong&gt;how.&lt;/strong&gt; That is to say, it is not apparent which tokens / phrases in the summary attend to which tokens / phrases in the source text. In particular, below is a growing list of goals for this visualization.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Enable identification of coverage&lt;/strong&gt;. For words / phrases / sentences, where is the attention being paid, and by what?&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Enable identification of missing coverage&lt;/strong&gt;. What is being unattended to that should be?&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Enable identification of extraction vs abstraction&lt;/strong&gt;. Where is copying occuring? Where is true abstraction occuring?&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;If this tool can accomplish these items, I believe it will be a good start in proving its value.&lt;/p&gt;&lt;p&gt;With this in mind, we need some sort of visualization to accompany the two blocks of text. As previously mentioned, heat-maps may not be the best solution.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*Kd4lr3ZZmOZ6ffMdp82PJg.gif&quot; /&gt;Interactive heat-map, as prototyped previously.&lt;/figure&gt;&lt;p&gt;Lag is apparent (likely a result of the large number of elements drawn), and even ignoring this, the tiles become extremely small as the input / output sequences grow, making it difficult to pick out even high attention weights. More visual weight is needed for significant attention weights, which is difficult to accomplish as x and y space is already taken by the input / output token position.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;So where else can we look?&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;Flowmaps&lt;/h4&gt;&lt;p&gt;Looking back at my project proposal, I saw this visualization made by Rikters et al. (2017).&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*uP_-gGiPkv6YMFYz.&quot; /&gt;An example of a flow-map from machine translation [Rikters et al. 2017].&lt;/figure&gt;&lt;p&gt;I thought this might be worth exploring, so I attempted to create something similar.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*SxZUaHFYssV5JtXo.&quot; /&gt;A flowmap displaying all edges is problematic. This doesn’t scale either.&lt;/figure&gt;&lt;p&gt;Unsurprisingly, there are far too many edges to display without significant overlap and occlusion. Summarization rears its head again as a challenge with its large input sequences.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;How do we remedy this?&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;One observation is that high attention weights are fairly sparse (as evident by the aggregate on the source text above). What if we filtered out these insignificant weights? A naive approach is to take the top &lt;em&gt;k &lt;/em&gt;percent of weights and display only those.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*I4jiiM98R88ZfMKz.&quot; /&gt;A flowmap showing only the top 1% of weights.&lt;/figure&gt;&lt;p&gt;The above example is displaying only the top 1% of attention weights. Edges have both their width and opacity scaled by their weight within this 1% domain. Significant (wide) weights are clearly identifiable. Thinner lines, faint (or nearly invisible) lines can also be seen, indicating that the much more significant weights have been preserved. Four distinct ‘rays’ can be seen, seemingly corresponding to the four sentence of the summary.&lt;/p&gt;&lt;p&gt;Selection and brushing seemed like intuitive follow-ups for interaction to enable more detailed / accurate pattern identification.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Selection&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1000/1*U8_42zGX24nN8iB7Wo-zPw.gif&quot; /&gt;Selection over the flowmap, both over the output nodes as well as the output text.&lt;/figure&gt;&lt;p&gt;Selection allows users to orient themselves in the flowmap, picking out which edges correspond to which input / output tokens.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Brushing&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1000/1*1t7BRJX9g2k80B67IFQ4lw.gif&quot; /&gt;Brushing over the flowmap allows for windowed pattern identification.&lt;/figure&gt;&lt;p&gt;Brushing enables accurate pattern identification. In the example above, brushing over the distinct rays allows us to see the almost entirely extractive nature of the summary — there is a clear 1:1 mapping from input to output that is implied by the clean structure of the rays, and confirmed upon inspecting the corresponding input / output tokens for these rays.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Challenges with Flowmaps (Future Work):&lt;/strong&gt;&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Selecting a top k% is not ideal — it does not generalize well.&lt;/strong&gt; In the pathological case, where attention is evenly distributed for all tokens, we lose a lot of valuable information. A potential band-aid to this is to allow users to select the percentage of weights displayed, but this may be dangerous as high percentages can crash the browser. Perhaps a more elegant solution would be to perform clustering on the weights. I’ll need to do more research here.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Overlapping paths can make reading the flowmap difficult.&lt;/strong&gt; The example shown above is fairly clean, direction flows, for the most part, in a single direction. You could imagine, however that if a summary is extremely abstractive, pulling from all over the source, there might be significant overlap in edges, decreasing legibility. A potential solution to this is edge bundling, where edges going in similar directions are pulled together to preserve pattern recognition.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;A good starting point for exploration here is the paper &lt;a href=&quot;http://vis.stanford.edu/files/2011-DividedEdgeBundling-InfoVis.pdf&quot;&gt;&lt;em&gt;Divided Edge Bundling for Directional Network Data&lt;/em&gt;&lt;/a&gt; by Selassie, Heller, &amp;amp; Heer (2011). In this, the authors describe a method for bundling, divided edge bundling, that holds characteristics I believe are important for my own visualization.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*Ma6OlxvATqGNHbyu.&quot; /&gt;Different techniques applied to a network of GitHub contributions along the west coast of the United States [Selassie, Heller, &amp;amp; Heer 2011].&lt;/figure&gt;&lt;p&gt;In the coming weeks I hope to dive into these techniques and explore their impact on the flowmap I’ve developed thus far.&lt;/p&gt;&lt;h4&gt;In Summary&lt;/h4&gt;&lt;p&gt;Still a lot of work to do! Here are my goals for the next week.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Improve flowmap visualization.&lt;/li&gt;&lt;li&gt;Find examples that cover the problem space (e.g. low coverage, abstraction, extraction).&lt;/li&gt;&lt;li&gt;Keep brainstorming.&lt;/li&gt;&lt;li&gt;Optimize code.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Things are getting interesting!&lt;/p&gt;&lt;h4&gt;References&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://ufal.mff.cuni.cz/pbml/109/art-rikters-fishel-bojar.pdf&quot;&gt;Rikters, Matīss, Mark Fishel, and Ondřej Bojar. “Visualizing neural machine translation attention and confidence.” &lt;em&gt;The Prague Bulletin of Mathematical Linguistics&lt;/em&gt; 109.1 (2017): 39–50.&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://vis.stanford.edu/files/2011-DividedEdgeBundling-InfoVis.pdf&quot;&gt;Selassie, David et al. “Divided Edge Bundling for Directional Network Data.” &lt;em&gt;IEEE Transactions on Visualization and Computer Graphics&lt;/em&gt; 17 (2011): 2354–2363.&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=a2d837ecf66b&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 09 May 2018 06:48:30 +0000</pubDate>
</item>
<item>
	<title>Aaron Johnston, Lynsey Liu &lt;br/&gt; Team Viterbi Or Not To Be: Advanced Model #1, Part 2</title>
	<guid isPermaLink="false">https://medium.com/p/d7a06e892cdd</guid>
	<link>https://medium.com/@viterbi.or.not/advanced-model-1-part-2-d7a06e892cdd?source=rss-c522ef075bb3------2</link>
	<description>&lt;p&gt;Welcome back to Advanced Model #1 and thanks for sticking with us! This week, we’ve gotten some promising results in our first advanced model attempt and made a lot of progress with the incorporation of a second data source, although there is still work to be done toward fully integrating the chatlog data into a single model. In this post, we’ll go over what we’ve done since last week and give some numbers as well as example summaries from this model, then start laying out what we would like to achieve for Advanced Model #2.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*AsUzi76WPSKaMji6.&quot; /&gt;Our project roadmap and where we are at now, highlighted in orange&lt;/figure&gt;&lt;h4&gt;&lt;strong&gt;Preprocessing&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;We decided to use preprocessing instead of features for some of the attributes of our data after discovering that our feature sets failed to focus solely on the conversation in some data types and instead gave false importance to format-specific patterns such as quoted text in emails. We eventually settled on the following distinction:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Attributes of the data that existed at the conversation-level should be features: that is, anything universally applicable to textual conversations in general was implemented as a feature for the model&lt;/li&gt;&lt;li&gt;Attributes of the data at the data source-level should be preprocessed. This allowed us to share features across different data types (for example, using tf-idf across both emails and chatlogs) while minimizing the number of “dead” features (for example, simply assigning a constant value to a feature for detecting email signatures when vectorizing the chatlog data).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The preprocessing we decided to do falls under the following categories:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Identifying format-specific content:&lt;/strong&gt; Quirks of the data format can sometimes present problems for our model, for example, we noticed separator lines composed of all dashes or symbols as well as email signatures (left example below) were making it into the summaries.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Removing quoted email text:&lt;/strong&gt; The email dataset contains quoted text of previous emails in the thread when there is an email reply, causing duplication of sentences in the summaries because the model seems to want to include the important sentence as much as possible. An example of a generated summary with the problem is in the right example below.&lt;/p&gt;&lt;p&gt;After initially parsing the data, we do this preprocessing step to identify such sentences using simple regular expression rules and remove them before computing feature vectors.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*vUpBdbFjg5Exfd-8.&quot; /&gt;An email signature (left) and quoted text (right) in generated summaries before adding preprocessing&lt;/figure&gt;&lt;h4&gt;&lt;strong&gt;Adding the Chatlog Dataset — New Pipeline&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;One of our major goals for the advanced model was to incorporate the chatlog dataset we identified early on in the project. Of course, having the capability to automatically generate summaries for chat conversations expands the usefulness and possible applications of our model: although email threads are incredibly common in today’s world, chat communication is also experiencing an incredible rise in popularity. Furthermore, as chat communications tend toward a large number of participants and a model of very frequent responses, our analysis is that chat data summaries have the potential to be even more useful than their email counterparts.&lt;/p&gt;&lt;p&gt;However, our goal with incorporating the chatlog data is ultimately to combine it with the email data in order to be able to train our model on both data types at once. To do this, we saw the need to create a common list of features that can be applied to any data input, allowing the model to train on both sources of data indiscriminately. As the Sood et. al. paper suggests, training on both sets of data has the potential to improve the resulting summaries of the model for each type of data separately, although the paper in question does not specify their results beyond the notion that they were promising in a preliminary examination.&lt;/p&gt;&lt;p&gt;The end goal for our system is illustrated below:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*YodqfIjCDfX5xJLfNG_JFQ.png&quot; /&gt;Pipeline for integrating different datasets with a common feature set into our model&lt;/figure&gt;&lt;p&gt;The blended colors represent the notion of common features, achieved through separate pre-processing and vectorizing of each data source but used in a single shared model.&lt;/p&gt;&lt;p&gt;To achieve this, we needed to do a major restructuring of our codebase, and it is unfortunately the case that a huge portion of our time this week was spent improving old code to make it more modular and compatible with these new requirements. What was once a single script to parse, process, vectorize, and train on a single dataset had to be broken apart into different modules for each of those tasks that could implement a common interface. In addition, with the growing number of options and tasks that had to be supported, we discovered it was necessary to entirely separate the concerns of processing text and handling configuration: to that end, we created a new, much more robust command-line interface and broke all other components into individual directories with as much code factoring as possible.&lt;/p&gt;&lt;p&gt;As a result of our design process and refactor, we currently have almost all of the infrastructure necessary for incorporating the chatlog data and training our model on all of the available data before evaluating on a single source. As we mentioned above, however, there were several challenges with parsing the chatlog data, namely the messy nature of the chats and the number of possible edge cases present in such a large dataset. Therefore, we are still in the process of finishing the parser component, but once it is complete we should be able to use both types of data in Advanced Model #2 and report on the impact that it makes. See our progress so far with this pipeline structure on our &lt;a href=&quot;https://github.com/viterbi-or-not-to-be/viterbi-or-not-to-be/tree/master/conversation&quot;&gt;GitHub repository&lt;/a&gt;!&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Results&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Through the addition of the preprocessing step, we have greatly improved our ROUGE scores and become competitive with the advanced model in the Sood et. al. paper. Here are the results of our advanced models, using all of the features we have discussed so far and with the preprocessing step:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*iDsZaXOhuHshbaFWXFlPvQ.png&quot; /&gt;Results of the three advanced model types&lt;/figure&gt;&lt;p&gt;These results are significantly better than our baseline, and we believe our model is generally pretty good at picking up on which sentences are important to keep! To more directly see the impact of preprocessing, we compared the results of the Naive Bayes model with and without preprocessing:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*BBrr-Z2ilFTbK8xi-t2SPg.png&quot; /&gt;Comparison between our advanced model with preprocessing and without preprocessing&lt;/figure&gt;&lt;p&gt;The model without preprocessing does decently, but the preprocessing definitely contributes significantly to our advanced model performance. To show our progress since the baseline model, this compares the results of the Naive Bayes baseline models with those of our current Naive Bayes model:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*M_zctk4dPmVbmVHeHmRYYQ.png&quot; /&gt;Comparison between our advanced model and our baselines&lt;/figure&gt;&lt;p&gt;Both ROUGE-1 and ROUGE-2 have stepped up by several percentage points, but the most significant increase is seen in the ROUGE-L improvement. Finally, our model compared with the model in the Sood et. al. paper:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*Ty7sqP2swRfdf1UGw7wb_g.png&quot; /&gt;Comparison between our advanced model and the Sood et. al. model&lt;/figure&gt;&lt;p&gt;As you can see, our ROUGE-L score is slightly lower but our ROUGE-1 and ROUGE-2 scores are higher! We’ve previously discussed the drawbacks of ROUGE―there is no definitively better type of ROUGE metric and ROUGE in general is not necessarily a reliable indicator of how good the generated summaries really are, so we are wary about quantifying our model’s performance in comparison to the Sood et. al. model’s performance based just on ROUGE scores. However, we haven’t been able to find any examples of the summaries generated by their model so this is all we have to go off of for now.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Example Summary and Analysis&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Because ROUGE provides relatively unreliable metrics for evaluation of our model’s summaries, we have also turned to human evaluation. One of the summaries that our model was able to generate based off an input email thread, using all of the preprocessing and extra features that we have built, is reproduced below in its original condition except for display-motivated truncation:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*BMVwYccbvULdQcwp.&quot; /&gt;Comparison between human annotated reference summary (left) and summary generated by our advanced model (right)&lt;/figure&gt;&lt;p&gt;This summary is fairly representative of the summaries that are being generated, and compared to the results we saw from our baseline models it is clearly doing better in terms of human evaluation. The sentences highlighted in green are those that are shared between the reference annotation and our system’s generated summary — interestingly, all but one of the sentences in the reference summary were successfully captured by our system. Therefore, reading through the summary generated by our system gives a strong impression of the topics that were discussed in the thread, and seemingly gives a human reader all the information that is needed.&lt;/p&gt;&lt;p&gt;However, there are certainly aspects of the current summaries produced by the model that are lacking. In the summary given above, all 6 sentences that were truncated for display purposes at the ellipsis and the four additional non-green sentences displayed were not included in the reference summary. This summary comes from a thread with only 31 sentences after preprocessing, meaning that while our model successfully captured all of the sentences marked as important by a human, it did so at the cost of incorporating an enormous percentage of unnecessary extra text that serves to make the summary less of a “summary” while adding relatively little content. To address this, we will need to figure out how to reward the model for producing more concise summaries, or to incorporate a “compression factor” that allows producing a summary with the k most relevant sentences for some value of the hyperparameter k. Another issue is highlighted in red above — while we added preprocessing to remove email signatures based on a set of heuristics, to avoid deleting important content we made the preprocessor act conservatively when uncertain, and as a result some signatures like in the example above made their way into the summaries. Although other features would ideally prevent these signatures from appearing in many cases, we will need to improve our preprocessing heuristics in order to target these kinds of medium-specific text examples before moving on to incorporate additional types of data.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Next Steps&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;To entirely finish Advanced Model #1, we would like to complete the process of incorporating chatlog data and then transition into work on Advanced Model #2 by continuing to explore and add conversation-specific features. We also want to address the excessive lengthiness problem we found in the generated summaries by doing something to limit the number of sentences the model is allowed to select for the extractive summary.&lt;/p&gt;&lt;p&gt;Beyond these immediate steps, we would love to be able to take a stab at abstractive summarization! It’s a really challenging but rewarding conversation summarization problem that we will need to put some more thought into to attempt. We’ve preliminarily determined that we can make an attempt using the extractive output from our current model along with some other contextual metadata from the conversation data (for example, authors of the chosen sentences), to get a start on an abstractive summary. In general, we think this will require more modeling of entity relationships and text generation.&lt;/p&gt;&lt;p&gt;Overall, we’re excited with what our model has been able to do so far and optimistic about what we’ll be able to achieve with Advanced Model #2, so stay tuned!&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=d7a06e892cdd&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 09 May 2018 06:33:15 +0000</pubDate>
</item>
<item>
	<title>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde: Advanced Model Attempt #1 (Act 2 Scene 1)</title>
	<guid isPermaLink="true">http://sarahyu.weebly.com/cse-481n/advanced-model-attempt-1-part-21</guid>
	<link>http://sarahyu.weebly.com/cse-481n/advanced-model-attempt-1-part-21</link>
	<description>&lt;div class=&quot;paragraph&quot;&gt;This week, I had to do a little backtracking and restructuring, but all for the better! &lt;ul&gt;&lt;li&gt;More Data! I have had a couple jobs still running that has allowed me to have more reddit data to work with overall, which is especially good news for the next advanced model&lt;/li&gt;&lt;li&gt;Subreddit ReOrg - A large portion of this week has been on identifying different subsets for the neurodivergent and neurotypical groups. In conversation with Maarten, we discussed that the subreddits in the current state are a bit too broad to address the hypotheses and may not produce a focused language model that makes sense. Currently, the neurodivergent group is a broad strokes grouping of all types of differences. With that in mind, I spent some time researching, following some Reddit rabbit holes, and learning about ICD 10 &lt;font color=&quot;#515151&quot;&gt;(International Statistical Classification of Diseases and Related Health Problems (ICD), a medical classification list by the World Health Organization (WHO)) to classify the subreddits and the mental illnesses they speak to. Among these topics, we specifically wanted to look at the the two 'Blocks' - Mood (affective) disorders and Neurotic, Stress-Related and Somatoform disorders. This would be defined as the new 28 subreddits constituting the neurodivergent set, and the 22 neurotypical subreddits are those that are general advice, community support, or discussions on mental health, broadly speaking. These were chosen from the initial ND set because while some of them discussed mental health and neurodiversity, they were open to more than just users dealing with mental health related issues. They had similar types of posts where people are more open and discussing in detail their personal lives, a kind of venting space. And choosing from this group rather than to look at more general reddit, was a decision made so that I could find the nuances rather than the more general difference seen in discussing psychology and not. Despite the significant reduction of subreddits (from 126 to 28 ND and 100 to 22 NT), the data collection I mentioned above has resulted in 5x the original vocabulary size and we now have a combined 1 million words in the newest set (being added to as we speak)&lt;/font&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;With that, I was able to run the previous vennclouds and idp models (and Act 2 Scene 2, before next week will hopefully include the Connotation Frames model results). For the vennclouds, I think we see some similarity from before of the &quot;my/me/I&quot; terms speaking in first person, but the NT posts has more discussion of a second person or a more general reference to an other or friends. It might also be useful to find a list of prepositional phrases to remove and to find something more interesting in the venn diagram middle portion. &lt;/div&gt;  &lt;div&gt;&lt;div class=&quot;wsite-image wsite-image-border-none &quot; style=&quot;padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;&quot;&gt; &lt;a&gt; &lt;img alt=&quot;Picture&quot; src=&quot;http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-05-09-at-2-32-31-am_orig.png&quot; style=&quot;width: auto;&quot; /&gt; &lt;/a&gt; &lt;div style=&quot;display: block; font-size: 90%;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;  &lt;div class=&quot;paragraph&quot;&gt;&lt;br /&gt;I also ran the IDP model from before and found the following top categories:&lt;br /&gt;&lt;strong&gt;ND&lt;/strong&gt;&lt;br /&gt;&lt;em&gt;I/&lt;span&gt;my/&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;me/myself&lt;/em&gt; - the personal discussion makes sense, but I'm a bit curious as to why it would be more prevalent than in the other discussion forums that are also predominantly venting spaces focused on the self seeking the community. &lt;/span&gt;&lt;br /&gt;&lt;em&gt;anxiety/depression/OCD&lt;/em&gt; - these are the subreddit categories we basically chose&lt;br /&gt;&lt;em&gt;feel/feeling &lt;/em&gt;- I was surprised to see a significantly higher mention of feeling in the ND categories despite the other subreddits still being communities discussing mental illness along with the larger public in discussing general problems &lt;br /&gt;&lt;br /&gt;&lt;strong&gt;NT&lt;/strong&gt;&lt;br /&gt;&lt;em&gt;you / his/he/him / girls/she/her - &lt;/em&gt;This is a bit surprising given that I had made a bit of a fuss around the female mentions being significantly higher in the ND categories. I'm interested to see what this shift might mean, but even more so, I think the discussion of another is an interesting contrast between the two that might be better suited for the connotation frames results that I hope to do in the next couple of days. &lt;br /&gt;&lt;em&gt;https&lt;/em&gt; - links are back! But more interestingly, while they were prevalent in the original NT group, which we hypothesized were due to the higher proportion of anecdotal advice in the ND categories, it seems that even in regards to discussions around mental illness, people bring in outside links and whatnot to advise, or uplift other users. &lt;br /&gt;&lt;br /&gt;Next Steps: As I mentioned above, I'd like to run this same new and larger dataset with the connotation frames model. Beyond that, I'd like to spend the next two weeks working on either implementing a SAGE log-linear model to describe these language models, or a deep learning model. If possible, I hope to also get the graphical model going &lt;br /&gt;&lt;br /&gt;&lt;/div&gt;</description>
	<pubDate>Tue, 08 May 2018 07:00:00 +0000</pubDate>
</item>
<item>
	<title>Aaron Johnston, Lynsey Liu &lt;br/&gt; Team Viterbi Or Not To Be: Advanced Model #1, Part 1</title>
	<guid isPermaLink="false">https://medium.com/p/4626fe37cadb</guid>
	<link>https://medium.com/@viterbi.or.not/advanced-model-1-part-1-4626fe37cadb?source=rss-c522ef075bb3------2</link>
	<description>&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*_Pn2CYQZkoIzZYLwVPV2MA.png&quot; /&gt;&lt;/figure&gt;&lt;p&gt;Work on our advanced model is underway! To recap, we aim to upgrade our baseline model by including other forms of conversational data (chatlogs and meeting transcripts in addition to the email data we have been using) into our training and adding features that target characteristics specific to conversational text.&lt;/p&gt;&lt;h4&gt;Extensibility and Other Datasets&lt;/h4&gt;&lt;p&gt;To achieve this, we first worked on restructuring our baseline code to be extensible to allow addition of inputs from other datasets and to allow different methods of feature extraction based on the dataset. We’ve started splitting our baseline code into smaller parts (parser, feature extractor, model) and creating a structure for the new code segments and datasets. We’ve also parsed one additional data type (GNUe chatlogs) and begun the process of integrating the data into the structure. Unfortunately, we have not yet been able to produce summaries using this dataset — while we have the parser working, several of our features and evaluation scripts do not translate easily to the new formatting and we are still working on refactoring our codebase to handle it. As we complete our first advanced model, bringing these new data sources into the fold will be a top priority so that we can begin to compare the differences between the dataset and work toward our stretch goal of training on both datasets in order to improve performance on each.&lt;/p&gt;&lt;h4&gt;Preprocessing&lt;/h4&gt;&lt;p&gt;Looking at the generated summaries from our baseline model, we found a few mistakes that could be easily avoided using automated preprocessing. The summaries often included quoted replies, email signatures, and other insignificant lines that could be eliminated by looking at simple characteristics of the sentence (for example, a line or sentence ending in a comma usually indicates that it is a greeting or closing clause). We previously added a feature based on the sentence starting with a ‘&amp;gt;’ character to eliminate sentences that were quotes from previous emails in the thread, which improved performance. We are now moving this to the preprocessing step. The preprocessing will occur during after parsing the dataset, but before feature extraction, and because it is highly specific to the types of data we are parsing it will have to be implemented separately for both email and chat data.&lt;/p&gt;&lt;p&gt;Another addition we have been looking into has been detection of email signatures. While we have not yet created a very successful system for this, we have some ideas on how to proceed as we finish our first advanced model. We have already tried adding a feature for a sentence’s proximity to the end of an email, but unfortunately it was not very successful in removing signatures. Therefore, we are hoping that preprocessing will fit the task better — for example, we might examine the email for the last contiguous block of non-empty lines, and remove them under the assumption that the email signature will always be at the end and will never be useful in a summary. But this comes with its own challenges, as some emails in the dataset (and in general use) do not have a signature, and thus the last contiguous block might be content or even the entire email in some cases. One idea we have to combat this would be application of a language model to the sentences in a contiguous chunk. If a language model (such as an n-gram model) were trained on the English language and exhibited a high perplexity when looking at a given sentence, it might be safe to say that it is not prose and is instead a collection of names, emails, or organization names as one might expect to see in a signature. Be sure to check back in our Part 2 blog post after we have implemented this preprocessing and reported on the results!&lt;/p&gt;&lt;h4&gt;Conversation-Specific Features&lt;/h4&gt;&lt;p&gt;We started our foray into conversation-specific features with the those listed in the complete features set (beyond the basic set in our baseline) in the Sood et. al. paper, before expanding upon this set with our own contributions that target email data specifically. So far, we’ve implemented the following features based on the paper —&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Is Question:&lt;/strong&gt; Important issues and concerns are often expressed in the form of questions. To take advantage of this idea, this feature represents whether or not (1 or 0) the sentence is a question. When training using this feature, we found that&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Sentiment Score: &lt;/strong&gt;Based on the idea that strong sentiments and opinions are important to a conversation, this feature captures the sentiment of a sentence. The score is determined by taking the difference between the positive and negative and score for each word in the sentence, then adding up the scores of all the words in the sentence and normalizing by the number of words in the sentence.&lt;/p&gt;&lt;p&gt;In addition to the features in the Sood et. al. paper, we came up with some more feature ideas based on our error analysis of the baseline model —&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Numbers:&lt;/strong&gt; Even with the ‘Special Terms’ feature, our baseline model often missed lines containing numbers or statistics that we would want to preserve in a summary because they were short or eliminated by the importance of other features. In order to address this shortcoming, this feature uses a simple regular expression mechanism to determine the occurrences of numeric data in a sentence.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;URLs:&lt;/strong&gt; The baseline model also often missed URLs, which are typically important information and usually contained in the summary annotations of the dataset. This feature would address this problem by using a regular expression to determine how many URLs are contained in the sentence.&lt;/p&gt;&lt;h4&gt;Results&lt;/h4&gt;&lt;p&gt;At first, we tested the features that were described in the Sood et. al. paper, evaluating them on the Naive Bayes model that we had found to be most generally successful in our previous baseline experimentation. As corroborated by the paper’s findings, we discovered that these features were somewhat impactful in improving the performance of our model, at least as far as ROUGE scores were concerned:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*X9KXUGGowXEptmVn3kv-jg.png&quot; /&gt;Results of the model with the conversation-specific features from Sood et. al. compared with the baseline&lt;/figure&gt;&lt;p&gt;Noticeably, the addition of these conversation features was strictly better for ROUGE evaluation. Both the question feature and sentiment feature were roughly equivalent, although we noticed that when we subjected the summaries to human evaluation it was easier to notice an improvement from the question feature. Many of the important sentences in the reference summaries seem to have been questions, perhaps because asking a question is such a common way to transition to a new topic in an email thread. As a result, we found that this feature helped populate our summaries with many of the questions from the reference summaries, establishing clear boundaries. Even if some of the sentences in our summaries were less impactful, having the questions made a big difference for a human reader because it was possible to get the general idea of the thread from the questions alone. As an example, this is one of our generated summaries, compared with a reference:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*ONLBMtMpzebsdPUa1AzWBQ.png&quot; /&gt;Comparison of reference summary (left) to our generated summary (right) using the Is Question feature&lt;/figure&gt;&lt;p&gt;It is noticeable that the questions add a significant amount of relevance to our summary, although there is still work to be done as far as capturing the shorter, choppier, but still more important non-question sentences.&lt;/p&gt;&lt;p&gt;However, because another significant goal of our advanced model is to explore other conversation-specific features not addressed in the research paper, we did some additional exploration on our own to find features that could take our model’s performance beyond the results of Sood et. al., even if only for email data. So far, we have found two that improved our ROUGE metrics while also seeming to make more relevant summaries by detecting numbers and detecting URLs in a given sentence. Our results are as follows:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*xiga8kKb3O5cYHYP2sDbTQ.png&quot; /&gt;Results of the model with our conversation-specific features compared with the baseline&lt;/figure&gt;&lt;p&gt;Using the numbers feature in particular, we found that our model was able to outperform the baseline considerably, although upon human examination we had trouble determining exactly why this had happened as the summaries did not capture that many numbers. However, as far as human examination went, we discovered that the URL feature made a clear impact, adding a considerable number of important URLs to our summaries that had originally been passed over by the model even though human annotators had marked them as being especially important.&lt;/p&gt;&lt;p&gt;Finally, we tried all of these new features together to see how they compared to the baseline:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*l7tr_T6H5jnqWRbSf7NeGA.png&quot; /&gt;Results of the model with the all of the additional features discussed compared with the baseline&lt;/figure&gt;&lt;p&gt;Ultimately, while these features were relatively few in number, their use of conversation-specific data clearly led to a great deal of performance increase for our model.&lt;/p&gt;&lt;h4&gt;Next Steps&lt;/h4&gt;&lt;p&gt;For Part 2 of our advanced model, we would like to finish restructuring and incorporating the other datasets into our model input. Because one of our stretch goals is to be able to find a way to incorporate multiple types of data into a single model, we are hoping to do this in a way that allows us to compute the same (or at least similar) features for each type of data.&lt;/p&gt;&lt;p&gt;Another goal is to implement the preprocessing steps described above as a part of dataset parsing. Significantly, there are some advanced preprocessing techniques described by the Sood et. al. paper that deal with chat data specifically, so we hope to incorporate those once the chat data is working correctly. Finally, we want to continue adding features — although it is certainly unlikely that all of the features we try will be as successful as the ones described above, we hope that this project will culminate in a thorough examination of the impacts that various features can make, so we will continue to explore in this regard as we finish up our first advanced model.&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=4626fe37cadb&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Thu, 03 May 2018 06:56:41 +0000</pubDate>
</item>
<item>
	<title>Halden Lin &lt;br/&gt; Team undef.: NLP Capstone | 06: Uncertainty</title>
	<guid isPermaLink="false">https://medium.com/p/6f773ae418d0</guid>
	<link>https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0?source=rss-2759d54493c0------2</link>
	<description>&lt;p&gt;previous posts: &lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5&quot;&gt;01&lt;/a&gt; &lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5&quot;&gt;02&lt;/a&gt; &lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3&quot;&gt;03&lt;/a&gt; &lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7&quot;&gt;04&lt;/a&gt; &lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a&quot;&gt;05&lt;/a&gt;&lt;/p&gt;&lt;p&gt;I’ve begun to realize I may not be getting as much out of the project I chose I had hoped. My initial motivation for my project was a hope of expanding my knowledge and developing insights on the NLP front by leveraging the familiarity of Visualization. While I am certainly learning a lot by reading papers on Attention and Neural Networks as a whole (especially through my in-class paper presentation), I feel the work I am doing in building a tool for visualizing and debugging attention models may not be providing me the space to explore NLP that I had hoped for. While the tool will certainly &lt;strong&gt;enable &lt;/strong&gt;exploration, my concern is that this exploration will not occur until after the tool is completed at the end of the quarter.&lt;/p&gt;&lt;p&gt;The good news is that there have been two recent developments that, while increasing my uncertainty, offer potential for greater depth in exploration along the NLP front.&lt;/p&gt;&lt;h4&gt;1. Potential Pivot&lt;/h4&gt;&lt;p&gt;I voiced these concerns with Prof. Choi this past week and was given a good amount of valuable advice. Per her suggestion, the beginning of my last cycle began with three tasks.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Read &lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2470718&quot;&gt;&lt;em&gt;The Efficacy of Human Post-editing for Language Translation&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;authored by&lt;em&gt; &lt;/em&gt;Spence Green, Jeff Heer, and Christopher Manning. This paper is unique in that it presents the value of Visualization and HCI within Natural Language Processing, but not as a window into a model. Rather, the authors explore a specific task integral to the Language Translation pipeline and present suggestions for future work in improving Language Translation.&lt;/li&gt;&lt;li&gt;Do in-depth human error-analysis of existing summarization models. I used examples from See et al.’s paper &lt;em&gt;Get To The Point: Summarization with Pointer-Generator Networks &lt;/em&gt;(2017).This was helpful gaining a better intuition as to the problem space and the challenges currently posed by machine summarization.&lt;/li&gt;&lt;li&gt;Think about how summarization as a task, whether that be the development of models, the model’s task itself, or end-user tasks that use the model, can be re-framed in order to leverage Visualization. This was especially time consuming, as it was difficult for me, but it helped immensely in taking a step back to understand the purpose of these models. This, in turn, helped me understand how my work can fit into this purpose.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The next few days consisted largely of brainstorming pivots for my project. The most promising direction that came out of these sessions is very briefly outlined below.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Assisted Cognitive Document Abstraction&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Machine-generated document summaries, even the state-of-the-art, are infrequently used in practice because their summaries are quite poor. Perhaps we can leverage existing models to, rather than produce definite summaries which may be error-prone or difficult to understand, create visualizations over the source text in order to assist humans in comprehension and abstraction.&lt;/p&gt;&lt;p&gt;For example, instead of treating attention weights as input for an output of text, as we do in summarization models, we can view them as output for human interpretation. Aggregate attention distributions (in summarization) highlight areas of the input text that are salient for the summary produced. Note that this is potentially more valuable than highlighting extractive summaries in the text because attention could potentially point towards different areas of the text that relate to a summary sequence. In this way, generation of summaries becomes a proxy task for creating salient highlights for text. We could then use this as a starting point from which ‘related’ sections in an article may be highlighted for users upon interaction (e.g. mousing over an attended-to sequence).&lt;/p&gt;&lt;p&gt;The hope is that these visualizations will increase the speed (over no summarization) or accuracy (over machine summarization) at which readers can abstract / understand key ideas in a document.&lt;/p&gt;&lt;p&gt;Most excitingly, with this re-framing of the task for these models, from sequence output to highlighting, perhaps the models can be modified by adding or removing constraints and mechanisms in order to improve performance for this new task.&lt;/p&gt;&lt;p&gt;Upon presenting this idea (in longer form) to Prof. Choi, I was encouraged to (1) think more about weaknesses of removing summaries altogether and (2) push for more novelty in the approach — is there any meaningful insight about attention models or summarization as a task that can be gleamed from this pivot, and if not, how can I work towards that. While I do not yet have answers to these concerns, the next development may result in a few.&lt;/p&gt;&lt;h4&gt;2. Related work, here at the Allen School&lt;/h4&gt;&lt;p&gt;It was just recently brought to my attention that a Tongshuang (Sherry) Wu, a PhD student in the Interactive Data Lab (in which I am currently working), is also working on visualizations for understanding attention models in NLP. As a part of her project, she and a few of her peers have developed a preliminary visualization tool for an attentive QA model (on the SQuAD dataset).She and my mentor, Kanit (Ham) Wongsuphasawat (whom I have been bouncing ideas off recently), have kindly offered to meet and discuss her work and insights on the problem space. Perhaps collaboration is a possibility — this is exciting! In any case, I suspect talking with Sherry and Ham will provide me the insight and guidance to make a decision on the direction of my project.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Future Work&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;I hope to make another blog post in the coming few days as I iron out a future direction. Before this, however, future work is unclear. Until next time!&lt;/p&gt;&lt;h4&gt;In the meanwhile (supplementary material)&lt;/h4&gt;&lt;p&gt;I’ve also been playing around with my visualization prototypes, even as I am uncertain as to whether or not they will be relevant to my project after this week. Here’s what I’ve discovered and implemented in that time.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Interactive heat-maps likely won’t work.&lt;/li&gt;&lt;/ol&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*_bVKvDPn6jBADKwFU9VG3g.gif&quot; /&gt;Interactive heat-maps result in a large degree of lag between input and visual update. This is likely due to the extremely large size of the attention matrix in summarization (24,000 individual squares in the heat-map).&lt;/figure&gt;&lt;p&gt;This is unfortunate, but browser limitations are limitations that must be worked around.&lt;/p&gt;&lt;p&gt;2. Selection over output text.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/999/1*KfMQd6YnDzdH9dZOyjVEIw.gif&quot; /&gt;Mousing over words in the summary results in a view of the attention distribution over the article for that decoder time-step.&lt;/figure&gt;&lt;p&gt;This is similar to the interactive visualizations presented by See et al. in their &lt;a href=&quot;http://www.abigailsee.com/2017/04/16/taming-rnns-for-better-summarization.html&quot;&gt;blogpost&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;3. Brushing over output text.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1000/1*nwGIF3VgNDeuFxRml8gGzg.gif&quot; /&gt;Brushing over the summary results in an aggregate attention distribution (i.e. coverage) over the article for the selected decoder time-steps.&lt;/figure&gt;&lt;p&gt;This is an interaction technique I have yet to see in work involving attention analysis, so this is exciting! It looks to be somewhat useful in identifying sections of input text that are salient to an &lt;strong&gt;idea&lt;/strong&gt; rather than a &lt;strong&gt;single word&lt;/strong&gt; in the output text.&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=6f773ae418d0&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 02 May 2018 06:59:16 +0000</pubDate>
</item>
<item>
	<title>Ananth Gottumukkala &lt;br/&gt; Team Turing Test: Advanced Model Attempt 1 (Part 1)</title>
	<guid isPermaLink="false">http://deeplearningturingtest.wordpress.com/?p=21</guid>
	<link>https://deeplearningturingtest.wordpress.com/2018/05/02/advanced-model-attempt-1-part-1/</link>
	<description>&lt;p&gt;This week I created and populated my SQL database with the birth year, birth place, industry, gender, profession, and continent information corresponding to 100 random famous people spanning across all time periods. Furthermore, I created a little over 30 questions that the model can ask as well as the corresponding SQL queries for each question. During each game for the simulation, the user will randomly pick a person for the model to guess and the model picks from a list of these questions to ask. Then, the query corresponding to this question is used to extract the truth value of the question from the database (Yes, No, Unknown). This answer is used as the response to simulate a real person giving that answer through user input. Now that the code has been written to interact with the database, the model can now fully create the observation at any point, which is the input vector to the DRQN. Next, I will hardcode the sample rewards as well as the rules of the game (maximum 20 questions, rewards for winning/losing/wrong guess, terminating game, etc.). This week I will be focusing on getting the simulation to run end-to-end, use tensorflow-gpu, and do hyperparameter tuning.&lt;/p&gt;</description>
	<pubDate>Wed, 02 May 2018 06:38:52 +0000</pubDate>
</item>
<item>
	<title>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde: Advanced Model Attempt #1 (Act 1)</title>
	<guid isPermaLink="true">http://sarahyu.weebly.com/cse-481n/advanced-model-attempt-1</guid>
	<link>http://sarahyu.weebly.com/cse-481n/advanced-model-attempt-1</link>
	<description>&lt;div class=&quot;paragraph&quot;&gt;The first part of implementing my advanced model attempt was to work on implementing the IDP Algorithm presented in  Monroe, B. L., Colaresi, M. P., &amp;amp; Quinn, K. M. (2008). &lt;em&gt;Fightin' words: Lexical feature selection and evaluation for identifying the content of political conflict. &lt;/em&gt;&lt;font size=&quot;2&quot;&gt;Political Analysis, 16(4), 372-403. &lt;/font&gt;&lt;br /&gt;&lt;br /&gt;In doing so, I was able to find the weighted log odds ratio of each word present in both ND and NT posts, ultimately showing which type of subreddit each word was 'more affiliated' with. The findings were as one might expect, especially with my previous baselines and were in line with the results from those. As seen below we see some familiar words within the ND (I, you, &lt;strong&gt;she&lt;/strong&gt;​) and NT (http) - so sorry for the ugly terminal output, but I need to find a prettier CSV presentation:&lt;/div&gt;  &lt;div&gt;&lt;div class=&quot;wsite-multicol&quot;&gt;&lt;div class=&quot;wsite-multicol-table-wrap&quot;&gt; 	&lt;table class=&quot;wsite-multicol-table&quot;&gt; 		&lt;tbody class=&quot;wsite-multicol-tbody&quot;&gt; 			&lt;tr class=&quot;wsite-multicol-tr&quot;&gt; 				&lt;td class=&quot;wsite-multicol-col&quot; style=&quot;width: 50%; padding: 0 15px;&quot;&gt; 					 						  &lt;div&gt;&lt;div class=&quot;wsite-image wsite-image-border-none &quot; style=&quot;padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;&quot;&gt; &lt;a&gt; &lt;img alt=&quot;Picture&quot; src=&quot;http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-05-02-at-12-42-36-am_orig.png&quot; style=&quot;width: auto;&quot; /&gt; &lt;/a&gt; &lt;div style=&quot;display: block; font-size: 90%;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;   					 				&lt;/td&gt;				&lt;td class=&quot;wsite-multicol-col&quot; style=&quot;width: 50%; padding: 0 15px;&quot;&gt; 					 						  &lt;div&gt;&lt;div class=&quot;wsite-image wsite-image-border-none &quot; style=&quot;padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;&quot;&gt; &lt;a&gt; &lt;img alt=&quot;Picture&quot; src=&quot;http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-05-02-at-12-43-09-am_orig.png&quot; style=&quot;width: auto;&quot; /&gt; &lt;/a&gt; &lt;div style=&quot;display: block; font-size: 90%;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;   					 				&lt;/td&gt;			&lt;/tr&gt; 		&lt;/tbody&gt; 	&lt;/table&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;  &lt;div class=&quot;paragraph&quot;&gt;This was a good first step, and will need some more work hashing out some final implementation details, but my next step in making this an actual advanced model, is to now utilize some of that reddit data that I've been harvesting for the past week or so. With that, we have a lot more data and might need to make some changes on the subreddit subsets depending on how the data has developed (changes in sentence length and number of total number of posts in each subreddit). Off to more data!!!&lt;/div&gt;</description>
	<pubDate>Tue, 01 May 2018 07:00:00 +0000</pubDate>
</item>
<item>
	<title>Ananth Gottumukkala &lt;br/&gt; Team Turing Test: Strawman/Baseline 2: Same DRQN Model with a Different Policy</title>
	<guid isPermaLink="false">http://deeplearningturingtest.wordpress.com/?p=18</guid>
	<link>https://deeplearningturingtest.wordpress.com/2018/04/26/strawman-baseline-2-same-drqn-model-with-a-different-policy/</link>
	<description>&lt;p&gt;I decided to narrow the scope of my problem by changing the types of questions asked to the user to be only yes/no questions. This simplifies interpreting the user response into a classification task. More specifically, the questions will be about figuring out the attributes of any entities brought up in the text.  Therefore, I will use a relational database to store the accumulated entity-attribute relationships instead of a semantic network since it will be easier to extract quantifiable features by performing specific queries. In addition to asking the user questions, I decided to involve database queries in the training process. This way the model can query the database about any inferences or guesses it has about the attributes of an entity, and the database can return a list of entities that fit the hypothesis. Then, the model is given a reward based on how much it was able to narrow down the list of entities. This allows the model to get frequent reward signals from the database to speed up training.&lt;/p&gt;
&lt;p&gt;Because of this change, my model architecture has also changed. The DRQN will now take as inputs the action from the previous time step (one-hot vector), the user response (word embeddings passed through CNN), and the database response (number of entities the previous query narrowed it down to). In addition, the outputs to the LSTM at each time step will feed into A+1 policy networks where A = number of attributes. The first A policy networks are needed because the model needs to learn how to guess each attribute independently. The last policy network determines which question the model will ask the user. So far I have implemented most of this architecture but still need to add in the policy networks and debug.&lt;/p&gt;
&lt;p&gt;Finally, I will implement a question simulator to randomly pick an entity and have the model guess what it is, similar to 20 questions. During this simulation, rewards will be automatically given every time the model queries the database and whenever the game ends (win or loss). Furthermore, a small penalty is given for a wrong guess. By implementing this simulator, the need for user input to give rewards is eliminated and this should completely automate and greatly speed up training.&lt;/p&gt;
&lt;p&gt;My goal for next week is to finish implementing and debugging the model to start this training simulation.&lt;/p&gt;</description>
	<pubDate>Thu, 26 Apr 2018 06:58:22 +0000</pubDate>
</item>
<item>
	<title>Halden Lin &lt;br/&gt; Team undef.: NLP Capstone | 05: Experimenting</title>
	<guid isPermaLink="false">https://medium.com/p/306dca636d3a</guid>
	<link>https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a?source=rss-2759d54493c0------2</link>
	<description>&lt;p&gt;&lt;em&gt;previous posts: &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5&quot;&gt;&lt;em&gt;01&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5\&quot;&gt;&lt;em&gt;02&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3&quot;&gt;&lt;em&gt;03&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7&quot;&gt;&lt;em&gt;04&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Hi! Here’s what I’ve been up to in the past week.&lt;/p&gt;&lt;h4&gt;Progress on the TensorBoard Plugin&lt;/h4&gt;&lt;p&gt;Real data collection and the backend are functioning!&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/800/1*l6M8uMcswVoaEtL0_HGt0w.png&quot; /&gt;Architecture of the Attention Plugin.&lt;/figure&gt;&lt;p&gt;At this point last week, I had implemented the nodes in green above. These were the operators / functions required to produce Summary protobufs that are in turn saved to disk.&lt;/p&gt;&lt;p&gt;This week, I completed a number of tasks to produce a bare-bones functioning plugin (sans visualizations).&lt;/p&gt;&lt;p&gt;First, I modified the source code for &lt;a href=&quot;https://github.com/abisee/pointer-generator&quot;&gt;See et al.’s (2017) attentional models&lt;/a&gt; to use the Attention Plugin API to save input text, output text, and attention distributions during evaluation.&lt;/p&gt;&lt;p&gt;Next, I implemented the Attention Plugin’s back-end, which is used to fulfill requests made by the front-end. This service currently offers two services:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;tags This route returns all tags associated for each run in the log. This should include 3 tags for each run: one for each of the input, output, and attention tensors.&lt;/li&gt;&lt;li&gt;attention This route returns a list values associated with the given tag (including time and step stamps). This can be used by the front-end to acquire each of the input, output, and attention lists (converted from tensors) by passing the corresponding tag (retrieved using the tags route).&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Finally, as a proof of concept, I modified the front-end provided in the &lt;a href=&quot;https://github.com/tensorflow/tensorboard-plugin-example&quot;&gt;TensorBoard Plugin Example&lt;/a&gt; to consume this back-end, showing it is able to retrieve summaries. Now we just need some visualizations to consume the data!&lt;/p&gt;&lt;h4&gt;Visualization Prototyping Begins&lt;/h4&gt;&lt;p&gt;While data collection and back-end development has been wrapping up, I’ve begun to prototype static visualizations for the plugin. To do this, I used data produced by &lt;a href=&quot;https://github.com/abisee/pointer-generator&quot;&gt;See et al.’s (2017) pre-trained attentional models&lt;/a&gt; (produced only at decode time without the Attention Plugin). Through this process, I hope to gain two things in particular.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;A idea of what will/won’t work as visualizations for summarization tasks.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;A better understanding of the behavior of attentive models&lt;/strong&gt;, and through that a better idea of how static and/or interactive visualizations can further interpretability and understanding.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The first idea I decided to pursue was that of a &lt;strong&gt;condensed heat-map&lt;/strong&gt;. You may recall the conventional heat-map used for attention visualizations described in &lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5&quot;&gt;my first blog post&lt;/a&gt;.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/612/1*_sq2Vy_Py7hEXp2tWBBXxg.png&quot; /&gt;Rikters et al. (2017). A heat-map with relatively large cells, allowing for display of text along the axes.&lt;/figure&gt;&lt;p&gt;The issues I noted with this visualization pattern are as follows:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;It is difficult to fit the words (as seen above) on the x-axis, harming readability.&lt;/li&gt;&lt;li&gt;This does not scale well with large input or output (e.g. summarization)&lt;/li&gt;&lt;li&gt;We do not read single-tokens at a time (i.e. y-axis), and input and output are generally not in this format either.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;To address the point (2), scalability, I decided to try producing a heat-map with no text labels, and thus each cell could be as small as a single pixel.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*WOlVYgmeZ0DmutTZkDXn2g.png&quot; /&gt;A prototype of a condensed heat-map, where x-axis represents input and y-axis represents output.&lt;/figure&gt;&lt;p&gt;The color scale is a discrete scale, where each step is determined by the quantiles of the weight distribution. The x-axis represents the input text, and the y-axis represents the output text, with each cell representing the amount of attention paid for that pair (output paid to input). The good news here is that the attention distribution is relatively easy to understand at a quick glance. The downside is that cells that are not part of a larger trend (you may notice a lone red spot near the top of the heat-map, approximately a quarter of the way through the x-axis) are harder to make out, as the cells are so small. Further, the distribution is contextless — we don’t know the structure of the input text or what words these high weights are associated with. In the example above, we understand that the model focused primarily on the beginning of the article, but we can’t tell whether that is good or bad without seeing the text.&lt;/p&gt;&lt;p&gt;To remedy this, I decided to also display the input text, with the input text highlighted according to the maximum of the weights it received. This also solves concerns (1) and (3) for the conventional heat-map.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*dJXS9s_391dACPuUwAgPmA.png&quot; /&gt;The input text corresponding to the heat-map above, where each token is highlighted according to its max attention weight received.&lt;/figure&gt;&lt;p&gt;By putting these two together (along with the output text for reference), we can gain a better understanding of how the model arrived at its summary. A viewer can now map the attention distribution shown in the heat-map to text in the input sequence by looking for patches of similar color intensity.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*dMqdcl01Za5U4nYrXpye6g.png&quot; /&gt;A prototype static visualization including both heat-map and highlighted text.&lt;/figure&gt;&lt;p&gt;To get a better sense of how this visualization pattern would play out, I built a light web-page that allows users to cycle through different input / output examples. The gif below shows several of these.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/800/1*_ACE44hvUSrwfE3F04gslg.gif&quot; /&gt;The described visualization pattern over several input / output sequences.&lt;/figure&gt;&lt;p&gt;More exploration (inside and outside of this pattern) will need to occur, but this seems promising!&lt;/p&gt;&lt;h4&gt;What’s Next&lt;/h4&gt;&lt;p&gt;Lots to get done this next week. Here’s what’s in my plan:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Continue working on data collection and cleaning up the TensorBoard plug-in. Move beyond the proof-of-concept front-end and show that meaningful visualizations (perhaps extremely basic ones) can be generated using the plugin back-end as a data source.&lt;/li&gt;&lt;li&gt;Read more into the model provided by See et al. (2017), as well as related work, to gain a better understanding of the architecture and function/behavior of attention. A closer study of the works cited in my &lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5&quot;&gt;second blog post&lt;/a&gt; will be a good starting point. The better I understand this mechanism the more equipped I’ll be to create meaningful visualizations.&lt;/li&gt;&lt;li&gt;Continue prototyping static visualizations, move on to interactive visualizations. Acquire feedback from peers for both.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Thanks for reading!&lt;/p&gt;&lt;h4&gt;Works Cited&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1704.04368.pdf&quot;&gt;See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” &lt;em&gt;ACL&lt;/em&gt; (2017).&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://ufal.mff.cuni.cz/pbml/109/art-rikters-fishel-bojar.pdf&quot;&gt;Rikters, Matīss, Mark Fishel, and Ondřej Bojar. “Visualizing neural machine translation attention and confidence.” &lt;em&gt;The Prague Bulletin of Mathematical Linguistics&lt;/em&gt; 109.1 (2017): 39–50.&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=306dca636d3a&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 25 Apr 2018 06:48:23 +0000</pubDate>
</item>
<item>
	<title>Aaron Johnston, Lynsey Liu &lt;br/&gt; Team Viterbi Or Not To Be: Baseline Model #2</title>
	<guid isPermaLink="false">https://medium.com/p/a21b51cdd27c</guid>
	<link>https://medium.com/@viterbi.or.not/baseline-model-2-a21b51cdd27c?source=rss-c522ef075bb3------2</link>
	<description>&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*M0h3Wof_sgtxGwgnT2IncQ.png&quot; /&gt;Bassline = Baseline?&lt;/figure&gt;&lt;p&gt;This week, we completed the baseline portion of our project (see the roadmap below!) by finishing the implementation of our various baseline models and evaluating their performance with the goal of providing context for the rest of the project. In last week’s blog post, we described the process of replicating the findings of a related research paper using a single model, and incorporating only features that apply to text summarization in general. This week, we expanded upon that start by adding an additional simple, single-feature baseline and by evaluating our implementation using other models as well! Finally, we built upon our codebase from last week with various bugfixes and feature additions, such as implementing k-fold cross validation for more reliable metrics.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*K0NWdjTpiYezkyqh34fdow.png&quot; /&gt;Roadmap of our project — At this point, we’ve completed the first big block, highlighted in orange!&lt;/figure&gt;&lt;h4&gt;Simple Baseline&lt;/h4&gt;&lt;p&gt;The simplest baseline we put together used only the sentence length feature, a very basic but often reliable measure of sentence importance, with a Naive Bayes model.&lt;/p&gt;&lt;h4&gt;More Realistic Baselines&lt;/h4&gt;&lt;p&gt;The more realistic and comprehensive baseline models that we implemented use the full “basic feature set” described in our &lt;a href=&quot;https://medium.com/@viterbi.or.not/baseline-model-1-a6690114c441&quot;&gt;last blog post&lt;/a&gt; with Naive Bayes, Decision Tree, and Multilayer Perceptron models. The comprehensive Naive Bayes baseline is the same as the baseline model described in our previous post — the main progress on this week’s baselines is the addition of a simple feature to catch email lines that are quoted replies (a problem we found in a lot of the summaries generated by our models) as well as experimentation with the different types of models.&lt;/p&gt;&lt;h4&gt;Results and Evaluation&lt;/h4&gt;&lt;p&gt;As expected, the simple Naive Bayes baseline performed pretty poorly. The models using all of the features in the basic set all performed similarly well, with slight fluctuations in which ROUGE metric they did better in (seen in the table below). Overall, we found that our Naive Bayes model performed competitively with the other models in ROUGE-L and the best in ROUGE-1 and ROUGE-2, though most importantly, we thought the summaries generated by Naive Bayes were the most satisfactory when actually reading them.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*Hv_d7fQj-ATlUEaV79Moiw.png&quot; /&gt;Table comparing the performances of the various baseline models we implemented, the best performing in each ROUGE metric highlighted in orange&lt;/figure&gt;&lt;p&gt;Our best baseline model does better than the corresponding model in &lt;a href=&quot;http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf&quot;&gt;Summarizing Online Conversations: A Machine Learning Approach&lt;/a&gt; in the ROUGE-1 and ROUGE-2 metrics&lt;strong&gt;, &lt;/strong&gt;but does significantly worse in the ROUGE-L metric. However, it is not clear which of the ROUGE metrics is more “important” to score well in, and it is hard to do a complete comparison between our model and theirs without a sample of the summaries generated by their model (which is not provided in the paper).&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*sFxZT2d-C_jKMnFxTWUHuA.png&quot; /&gt;Table comparing the performance of the our best baseline model with the corresponding model in &lt;a href=&quot;http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf&quot;&gt;&lt;strong&gt;Summarizing Online Conversations: A Machine Learning Approach&lt;/strong&gt;&lt;/a&gt;, the best performing in each ROUGE metric highlighted in orange&lt;/figure&gt;&lt;p&gt;In an effort to better understand what these automated metrics are measuring, here are descriptions of what ROUGE-L and ROUGE-N (ROUGE-1 and ROUGE-2) measure —&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ROUGE-L: &lt;/strong&gt;Based on Longest Common Subsequence statistics, identifies longest co-occurring in sequence n-grams.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ROUGE-1: &lt;/strong&gt;Unigram overlap between system and reference summaries.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ROUGE-2: &lt;/strong&gt;Bigram overlap between system and reference summaries.&lt;/p&gt;&lt;p&gt;ROUGE-L and ROUGE-N clearly measure summary quality very differently, and rather than increase together, the metrics vary greatly and sometimes change inversely. While performing a mini ablation study with our baselines, we noticed that removing certain features increased ROUGE-L but cause large drops in both ROUGE-1 and ROUGE-2, as well as generated less satisfactory summaries (judged by us reading the generated summaries).&lt;/p&gt;&lt;p&gt;Because ROUGE does not necessarily reliably measure the quality of a conversation summary, human monitoring of generated summaries and error analysis are crucial to this project.&lt;/p&gt;&lt;h4&gt;Error Analysis&lt;/h4&gt;&lt;p&gt;So, although we used the ROUGE metrics for our model in order to compare it to our baseline research paper, we put an emphasis on human evaluation due to the inability of ROUGE to capture all the elements of successful summarization. Namely, although ROUGE is capable of determining whether the words and subsequences used in a summary match the human-annotated reference, it cannot capture critical aspects of the text such as its coverage of the source document’s most important points or whether it makes logical sense when read.&lt;/p&gt;&lt;p&gt;Upon reading through the summaries produced by our model, we discovered an interesting mix of results. Several sentences that appeared key to establishing the email thread’s topic were included in the summary by the baseline, indicating that its features for topic identification and term similarity were contributing in a positive manner. However, although it is expected that any extractive summary will produce grammatically imperfect results, there were noticeably major issues with the formation of our baseline model’s summaries.&lt;/p&gt;&lt;p&gt;An excerpt of one fairly representative summary produced by our model appears below, unedited except for truncation and formatting for clarity. This is a summary of an email chain concerning accessible technology from the BC3 corpus:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*JGjecxwGpwd-rxwnf_t_Cw.png&quot; /&gt;Comparison with reference summary&lt;/figure&gt;&lt;p&gt;As one can see, only the first two sentences (green) of this particular summary match the human-annotated summary; the rest (red) diverge and never again are the same sentences shared. This trend is seen across most of the summaries produced by our baseline model, where early sentences tend to be shared — one hypothesis is that the first email in a thread has clear significance in establishing that thread’s topic, while subsequent emails are less certain, leading to divergence between the model and human understanding.&lt;/p&gt;&lt;p&gt;Beyond the matching of sentences, there are certain aspects of the summary that, through a human evaluation, can be identified as clearly not belonging in the summary:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*ni7uIemzWgCsW4Yvh0jlwA.png&quot; /&gt;Email-specific formatting leads to summarization mistakes&lt;/figure&gt;&lt;p&gt;In this example, there are sequences of text that are directly repeated (orange). This occurs due to emails having quoted text from previous emails in their message bodies, and as the general text summarization features attribute the same likelihood of being relevant to the summary to both versions of the text based solely on content (and not, for instance, sentence position), it makes sense that both would be included. Doing so seems not to vastly impact the ROUGE score, but provides another example of the importance of human evaluation because it seems reasonable that no human would prefer to have those repetitions in a summary. Another example of the baseline model’s errors can be found in the email signature present in the summary (blue), which a human reader would clearly not find meaningful for the summary.&lt;/p&gt;&lt;p&gt;Both of these mistakes can be attributed to the fact that our baseline model uses general features for text summarization, and does not factor in conversation-specific features such as recognizing an email signature as being irrelevant to the topics being discussed. Once we begin work on our minimum viable product, we expect it to perform much better in this category, because we will have the chance to add these features.&lt;/p&gt;&lt;p&gt;Finally, the following examples show cases in which our model makes the opposite mistake from above, failing to capture portions of the original conversation that are important to the summary through human eyes. As expected, both of the common cases of failure we identified seem to stem from the fact that the missed content is formatted in a different way than normal text.&lt;/p&gt;&lt;p&gt;For the same conversation as above, the following shows just the URLs that were included in a human-annotated summary. Highlighted in green are the URLs which our baseline model also included in its generated summary:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*P9C4OsXf9w3KK4ishqa9Tg.png&quot; /&gt;Almost all important URLs are not captured by the baseline model&lt;/figure&gt;&lt;p&gt;As one can see, the baseline model had a 10% success rate in identifying URLs from the email thread that the human annotator deemed as important. In a thread that primarily dealt with identifying resources from the internet, having these URLs in a summary would be highly desirable, so we consider this to be a major failing of the baseline model. Because URLs are much different from typical text, using general text summarization features likely led to this absence because there are no features that can ascribe importance to URLs based purely off their general format.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*Wfd7cl-8KZ36YvAWXG4wHw.png&quot; /&gt;Structured data, such as ordered lists, are not captured&lt;/figure&gt;&lt;p&gt;As another example, the following is a comparison between our baseline model and a human-annotated reference summary for a different conversation that includes discussion of poll results:&lt;/p&gt;&lt;p&gt;Although the baseline model does relatively well in identifying sentences related to the discussion of the poll results, its summary is noticeably lacking the results themselves. We hypothesize that the general text summarization features are insufficient to detect numerical data or items that are presented in a list, such as the one above, and therefore because the actual text within each poll result item is very generic the baseline model was unable to successfully select them for the summary.&lt;/p&gt;&lt;p&gt;Ultimately, these few examples are not enough to capture the exact failings of our baseline model, but by analyzing them in conjunction with the other summaries generated for our validation set, we were able to get an impression of the types of improvements that will be needed. In our next step of including conversation-specific features, we plan to make our top priority addressing structured data unique to emails by creating features to target email summaries, quoted text (and repeated text in general), and certain entities such as URLs or lists.&lt;/p&gt;&lt;h4&gt;Steps Towards an Advanced Model&lt;/h4&gt;&lt;p&gt;Keeping the weaknesses of our baseline in mind, our next steps towards creating a more advanced conversation summarization model (and approaching our Minimum Viable Product!) include the following:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Incorporate conversation-specific features&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;We would like to explore using topic segmentation to preprocess conversation data and potentially improve model performance.&lt;/li&gt;&lt;li&gt;We would also like to add features that incorporate detection of&lt;strong&gt; structured data&lt;/strong&gt; (URLs, Lists, Numbers), &lt;strong&gt;sentiment scores&lt;/strong&gt; of sentences, and &lt;strong&gt;discourse markers&lt;/strong&gt; (defining the purpose of a sentence in the text, for example, identifying a sentence as an email signature).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Train the models on other datasets&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;We will need preprocess the other datasets and restructure some of our code to handle input of the other datasets.&lt;/li&gt;&lt;li&gt;We anticipate some challenges based on the differences of the other datasets — the chatlog data will require much more preprocessing and meeting transcripts will likely have different vocabulary (i.e. no URLs, fewer abbreviations) which may impact our feature engineering process.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Check back next week to see our initial work on the most exciting part — the advanced model!&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=a21b51cdd27c&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 25 Apr 2018 06:29:12 +0000</pubDate>
</item>
<item>
	<title>Kuikui Liu, Nicholas Ruhland &lt;br/&gt; Team INLP: NLP Capstone Post #5: A New Hope</title>
	<guid isPermaLink="false">http://mathstoc.wordpress.com/?p=323</guid>
	<link>https://mathstoc.wordpress.com/2018/04/25/nlp-capstone-post-5-a-new-hope/</link>
	<description>&lt;h1&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Dataset Improvements&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;&lt;i&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Last time, on Music NLP.&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt; We ran into many midi data parsing issues. Since then, we have discovered a new dataset called the Lakh MIDI Dataset (&lt;/span&gt;&lt;a href=&quot;http://colinraffel.com/projects/lmd/&quot;&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;http://colinraffel.com/projects/lmd/&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;) that comes with reasonably well-formed midi files. Using the “Clean MIDI Subset”, we found thousands of midi files with their associated song names and songwriters. From these midi files, we extracted all with nonempty “lyric” fields when parsed via the pretty_midi package (which, incidentally, is also developed by Colin Raffel). After this step, we were left with ~1200 midi files that contain lyrics.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;We currently clean the lyrical content by removing all unusual symbols and setting all characters to lowercase. We leave all lyrical tokens as is, which typically means syllable. Due to the inconsistent quality of the MIDI annotations, many songs are tokenized instead to characters, words, or even sentences. We will explore other methods for processing data if this is not sufficient for our results.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;It is unfortunate we did not find this dataset sooner, because most of our challenges up to this point have been dealing with the poor quality of the gathered data.&lt;/span&gt;&lt;/p&gt;
&lt;h1&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Alignment&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;For our task of producing karaoke style output, there are two main tasks we have to solve. The first task is the generation of plausible lyrics, and the second is to align the lyrics to the proper time along the musical data. The alignment task has been studied extensively, but specifically aligning lyrical content to MIDI has not been covered in literature we have found. The most common alignment task is lyrics to audio data, as opposed to MIDI. The other common task is to align audio data to the notes defined in a MIDI file. In [1], they show a method that takes a MIDI file with annotated lyrics and uses this to align the lyrics to the raw audio. Unfortunately this is not our task, because we are trying to generate the annotated MIDI.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;This week, we have decided to ignore the alignment task and focus primarily on making a reasonable lyrical model. We will return to alignment next week.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;The next step was to align the lyrics with pianoroll. Fortunately, well-formed midi data parsed into PrettyMIDI objects come with a “get_piano_roll” function that takes as input a list of “times” which correspond to where in time pretty_midi will attempt to sample the music. As each syllable in the lyrics comes with a start time for when the singer enunciates it, we can pass in these start times to produce pianoroll that is aligned (up to small error) with the lyrics.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;For some implementation reasons that are difficult to explain in English, it is possible for “get_piano_roll” to produce NaN entries, which we have replaced with zeros. Due to this and the potential for other such problems, we have forked the pretty_midi package and will be able to modify the code for our needs. For example, as pointed out in [2], “in a given MIDI file there is no reliable way of determining which instrument is a transcription of the vocals in a song”. As such, there are many choices for how to do alignment; pretty_midi has implemented just one. It is an interesting task to see how different alignment methods help or hurt our models.&lt;/span&gt;&lt;/p&gt;
&lt;h1&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Lyric prediction&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Now that we have aligned pianoroll to lyrics data, we can begin engineering the model. Last time, we used an LSTM to generate lyrics given starting characters. Here, we will again use LSTMs, but instead, work at the syllable level and take as input the pianoroll of a song. As each column of a pianoroll is a time slice, each input vector to the LSTM is a single time slice. Each time slice is a 128-dimensional vector, with each entry representing the activation of an instrument; there are 128 midi recognized “instruments”.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;All that is left is to play with the architecture. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;RNN model&quot; class=&quot;alignnone size-full wp-image-322&quot; src=&quot;https://mathstoc.files.wordpress.com/2018/04/rnn-model1.png?w=676&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;At the moment, our pipeline looks like what is shown in the diagram. At each iteration, we take a song, extract the lyrics and the corresponding pianoroll data. We then feed each time slice of the pianoroll data through an encoder unit, then through an LSTM unit, then through a decoder unit, and finally through a softmax to produce the prediction. Our loss is the negative log-likelihood (negative logarithm of the RNN softmax probability of the true syllable).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;We will compare our final model to this baseline with respect to the loss on a held-out validation set. We will also experiment with loss functions other than cross entropy to see how it affects the actual lyrical output.&lt;/span&gt;&lt;/p&gt;
&lt;h1&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Model results&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;We have so far only trained our model for a single iteration over the training set. For an empirical evaluation on the current model quality, we ran a single MIDI through the input and computed the argmax word for each output. This produced a result in which every predicted lyric was an empty message, which is the most common string in the training set. We will explore methods to handle this class imbalance as our next task.&lt;/span&gt;&lt;/p&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;[1] Müller, Meinard &amp;amp; Kurth, Frank &amp;amp; Damm, David &amp;amp; Fremerey, Christian &amp;amp; Clausen, Michael. (2007). Lyrics-Based Audio Retrieval and Multimodal Navigation in Music Collections. 4675. 112-123. 10.1007/978-3-540-74851-9_10.&lt;/span&gt;&lt;br /&gt;
&lt;span style=&quot;font-weight: 400;&quot;&gt;[2] &lt;/span&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Raffel, Colin and Daniel P. W. Ellis. “Extracting Ground-Truth Information from MIDI Files: A MIDIfesto.” &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;ISMIR&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt; (2016). &lt;/span&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt; &lt;/span&gt;&lt;/p&gt;</description>
	<pubDate>Wed, 25 Apr 2018 04:44:57 +0000</pubDate>
</item>
<item>
	<title>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde: Actual Strawman Update</title>
	<guid isPermaLink="true">http://sarahyu.weebly.com/cse-481n/actual-strawman-update</guid>
	<link>http://sarahyu.weebly.com/cse-481n/actual-strawman-update</link>
	<description>&lt;div class=&quot;paragraph&quot;&gt;&lt;strong&gt;Real Data and Results Have Been Seen! &lt;/strong&gt;&lt;br /&gt;As I mentioned in my last post, I was struggling with accessing the data, but I've since solved my problems and got to learn some cool tools along the way (like apparently you can read a compressed file without decompressing??? wild). I've also spent a large part of the week learning and fighting with SqlAlchemy, PyMySQL, MySQL, and UTF-8 issues. With the interaction of all of these, I was able to read (most of the) Reddit posts of January 2017 (thanks to Jason Baumgartner publishing these dumps on pushshift.io, I will donate when I have an income) which amounted to 80 million posts, find the users we are interested in, find neurotypical subreddits these users post to, and then get posts of our two (neurotypical and neurodivergent) subreddit subsets. &lt;br /&gt;&lt;br /&gt;Side Note: I'm going to start referencing the Neurodivergent set as ND, and Neurotypical as NT, trying to save some typing&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;Baseline #1 (kind of an update of the Strawman #1):&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;Glen Coppersmith and Erin Kelly (2014). &lt;strong&gt;&lt;em&gt;Dynamic Wordclouds and Vennclouds for Exploratory Data Analysis. &lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;font size=&quot;2&quot;&gt;Association for Computational Linguistics Workshop on Interactive Language Learning and Visualization&lt;/font&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; With thanks to Coppersmith and Kelly, I was able to make a Term Frequency Venncloud as seen below that show in black the most frequent terms found in both subreddit subsets, and then separated into the most frequent terms in neurodivergent subreddits and neurotypical subreddits in blue and red, respectively. &lt;/div&gt;  &lt;div&gt;&lt;div class=&quot;wsite-image wsite-image-border-none &quot; style=&quot;padding-top: 10px; padding-bottom: 10px; margin-left: 0px; margin-right: 0px; text-align: center;&quot;&gt; &lt;a&gt; &lt;img alt=&quot;Picture&quot; src=&quot;http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-04-26-at-1-48-22-pm_orig.png&quot; style=&quot;width: auto;&quot; /&gt; &lt;/a&gt; &lt;div style=&quot;display: block; font-size: 90%;&quot;&gt;Naurodivergent vs. Neurotypical Subreddit Venncloud&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;  &lt;div class=&quot;paragraph&quot;&gt;&lt;br /&gt;As we can see, the middle of the venncloud is pretty uninteresting, but here are some notable points:&lt;ul&gt;&lt;li&gt;Personalization: Frequency of you/me, your/my words which indicate some sense of relationship and more personalization between ND posters. This contrasts the frequency of they, indicating some discussion of an other, in the NT subreddits.&lt;/li&gt;&lt;li&gt;&quot;is&quot;: I interpreted the frequency of this word in the NT subreddits as a more definitive and declarative way of speech, rather than other words such as &quot;think&quot;, &quot;feel&quot; and &quot;maybe&quot; (in the ND subreddits) which signal more hesitation. This is a point touched on and described as dogma in Fast &amp;amp; Horvitz which is one of the papers I discussed in a previous post.&lt;/li&gt;&lt;li&gt;&quot;www&quot;, &quot;imagesofnetwork&quot; :  This is something I cold probably fix; the way I pre-process the data scrubs and separates the links into separate words. At the end of the day though, this shows that there are significantly more links in NT subreddits. My thought is that the lack of such in the ND subreddits might mean more anecdotal and personal interactions than when compared to ND subreddits&lt;/li&gt;&lt;li&gt;Moral Adjectives: Some of the ND frequently used terms are what I am going to call Morale Adjectives (let me know if there's an actual term for this); here I mean, we see words like &quot;good&quot;, &quot;right&quot;, &quot;bad&quot;, which are often used to describe habits or behavior.&lt;/li&gt;&lt;li&gt;SURPRISE GENDER DIFF: As you can see, 'she' is one of the most frequent ND words, whereas 'he' is  one of the most frequently used NT words. Some thoughts: 1) doesn't show anything, there are some partner subreddits and may just show that the predominantly male reddit user base talks about different genders in the two, but they themselves may not be a different gender distribution or 2) could show different gender engagement in the different subsets.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;strong&gt;Baseline #2: Connotation Frames&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;Hannah Rashkin, Sameer Singh, Yejin Choi. 2016. &lt;strong&gt;&lt;em&gt;Connotation Frames: A Data-Driven Investigation.&lt;/em&gt;&lt;/strong&gt;&lt;font size=&quot;2&quot;&gt; In Proceedings of ACL 2016&lt;/font&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;Maarten Sap, Marcella Cindy Prasettio, Ari Holtzman, Hannah Rashkin, &amp;amp; Yejin Choi. 2017. &lt;em&gt;&lt;strong&gt;Connotation Frames of Power and Agency in Modern Films.&lt;/strong&gt;&lt;/em&gt; &lt;font size=&quot;2&quot;&gt;sched. to appear EMNLP 2017 short papers. &lt;/font&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; With help from Maarten Sap, another model I explored was the Connotation Frames formalism, to look at the verbs used in both our NT and ND subreddits and the sentiments these provide between agent and subject. However, we found no significant differences between the two (output below).&lt;/div&gt;  &lt;div&gt;&lt;div class=&quot;wsite-multicol&quot;&gt;&lt;div class=&quot;wsite-multicol-table-wrap&quot;&gt; 	&lt;table class=&quot;wsite-multicol-table&quot;&gt; 		&lt;tbody class=&quot;wsite-multicol-tbody&quot;&gt; 			&lt;tr class=&quot;wsite-multicol-tr&quot;&gt; 				&lt;td class=&quot;wsite-multicol-col&quot; style=&quot;width: 50%; padding: 0 15px;&quot;&gt; 					 						  &lt;div&gt;&lt;div class=&quot;wsite-image wsite-image-border-none &quot; style=&quot;padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;&quot;&gt; &lt;a&gt; &lt;img alt=&quot;Picture&quot; src=&quot;http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-04-26-at-9-45-10-am_orig.png&quot; style=&quot;width: auto;&quot; /&gt; &lt;/a&gt; &lt;div style=&quot;display: block; font-size: 90%;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;   					 				&lt;/td&gt;				&lt;td class=&quot;wsite-multicol-col&quot; style=&quot;width: 50%; padding: 0 15px;&quot;&gt; 					 						  &lt;div&gt;&lt;div class=&quot;wsite-image wsite-image-border-none &quot; style=&quot;padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;&quot;&gt; &lt;a&gt; &lt;img alt=&quot;Picture&quot; src=&quot;http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/nt-verbs_1_orig.png&quot; style=&quot;width: auto;&quot; /&gt; &lt;/a&gt; &lt;div style=&quot;display: block; font-size: 90%;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;   					 				&lt;/td&gt;			&lt;/tr&gt; 		&lt;/tbody&gt; 	&lt;/table&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;  &lt;div class=&quot;paragraph&quot;&gt;&lt;br /&gt;&lt;strong&gt;Baseline #3: LIWC2015&lt;/strong&gt;&lt;br /&gt;Finally, I used LIWC2015 to count and classify the psychological meanings and categories for both NT and ND subreddits. This serves as another type of language model to define these two 'languages' and offers us another metric on which to find similarities and differences. ​&lt;br /&gt;&lt;br /&gt;Just for some clarification, the way that this model works is by having 73 categories (more information available &lt;a href=&quot;https://liwc.wpengine.com/compare-dictionaries/&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;), anywhere from topics - PRONOUN, HEALTH, BIO - to grammar - VERB, ARTICLE - and gives the percentage of the language that each category accounts for in that 'language'. In our case, we see the distribution of categories in NT subreddits compared to ND subreddits. &lt;br /&gt;&lt;br /&gt;&lt;span&gt;My hypotheses were:&lt;/span&gt;&lt;ul&gt;&lt;li&gt;[You, Heshe, Pronoun, Health, Feel, They] categories would be significantly higher in ND &lt;/li&gt;&lt;li&gt;[Anger, Power, Swear] categories would be significantly lower in ND than in NT&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;After getting the results, I report the top 10 categories with the largest % difference between the two. &lt;ul&gt;&lt;li&gt;HEALTH(3.34x), &lt;span&gt;INGEST(2.69x), BIO(2.13x)&lt;/span&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;These categories are topic specific (ingestion related to drug subreddits and bio on biological processes) and align with what we expect in mental health topic subreddits&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;FEEL(2.04x), SAD(1.88x), ANX - anxiety (&lt;span&gt;2.86x)&lt;/span&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;​Also make sense for the support communities within the ND group, potentially, topical for &quot;anxiety&quot; as a temporary and consistent feeling&lt;/span&gt;&lt;br /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;FAMILY(2.07x), HOME (2.05x)&lt;br /&gt;&lt;ul&gt;&lt;li&gt;This was a bit surprising, I believe appeals to the family and home tend are prominent in support groups as well as the &quot;partners of&quot; subreddits we have in the ND group&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;I (1.73x)&lt;ul&gt;&lt;li&gt;There seems to also be a lot of personal discussion, which we expect in subreddits that are meant to discuss personal problems&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;FEMALE (1.81x)&lt;br /&gt;&lt;ul&gt;&lt;li&gt;ITS HERE AGAIN WHY AND HOW&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;​&lt;br /&gt;That's all for baseline models, here's to my first attempt at the more advanced model this week...&lt;/div&gt;</description>
	<pubDate>Tue, 24 Apr 2018 07:00:00 +0000</pubDate>
</item>
<item>
	<title>Ananth Gottumukkala &lt;br/&gt; Team Turing Test: Strawman/Baseline 1: Deep Recurrent Q Network</title>
	<guid isPermaLink="false">http://deeplearningturingtest.wordpress.com/?p=16</guid>
	<link>https://deeplearningturingtest.wordpress.com/2018/04/20/strawman-baseline-1-deep-recurrent-q-network/</link>
	<description>&lt;p&gt;For this week, I decided to first develop the RL model for asking questions. I chose to try a Deep Recurrent Q Network (DRQN) first (and the policy gradient method later) using the following repository as a starting point:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/awjuliani/DeepRL-Agents/blob/master/Deep-Recurrent-Q-Network.ipynb&quot; rel=&quot;nofollow&quot;&gt;https://github.com/awjuliani/DeepRL-Agents/blob/master/Deep-Recurrent-Q-Network.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This repository implements the DRQN for games by using LSTM cells to encode sequential information as successive frames are passed in for each time step. These frames are then passed through a CNN, then the LSTM cell, and then output the Q values. In the code I replaced where the input image (frame) is passed into the DRQN with the 2D word embedding matrix (GloVe vector for each word in sentence) and passed it straight into the CNN. I also gave a default reward of 0 to the model and managed to run the model without errors.&lt;/p&gt;
&lt;p&gt;My goal for next week is to change the reward allocation to be user input, hardcode all the question templates, and begin training the model.&lt;/p&gt;</description>
	<pubDate>Fri, 20 Apr 2018 06:47:18 +0000</pubDate>
</item>
<item>
	<title>Halden Lin &lt;br/&gt; Team undef.: NLP Capstone | 04: First Steps</title>
	<guid isPermaLink="false">https://medium.com/p/be87c31976b7</guid>
	<link>https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7?source=rss-2759d54493c0------2</link>
	<description>&lt;p&gt;&lt;em&gt;previous posts: &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5&quot;&gt;&lt;em&gt;01&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5&quot;&gt;&lt;em&gt;02&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3&quot;&gt;&lt;em&gt;03&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Nearing 4 weeks in — I’ve finally got a foothold in the development process. Over this past week I’ve been looking through TensorBoard and TensorFlow source-code and documentation in an attempt to develop a foundation for plugin development.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Notable Resources:&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.tensorflow.org/programmers_guide/summaries_and_tensorboard&quot;&gt;TensorBoard Documentation&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/tensorflow/tensorboard&quot;&gt;TensorBoard Source Code&lt;/a&gt; and &lt;a href=&quot;https://github.com/tensorflow/tensorboard/tree/master/tensorboard/plugins&quot;&gt;Existing Plugins&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/tensorflow/tensorboard-plugin-example/blob/master/README.md&quot;&gt;Developing a TensorBoard Plugin&lt;/a&gt; (a simple example)&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Completed Milestones:&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;Understand the structure of a TensorBoard Plugin, specifically how the architecture of the Attention Plugin should look like.&lt;/li&gt;&lt;li&gt;Design and write the data fetching layer.&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;Plugin Architecture&lt;/h4&gt;&lt;p&gt;In TensorFlow, data from iterations of training / evaluation is stored as a set of &lt;strong&gt;summaries&lt;/strong&gt;. These can take the form of any tensor, including text, image, scalars, or time series. These are written to disk as the computation graph is executed. Each ‘summary’ takes the form of a &lt;a href=&quot;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/framework/summary.proto&quot;&gt;Summary protocol buffer&lt;/a&gt;, which holds, in addition to the data stored, critical identifying information (tags and metadata). A plugin can then read summaries associated with particular tags and sessions from disk to serve to the TensorBoard front-end via a plugin back-end, where a visualization is rendered.&lt;/p&gt;&lt;p&gt;Following &lt;a href=&quot;https://github.com/tensorflow/tensorboard-plugin-example/blob/master/README.md&quot;&gt;&lt;em&gt;Developing a TensorBoard plugin&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;the Attention Plugin with have three primary components:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Data API layer. This is what allows users to capture relevant summaries from within their models.&lt;/li&gt;&lt;li&gt;Plugin backend, which serves said summaries.&lt;/li&gt;&lt;li&gt;Frontend, where the visualizations are displayed.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Unlike commonly used plugins such as the &lt;a href=&quot;https://github.com/tensorflow/tensorboard/tree/master/tensorboard/plugins/scalar]&quot;&gt;scalar&lt;/a&gt; and &lt;a href=&quot;https://github.com/tensorflow/tensorboard/tree/master/tensorboard/plugins/histogram&quot;&gt;histogram&lt;/a&gt; plugins, the Attention Plugin consumes 3 distinct values: the input text, the decoded output text, and the attention matrix that correlates the two. Initially, I attempted to store these all in a single Summary protobuf, where the first two rows of the encapsulating matrix would contain the text, and the rest would contain the attention weights. This results in a mixing of string and float types in a single Tensor, which is not valid (to my knowledge) in TensorFlow. I then realized I could store these separately, each in their own summary, and retrieve them via an identifying name. The resulting architecture is shown in the diagram below.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*QK7USkxsSC3u6F0LKbKWXQ.png&quot; /&gt;The architecture of the Attention Plugin.&lt;/figure&gt;&lt;p&gt;I decided to make the output text an optional summary, as models don’t necessarily need to decode (via Viterbi, Beam Search, or otherwise) an output sequence while training. The input text and attention matrix are still valuable, as summary statistics (e.g. coverage, important words, etc) can be gleamed without the decoded text.&lt;/p&gt;&lt;h4&gt;Data API Layer&lt;/h4&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*0m1-fllpNYMP666FhR0nbA.png&quot; /&gt;Data API Layer highlighted in green.&lt;/figure&gt;&lt;p&gt;As the TensorBoard authors suggest, the data API layer, defined in attention_summary.py, provides two methods for creating Summary protobufs, which can then be written to disk via a FileWriter. The first is via a TensorFlow op, which can be thought of as a node in the computation graph, that produces a Summary when the graph is executed. The second is by directly creating the protobuf, which allows for data to be saved outside the execution of a TensorFlow session. I’ve implemented both of these. There is a separate method for each of the three datum used by the plugin (input text, output text, attention matrix), and each of the three summary datum are tagged differently (e.g. name/attention_input_summary, name/attention_output_summary) in order to allow for distinguishable retrieval later.&lt;/p&gt;&lt;p&gt;An example of the usage of both methods can be found in attention_demo.py.&lt;/p&gt;&lt;h4&gt;Next Steps&lt;/h4&gt;&lt;p&gt;I suspect the work completed this week was the biggest hurdle in terms of time:code ratio. I would not be surprised if I had to revisit the work done here in order to clean things up or fix small bugs. However, with this understanding and architecture nailed down, I expect implementation of the rest of the plugin will come at a faster pace. With that said, three tasks stand as immediate goals for the next week.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Modify my forked repository of the summarization model created by &lt;a href=&quot;https://arxiv.org/pdf/1704.04368.pdf&quot;&gt;See et al.&lt;/a&gt; (original found &lt;a href=&quot;https://github.com/abisee/pointer-generator&quot;&gt;here&lt;/a&gt;) to produce and save the appropriate summaries for the Attention Plugin. I’ve already started looking into this, and expect to have to fiddle around with the training / evaluation scheme in order to grab an appropriate amount of data.&lt;/li&gt;&lt;li&gt;Implement the backend of the Attention Plugin.&lt;/li&gt;&lt;li&gt;Begin prototyping visualizations (pen &amp;amp; paper) and acquire preliminary feedback.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Until next time.&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=be87c31976b7&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Thu, 19 Apr 2018 06:33:40 +0000</pubDate>
</item>
<item>
	<title>Aaron Johnston, Lynsey Liu &lt;br/&gt; Team Viterbi Or Not To Be: Baseline Model #1</title>
	<guid isPermaLink="false">https://medium.com/p/a6690114c441</guid>
	<link>https://medium.com/@viterbi.or.not/baseline-model-1-a6690114c441?source=rss-c522ef075bb3------2</link>
	<description>&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*bGQmjLRpsY3UnYhK6e8Lyg.png&quot; /&gt;&lt;/figure&gt;&lt;p&gt;This week, we implemented our &lt;a href=&quot;https://github.com/viterbi-or-not-to-be/viterbi-or-not-to-be/tree/master/baseline&quot;&gt;first baseline model&lt;/a&gt; for conversation summarization. In order to create a baseline that would be useful to build off of and compare our future results to, we decided to base this model off the Naive Bayes implementation described in the paper &lt;a href=&quot;http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf&quot;&gt;&lt;strong&gt;Summarizing Online Conversations: A Machine Learning Approach&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;To begin with, we identified the W3C Email Threads dataset as a useful starting point because of the fact that we have access to multiple email datasets, and because the paper mentioned above indicated that chatlog data would require a great deal of additional preprocessing to be able to manipulate. By comparison, the email data is fairly simple to interpret because it is rare for a single sender to convey their portion of a message across multiple emails, and the writing is generally more grammatically well-formed. The experiments in the paper run on the &lt;a href=&quot;https://flossmole.org/content/software-archaeology-gnue-irc-data-summaries&quot;&gt;GNUe Archives&lt;/a&gt; and the &lt;a href=&quot;https://www.cs.ubc.ca/cs-research/lci/research-groups/natural-language-processing/bc3.html&quot;&gt;BC3 Corpus&lt;/a&gt; (annotated W3C Email Threads).&lt;/p&gt;&lt;p&gt;The paper also uses &lt;a href=&quot;https://www.cs.waikato.ac.nz/ml/weka/&quot;&gt;Weka Toolkit&lt;/a&gt; for all of its model implementations, so we initially aimed to use Weka as well to reproduce our baseline. However, we encountered a few challenges while starting out with Weka that ultimately led to our abandoning the platform in favor of a more flexible Python implementation. The email data is in XML format, whereas Weka appears to work best with a format called ARFF, and in our preliminary examination we found ARFF to be fairly difficult to map directly to XML. In particular, ARFF’s apparent inability to handle dynamic-length data types or nested relations made it challenging to plan around — this was a problem because for each training example (email thread) in our dataset, we have a variable-length amount of information (number of emails, number of sentences per email, number of words per sentence, etc.). Without usage of dynamic-length data coupled with a toolset/interface more suited to data mining and application of basic, pre-made machine learning models than detailed feature engineering, we found Weka specifically difficult to use for feature extraction.&lt;/p&gt;&lt;p&gt;Instead, we ended up deciding to implement the baseline model in Python — including parsing the XML from our chosen dataset, extracting features, and using SciKit-Learn to train a Naive Bayes model to form the baseline itself. Since our aim with the baseline was to re-implement at least part of the work done by the &lt;a href=&quot;http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf&quot;&gt;&lt;strong&gt;Summarizing Online Conversations: A Machine Learning Approach&lt;/strong&gt;&lt;/a&gt; paper, we also chose to set up evaluation that would mirror their evaluation techniques, and settled on using a previously-written implementation of ROUGE for the task. Re-implementing the baseline model in Python based on previous work took more effort than using Weka would have, but was advantageous in that it helped us understand the specific challenges of the task and resulted in somewhat extensible code we can adapt for later phases of the project.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Feature Selection&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;The Feature Selection section of the paper notes a “basic feature set,” which refers to features that are “not specific to conversations and consider the conversation as a simple piece of text.” For our baseline, we decided to target only the basic features to establish the difference that can be made by using conversation-specific features. Based on this basic set, our Naive Bayes baseline incorporates the following features —&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Mean TF-IDF: &lt;/strong&gt;Term frequency-inverse document frequency (TF-IDF) characterizes frequency of a word and reflects its importance to an email thread. Calculating TF-IDF results in a vector of word frequencies per email, and we take the mean of the values in the vector for the mean TF-IDF feature.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Mean TF-ISF: &lt;/strong&gt;Similar to TF-IDF but at a different granularity, term frequency-inverse sentence frequency (TF-ISF) characterizes frequency of a word and reflects its importance to an email. Calculating TF-ISF results in a vector of word frequencies per sentence, and we take the mean of the values in the vector for the mean TF-ISF feature.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Sentence Length: &lt;/strong&gt;Number of characters in the sentence.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Sentence Position: &lt;/strong&gt;Index of the sentence within the email.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Similarity to Title: &lt;/strong&gt;We represent the name of an email thread as a TF-ISF title vector, in the same form as described earlier (without taking the mean). This feature is then the result of the cosine similarity between the TF-ISF vector for a sentence and the title vector.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Centroid Coherence: &lt;/strong&gt;We represent the centroid of an email thread as the average of the TF-ISF sentence vectors. This feature is then the result of the cosine similarity between the averaged centroid vector and the sentence vector.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Special Terms: &lt;/strong&gt;Numbers and proper nouns are deemed as ‘special terms.’ This feature is the count of special terms in a sentence normalized (divided) by the number of special terms in the email thread.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Results and Evaluation&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;After implementing our baseline model, we used the ROUGE package to evaluate its summarization on a variety of metrics. We split the data into training and testing segments, placing 80% of email threads in the training set and 20% in the testing set. We then used our model and features to generate summaries and used ROUGE-L to measure their performance. After computing the average ROUGE-L, ROUGE-1, and ROUGE-2 F1 scores across all the email threads in the testing set, we produced the following results (along with the results reported in the baseline paper for comparison):&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*vjlGJvdBn_k4obtMdkGdIA.png&quot; /&gt;Mean F1 scores for various ROUGE metrics, compared to the results from &lt;a href=&quot;http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf&quot;&gt;&lt;strong&gt;Summarizing Online Conversations: A Machine Learning Approach&lt;/strong&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h4&gt;&lt;strong&gt;Error Analysis&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;It is certainly helpful to have a set of metrics like ROUGE to establish a comparison between our model and existing models, but for a task such as automatic summarization it is an unfortunate reality that no existing metrics really come close to fully capturing the “success” of a summary. Comparing the compositions of two summaries provides valuable insight into the performance of a model, but ultimately a great deal of the usefulness of a summary revolves around its ability to convey the information contained in a conversation without needless filler and in a logical, simple format. Because there are no metrics that can describe how well a summary captured the topics in a conversation or how understandable it is, we will have to rely heavily on human interpretation to judge the success of our model.&lt;/p&gt;&lt;p&gt;For our baseline, we took a look at the generated summaries and discovered that while the general topic of each email thread is easily discernible, it is sometimes difficult to follow the course of the discussion. In addition, we found that our summaries were especially susceptible to the inclusion of “fluff” — short, choppy sentences or signature elements with no relevance to the actual contents of the summary that simply obstructed the reader. Perhaps our future attempts will have to target this with features specifically designed to identify things like email signatures or greetings, to help distinguish between these sources of “fluff” and the actual content of each email. Notably, this is not an issue that chatlog data suffers from, because there are typically fewer signatures or static portions of chats to ignore.&lt;/p&gt;&lt;p&gt;Our analysis is exemplified by the sample summary and its annotated counterpart below:&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*ycgusov-GEUfQm7C.&quot; /&gt;Summary for an email thread generated by our baseline model&lt;/figure&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*aOxikqivuOMXLgnM.&quot; /&gt;Summary for the same email thread from the dataset annotation&lt;/figure&gt;&lt;h4&gt;&lt;strong&gt;Future Improvements&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Although our baseline model provided a useful point of comparison for future efforts, we were not able to entirely replicate the results of the paper we based it off of. Despite using the same features that they described, we achieved a significantly lower mean ROUGE-L F1 score of 0.409 as compared to their 0.245 for the same dataset. As a result, it seems that an important next step would be to identify the discrepancies between our implementation and theirs to try and faithfully reproduce their results before moving on to other models.&lt;/p&gt;&lt;p&gt;One possible issue we identified with our model could be the lack of a topic boundary preprocessing step as found in the research paper. Although their description made it seem as though the technique mainly applied to chatlog data, it is possible that performing such a preprocessing step would bring our model’s performance closer to theirs. The paper describes two different approaches at a very high level, so further research and experimentation would be needed to determine a reasonable implementation to perform such a task. In addition, there were various parameters left out of the paper’s description that could affect the model’s performance, such as ROUGE evaluation parameters and the implementation of Naive Bayes, which could have made an impact.&lt;/p&gt;&lt;p&gt;After finishing our baseline implementation, we plan to implement further models to address this task. The paper we previously mentioned uses a number of other approaches, so one direction we plan to move in is selecting other potentially effective models from their list and implementing them (decision trees look the most promising and would require very little modification to the code). Afterwards, we plan to address the other datasets, and then move into feature engineering and tweaking our implementations to produce our minimum viable product.&lt;/p&gt;&lt;h4&gt;Code&lt;/h4&gt;&lt;p&gt;As mentioned in our first blog post, the full code for our project is &lt;a href=&quot;https://github.com/viterbi-or-not-to-be/viterbi-or-not-to-be&quot;&gt;available on Github&lt;/a&gt;, which currently includes usage instructions located in the README.md file for the baseline directory that can guide a user through the process of setting up the model, producing summaries, and running the ROUGE evaluation. We certainly have a long way to go in terms of code organization and cleanliness, but this baseline implementation at least allows for a preliminary examination of the task and produces the results necessary to interpret the rest of our model approaches with appropriate context.&lt;/p&gt;&lt;p&gt;Edited 4/24 to add baseline dog.&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=a6690114c441&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 18 Apr 2018 06:55:14 +0000</pubDate>
</item>
<item>
	<title>Ron Fan, Aditya Saraf &lt;br/&gt; Team PrimeapeNLP: Blog Post #4</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-3753031463594823927.post-8569998071322028844</guid>
	<link>https://cse481n.blogspot.com/2018/04/blog-post-4.html</link>
	<description>&lt;div dir=&quot;ltr&quot; id=&quot;docs-internal-guid-7937c8af-d777-ed0f-f77b-cf09623b985e&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;A big part of our work for setting up a baseline is the creation of a reasonably good dataset for training and evaluating extractive text summarization. Our goal was to build a dataset with all sentences from the articles marked with binary labels indicating whether or not they were part of the extracted summary.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;We used the DailyMail and CNN story dataset, which is meant for abstractive summarization, to build our own dataset. The data set includes automatically-parsed lines from news articles, as well as a few bullet point highlights for each article. These highlights are not sentences directly from the article, but are overall a decent indicator and considered to be one of the most useable datasets out there (if for no other reason than sheer volume of data).&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;To build our data set, we used a toy metric roughly based off of ROUGE-N, with the understanding that we would only need a way of relative ranking for each sentence.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;The procedure to generate the data set was as follows:&lt;/span&gt;&lt;/div&gt;&lt;ol style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Read in a single .story file from the abstractive dataset into highlights and sentences.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Post-process sentences- in the original data, new lines do not correspond exactly with sentence endings. Additionally, some sentences are originally split arbitrarily by new lines. We do an additional split by the regex (?&amp;lt;=[.?!])\s+ (whitespace with period, question mark, or exclamation mark lookbehind), but sentence “re-joining” is off by default, as some sentences in the original dataset do not end with punctuation.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Score each sentence with our metric.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;ol style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Tokenize each sentence and highlight.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Build unigram, bigram, and trigram lists.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Count the number of matches between the sentence and all the highlights, giving more weight to bigram and trigram matches and also weighting by word length.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Sort sentences by score.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Let S be the number of sentences and H be the number of highlights. The algorithm picks up to min(1, floor(S/2)) sentences as part of the summary. It picks at least the H sentences with the highest scores. After sentence H is picked, subsequent sentences will only be picked if their score was at least (80+3*X)% of the previously-picked sentence’s score, where X is the number of sentences currently picked. This is effectively a fairly arbitrary metric to pick the most likely sentences roughly in accordance with the size of the abstractive summary, while also allowing for particularly similar sentences to both be chosen for completeness.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;All data input and output with UTF-8 encoding.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Output format:&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;&amp;lt;#&amp;gt; &amp;lt;SENTENCE PLAINTEXT&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;# is either 0 = normal sentence in the article, 1 = sentence chosen as part of extractive summary, 2 = original abstractive summary (should not be touched by model, only left there for human reference). &lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Overall, we think our data set is generally reasonable and makes sense. Nonetheless, there are a number of weaknesses with both extractive models in general and this specific type of dataset (including some problems which derive from the original abstractive dataset).&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Key weaknesses of data set:&lt;/span&gt;&lt;/div&gt;&lt;ul style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;In the original data, highlights do not always correspond to actual information in the article. For example, this short story has four highlights that are all new information: 008fc24ca9f4c48a54623bef423a3f2f8db8451a.story.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Frequent formatting problems - sentences that don’t terminate with punctuation, repeated sentences, bugged unicode characters, etc.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Key weaknesses specific to extractive summarization:&lt;/span&gt;&lt;/div&gt;&lt;ul style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Articles that are particularly short are effectively impossible to meaningfully summarize with extractive techniques.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Some sentences in articles contain the same content with slightly different wording. In these cases, we decided to choose both sentences, with the idea that post-processing could take care of highly-similar sentences, but a model could not be expected to accurately distinguish between two such sentences if they have different labels.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;The Baseline Model:&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;For our baseline combinatorial approach, we did a simple Maximum Coverage Problem implementation. The Maximum Coverage Problem is a classic NP-complete problem. Given a collection of n sets, the goal is to maximize the number of chosen (or “covered”) elements while only choosing k of the sets (where k &amp;lt; n). It’s very straightforward to reduce summarization to this problem. The sentences in the document are the sets, and the vocabulary of the document represents the “universe”, or the elements in the sets. The goal is to cover as many words as possible while picking the same number of sentences as in the labelled summary. The intuition is that sentences with more words capture more semantic meaning, and once a word is listed in the summary, that word need not be considered again. This reduction makes some intuitive sense, but two main aspects must be refined. First, not all words are equally meaningful. Some words, like “a”, “the”, or “and”, have little semantic content, while named entities and other important words have much higher semantic content. Second, we should at least account for sentence lengths -- instead of constraining the algorithm to pick the same number of sentences, we should constrain it to the same word count. This two additional criteria turn the problem into the Budgeted Maximum Coverage Problem: elements in the sets have specified values, and the sets have specified costs. The new objective is to maximize the total value of the covered elements while remaining with a given budget.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Of course, this problem is NP-complete, so it may seem like a strange choice to model summarization with. There are two approaches to this. First, a simple greedy algorithm achieves an approximation of ~63%, which means that the greedy algorithm is guaranteed to get at least 63% of the value of the optimal solution. For the standard MCP, the greedy algorithm just chooses the set with the most uncovered elements until no more sets are allowed. For the budgeted MCP, the approximation algorithm is slightly more complex. See Khuller et al. for a detailed look at it -- the algorithm is slightly more work, but still very understandable, and achieves the same approximation bound.  We can also formulate the problem as an Integer Linear Program (ILP) and use an ILP solver to generate optimal solutions on realistic instance sizes. This works because the documents and sentences are both small.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;For now, we are using the greedy algorithm for the standard MCP. As a simple metric, we used the number of correct chosen sentences divided by the number of chosen sentences in total (correct means that the gold standard also picked that sentence). With a basic MCP approach, we had an accuracy of 0.218. This was measured on a small sample of 2000 stories. In order to approximate a weighting scheme, we use a stop list to simply remove common articles and other semantically empty words. With this small modification, we had an accuracy of 0.2328.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;We plan to extend this to a better baseline model in the next few days. We will formulate the problem as an ILP and pass it to an ILP solver for an optimal solution. We will also implement a more sophisticated weighting scheme. One idea is to use some of the labelled data as training data (right now, we don’t train) to build a weight matrix for common words -- we can build this matrix with a logistic regression, using n-gram (probably unigram) similarity as the loss function.This will hopefully give us a more reasonable baseline model.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Evaluation Framework:&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;For now, we’re using a simple accuracy metric. We plan to switch to ROUGE, which counts n-gram similarity (ROUGE measures recall, not precision). We will work with the ROUGE-2.0 Java package or pyrouge, depending on which language we are working with. &lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;So to summarize our goals for the next week, we will improve this baseline model by formulating the problem as an ILP and we may implement a weighting scheme (if that’s too complicated, we’ll save it for the advanced model). We will also build a baseline neural model. Then, we’ll flesh out our evaluation framework using ROUGE metrics, train/test using more of the corpus, and have detailed error analysis.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 700; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;References:&lt;/span&gt;&lt;/div&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Khuller, S., Moss, A., &amp;amp; Naor, J. (Seffi). (1999). The Budgeted Maximum Coverage Problem. &lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Inf. Process. Lett.&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;70&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;(1), 39–45. https://doi.org/10.1016/S0020-0190(99)00031-9&lt;/span&gt;&lt;/div&gt;</description>
	<pubDate>Wed, 18 Apr 2018 06:25:00 +0000</pubDate>
	<author>noreply@blogger.com (Ron &amp; Aditya)</author>
</item>
<item>
	<title>Kuikui Liu, Nicholas Ruhland &lt;br/&gt; Team INLP: NLP Capstone Post #4: Baseline and MIDI Frustration</title>
	<guid isPermaLink="false">http://mathstoc.wordpress.com/?p=314</guid>
	<link>https://mathstoc.wordpress.com/2018/04/18/nlp-capstone-post-3-baseline-and-midi-frustration/</link>
	<description>&lt;h1&gt;&lt;b&gt;Baseline model&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Our baseline approach is taken from Daniil Pakhomov’s excellent blog post[1]. In this post, two separate RNNs are trained as generators: one for lyrical content and one for music content (in piano roll format). We will begin by using his trained lyrical model, and attempt to do conditional sampled character generation given a starting sequence of characters. We loaded the already trained models from the blog post and generated lyrics according to the style of a given songwriter and with a given seed word. The lyrics are generated via a character-level LSTM and generates the next character conditioned on the preceding characters and choice of songwriter. The model is trained on a corpus of song lyrics, where naturally the “correct” character to generate is the next character in the lyrics. Essentially the same mechanism is applied to the musical note generation.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;The characters are encoded as a one-hot vector over all letters in the English alphabet plus space, comma, etc. Piano rolls already come in an encoding amenable to feeding into RNNs, modulo additional zero padding to ensure every time slice of every piano role has the same dimension. In particular, at each time step (discretized in an appropriately fine-grained way), we have an indicator 0-1 vector on which notes are currently activated.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Here is a song generated in the style of “Queen” with the starting seed sequence of characters “Music”:&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;Music savor valerite – yah  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;Imabribot, bind me – I – well  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;All going down to L&lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;At the eyes of the universe  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;Agree, five to the Slim  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;I just want to convincide  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;We wash stars and quiet Ich  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;You had a dirty old baby  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;We won’t  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;We does nothing no one ezy? follohin?  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;Sometimes we get down and ooh  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;Nothing do you see all night  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;This is my pries  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;Joyful the world  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;Does their beams  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;Surgeon makes the scule la beat  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;Walking out on my pocket ride  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;My faulty power  &lt;/i&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;i&gt;I wear from the ston&lt;/i&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Eventually, since we are actually interested in converting the musical information into plausible lyrics, we will need to modify this baseline in the natural way to take as input time slices of the musical instrumentation in piano roll format and predict characters (or syllables) that are to be enunciated simultaneously with the played notes. In this manner, the lyrics come already aligned in a natural way, and the words can be extracted by compressing the letters occurring between spaces.&lt;/span&gt;&lt;/p&gt;
&lt;h1&gt;&lt;b&gt;Dataset parsing&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;The MIDI format has an unfortunate number of unexpected caveats. We have spent a majority of our time so far cleaning the data and attempting to use it in existing Python libraries that handle MIDI. A brief description of MIDI[2] covers some of the challenges:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li style=&quot;font-weight: 400;&quot;&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;MIDI is made up of a series of messages, such as notes, instruments, and tempo changes. Additional metadata messages exist called meta messages, which can contain text content such as the song title (and lyrics!). In our dataset, lyrics are provided either as “text” messages or as “lyrics” messages.&lt;/span&gt;&lt;/li&gt;
&lt;li style=&quot;font-weight: 400;&quot;&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Messages are grouped into different tracks, often representing separate instruments. Metadata sometimes is located in its own track, and lyrics are sometimes found in a different track from the rest of the metadata.&lt;/span&gt;&lt;/li&gt;
&lt;li style=&quot;font-weight: 400;&quot;&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Durations in the MIDI format are specified as a delta-time relative to the most recent frame. Delta times are in a unit called a tick. Ticks are defined in the file header as a division of the quarter note. The header also defines the number of ticks per frame, which is what the deltas are relative to. Beats per minute (bpm) messages adjust the speed of playback throughout the song.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;The most promising library so far is PrettyMIDI[3], which handles most of the unexpected behavior of the basic MIDI format. This library wraps MIDI messages into structured python objects, and provides a conversion from MIDI into piano roll format. Piano roll in this case is a numpy array of shape (num_notes, num_frames). This allows us to input the musical data directly into an RNN. The units are also converted into absolute seconds, as opposed to relative durations. PrettyMIDI can additionally handle embedded lyrics, but this has proven to be a challenge due to the variety of annotation styles in our dataset. About 200 of our 900 files have parsed lyric data properly, so continuing to clean our data is a high priority.&lt;/span&gt;&lt;/p&gt;
&lt;h1&gt;&lt;strong&gt;U&lt;/strong&gt;pd&lt;strong&gt;ate&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;Unfortunately, we have found the Kara1k dataset[4] to be inapplicable to our project, as the raw sequence of musical notes and lyrical content are not provided, only metadata that the dataset developers have extracted.&lt;/span&gt;&lt;/p&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;[1] &lt;/span&gt;&lt;a href=&quot;http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/&quot;&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;[2] &lt;/span&gt;&lt;a href=&quot;http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html&quot;&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;[3] &lt;/span&gt;&lt;a href=&quot;http://craffel.github.io/pretty-midi/&quot;&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;http://craffel.github.io/pretty-midi/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;[4] &lt;/span&gt;&lt;a href=&quot;http://yannbayle.fr/karamir/kara1k.php&quot;&gt;&lt;span style=&quot;font-weight: 400;&quot;&gt;http://yannbayle.fr/karamir/kara1k.php&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;</description>
	<pubDate>Wed, 18 Apr 2018 04:58:56 +0000</pubDate>
</item>
<item>
	<title>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde: First Strawman Attempt</title>
	<guid isPermaLink="true">http://sarahyu.weebly.com/cse-481n/first-strawman-attempt</guid>
	<link>http://sarahyu.weebly.com/cse-481n/first-strawman-attempt</link>
	<description>&lt;div class=&quot;paragraph&quot;&gt;Well...here's the first hiccup: the Reddit data I'd like to use is much too large (like 8GB compressed and unknown uncompressed for one month of posts). Since my last post, I had been working on trying to scrape the data manually through Reddit API requests, but I was running into some issues and it was taking quite a while because of the request restrictions.&lt;br /&gt;&lt;br /&gt;I decided, maybe a little later than I should have, to use the Reddit Data dumps provided by John Baumgartner at pushshift.io instead, but much of the recent data is too large for my computer, attu, as well as my Azure instance. I am working with a grad student to get access to more resources so that I can work with (or even open) some of these files! However, in the meantime I have committed some files that &lt;em&gt;would &lt;/em&gt;be my strawman. I have a list of 124 subreddits labeled as the neurodivergent subreddit subset and currently have a model that builds a set of users that post to these subsets, finds the other neurotypical subreddits those users also post to, and aggregates a set of those subreddits. The strawman compares the basic n-grams in each subset of the subreddits to see basic language model differences. I also cloned the vennclouds github project to try and visualize the n-grams (uni, bi, and tri) that are used in these two subsets as well as their overlap however, the current version seems to have a basic bug.&lt;br /&gt;&lt;br /&gt;I will get the resources hopefully in the next couple of days and update this post with the actual data results! &lt;br /&gt;&lt;br /&gt;&lt;em&gt;To be continued...&lt;/em&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;</description>
	<pubDate>Wed, 18 Apr 2018 03:47:19 +0000</pubDate>
</item>
<item>
	<title>Halden Lin &lt;br/&gt; Team undef.: NLP Capstone | 03: Project Proposal</title>
	<guid isPermaLink="false">https://medium.com/p/7d8e9ec1a8e3</guid>
	<link>https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3?source=rss-2759d54493c0------2</link>
	<description>&lt;p&gt;&lt;em&gt;previous posts: &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5&quot;&gt;&lt;em&gt;01&lt;/em&gt;&lt;/a&gt;&lt;em&gt; &lt;/em&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5&quot;&gt;&lt;em&gt;02&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Towards a Better Understanding of Neural Networks: Visualizing Attention in Sequence-to-Sequence Models&lt;/h3&gt;&lt;h4&gt;A brief review of attention&lt;/h4&gt;&lt;p&gt;The idea of ‘attention’ was first introduced to the sphere of natural language processing by Bahdanau et al. (2014) in &lt;em&gt;Neural machine learning by jointly to align and translate&lt;/em&gt;. The idea is fairly straightforward: if we have an encoder-decoder model, at each decoding time-step we generate a vector of attention weights corresponding to each of the encoding units. That is to say, when generating each output token, we pay ‘attention’ to certain parts of the input sequence. Intuitively, this is much how we as humans fixate on parts of text to perform tasks such as summarization or question answering.&lt;/p&gt;&lt;h4&gt;Why visualization?&lt;/h4&gt;&lt;p&gt;In Machine Learning, neural networks have always been a sort of black box. We know they work incredibly well in certain contexts, but its often difficult to understand why they work so well. The following quote sums up the need for interpretability quite well.&lt;/p&gt;&lt;blockquote&gt;&lt;strong&gt;&lt;em&gt;“I believe the most important direction for future research is interpretability.&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; The attention mechanism, by revealing what the network is “looking at”, shines some precious light into the black box of neural networks, helping us to debug problems like repetition and copying. To make further advances, we need greater insight into what RNNs are learning from text and how that knowledge is represented.”&lt;/em&gt;&lt;/blockquote&gt;&lt;blockquote&gt;- Abigail See, PhD - Stanford University, &lt;em&gt;‘So, is abstractive summarization solved?’&lt;/em&gt; from &lt;a href=&quot;http://www.abigailsee.com/2017/04/16/taming-rnns-for-better-summarization.html&quot;&gt;Taming Recurrent Neural Networks for Better Summarization&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;Visualization provides an avenue for interpretability by mapping the behavior of the complex networks to easy-to-understand visual encodings.&lt;/p&gt;&lt;h4&gt;A survey of related work&lt;/h4&gt;&lt;p&gt;Although I am not aware of any papers dedicated to the visualization of attention, examples can be readily found in both published literature and online blogposts. For each example below, I’ll point out strengths and weaknesses. Ultimately, I hope to show that there are improvements we can make that can augment the interpretability of the workings of seq2seq attentional models.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Heat-maps&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/404/0*9FCWt3AO5oGxLxtg.&quot; /&gt;Bahdanau et al. (2014). An attention visualization for a seq2seq problem (in this case, translation). Whiter cells represent higher attention.&lt;/figure&gt;&lt;p&gt;The encoding scheme used by Bahdanau et al. (2014) themselves, heat-maps were the most common encoding of attentional data I found. While making the task of relative correlation lookup efficient, these have a couple of weaknesses.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Hard to scale. With tasks involving large input or output (e.g. a hundred or more tokens) the size of the heat-map quickly gets out of hand. Scrolling greatly decreases the effectiveness of a visualization with respect to analysis tasks.&lt;/li&gt;&lt;li&gt;Difficult to read. We generally don’t read in a token-per-line format. Furthermore, source text is rarely in a token-per-line format — we lose insightful information that could be drawn from analyzing the original structure of the text.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;Flow-maps&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*I3cdFcqDAcdKEwuCpAPHTA.png&quot; /&gt;Rikters et al (2017). The input sequence is seen on top — output on bottom. Thicker lines denote higher attention.&lt;/figure&gt;&lt;p&gt;Less common, but interesting nonetheless. This kind of flow-map suffers from problems similar to those of heat-maps. One could also argue that the thinness of the lines and their cross-hatch nature hinder interpretability.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Interaction&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/800/1*3dTXvSI-L3X3M-MKXRraBA.gif&quot; /&gt;See et al. (2017). Interactive visualization of attention&lt;/figure&gt;&lt;p&gt;Interaction solves many of the issues of the static visualizations surveyed above. We retain the structure of both the input and output text, and lookup is quick and efficient. There is a trade-off, however. We are only able to view the attention of a single word at a time, and as a result it is hard to get a sense of the overall coverage or structure of attention.&lt;/p&gt;&lt;h4&gt;A case study: Summarization&lt;/h4&gt;&lt;p&gt;In particular,&lt;strong&gt; abstractive summarization&lt;/strong&gt;. Summarization is a particularly interesting use case of attention because of the requirement of the condensing of text. The hypothesis is that good abstractive models will be able to cover the majority of the original document. Here I note the difference between &lt;strong&gt;extractive &lt;/strong&gt;and&lt;strong&gt; abstractive &lt;/strong&gt;summarizations. The former involves selecting pieces of the original text, verbatim. The latter involves compressive paraphrasing.&lt;/p&gt;&lt;p&gt;Until recently, most of the work in text summarization has revolved around extractive summarization (See et al. 2017). However, the rising prevalence of recurrent neural networks has allowed for further focus in abstractive summarization. Attention has played an important role in improving results. Below is a brief list of relevant work.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1509.00685.pdf&quot;&gt;Rush, Alexander M. et al. “A Neural Attention Model for Abstractive Sentence Summarization.” &lt;em&gt;EMNLP&lt;/em&gt; (2015).&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1602.06023.pdf&quot;&gt;Nallapati, Ramesh et al. “Abstractive Text Summarization using Sequence-to-sequence RNNs and Beyond.” &lt;em&gt;CoNLL&lt;/em&gt; (2016).&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1712.06100.pdf&quot;&gt;Hasselqvist, Johan et al. “Query-Based Abstractive Summarization Using Neural Networks.” &lt;em&gt;CoRR&lt;/em&gt; abs/1712.06100 (2017): n. pag.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1705.04304.pdf&quot;&gt;Paulus, Romain et al. “A Deep Reinforced Model for Abstractive Summarization.” &lt;em&gt;CoRR&lt;/em&gt; abs/1705.04304 (2017): n. pag.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1704.04368.pdf&quot;&gt;See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” &lt;em&gt;ACL&lt;/em&gt; (2017).&lt;/a&gt;&lt;/p&gt;&lt;h4&gt;Summarization Specific Challenges&lt;/h4&gt;&lt;p&gt;While visualizations of attention are helpful in shedding light on the workings of seq2seq models, summarization models in particular have trouble leveraging this window.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;We care about &lt;strong&gt;where&lt;/strong&gt; attention falls just as much as what it falls on. We hope to maximize &lt;strong&gt;coverage&lt;/strong&gt;. This is not currently addressed in any interactive visualizations I am aware of.&lt;/li&gt;&lt;li&gt;We have large input sequences. As discussed in &lt;strong&gt;“A survey of related work,”&lt;/strong&gt; this is particularly problematic for static visualizations.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;With this in mind, I propose areas for improvement in both interactive and static visualizations.&lt;/p&gt;&lt;h4&gt;Where to?&lt;/h4&gt;&lt;p&gt;With interactive visualizations, two things.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;One. Coverage &lt;/strong&gt;is the aggregated attention over a sequence of output tokens. An example given by See et al. can be seen in the figure below. Perhaps allowing brushing to visualizing the aggregate attention over a phrase or sentence can help us understand attention in a more global context.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/956/0*vE-iXohphbWY6Nam.&quot; /&gt;See et al. (2017). Example of coverage.&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;Two. Extraction vs Abstraction: &lt;/strong&gt;Ideally, we want our model to learn how to abstract rather than extract. 1:1 exact match attention is less interesting to see than seeing attention to groups of words. Perhaps emphasizing / de-emphasizing can this in visualizations can help aid understanding of models.&lt;/p&gt;&lt;p&gt;With static visualizations, there are two analysis tasks that we wish to optimize for.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Summary. &lt;/strong&gt;What is the overall structure of the attention (e.g. coverage).&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Value. &lt;/strong&gt;Which input words are attended (i.e. focused on) by each output timestep?&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;It is difficult to design an &lt;em&gt;effective&lt;/em&gt; static visualization that lends itself well to both of these tasks. Perhaps we need a set of visualizations. For example, one visualization might afford better performance for summary analysis, while another might afford better performance for value analysis. In addition, these static visualizations can incorporate ideas described in previous section.&lt;/p&gt;&lt;p&gt;Additionally, attention visualizations thus far have been for &lt;strong&gt;specific examples&lt;/strong&gt;. Perhaps there a way we can look &lt;strong&gt;across examples&lt;/strong&gt; to better understand the behavior of these neural networks. Derived metrics for attention or coverage could be useful in better understanding and diagnosing these models.&lt;/p&gt;&lt;p&gt;My hope is that addressing these items in both interactive and static visualizations will allow us to better reason about neural networks. In particular, I hope the result can be used as a valuable tool for error analysis, &lt;strong&gt;even&lt;/strong&gt; &lt;strong&gt;beyond&lt;/strong&gt; hyperparameter tuning. Insights could be gleamed that motivate additions or constraints or mechanisms to optimize coverage (e.g. See et al. (2017)) or abstraction.&lt;/p&gt;&lt;h4&gt;The Plan&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Minimum Viable Plan&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Develop a TensorBoard plugin that allows for the static and interactive visualizations described in &lt;strong&gt;Where to?&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Acquire feedback from students / researchers in the Allen School.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;I intend to leverage existing models to retrieve data. For example, that &lt;a href=&quot;https://github.com/abisee/pointer-generator&quot;&gt;provided publicly&lt;/a&gt; by See et al. (2017). The dataset used by them is a &lt;a href=&quot;https://github.com/abisee/cnn-dailymail&quot;&gt;modified CNN/Daily Mail Dataset&lt;/a&gt; [Hermann et al. (2015), See et al. (2017)] — a collection of articles and bullet point summaries.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Stretch Goals&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Explore and implement aggregate, cross-example visualizations as described in &lt;strong&gt;Where to?&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Release a beta of the TensorBoard plugin on github and acquire feedback there.&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;Works Cited&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1704.04368.pdf&quot;&gt;See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” &lt;em&gt;ACL&lt;/em&gt; (2017).&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1506.02078.pdf&quot;&gt;Karpathy, Andrej, Justin Johnson, and Li Fei-Fei. “Visualizing and understanding recurrent networks.” &lt;em&gt;arXiv preprint arXiv:1506.02078&lt;/em&gt;(2015).&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1712.06100.pdf&quot;&gt;Hasselqvist, Johan et al. “Query-Based Abstractive Summarization Using Neural Networks.” &lt;em&gt;CoRR&lt;/em&gt; abs/1712.06100 (2017): n. pag.&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1602.06023.pdf&quot;&gt;Nallapati, Ramesh et al. “Abstractive Text Summarization using Sequence-to-sequence RNNs and Beyond.” &lt;em&gt;CoNLL&lt;/em&gt; (2016).&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1705.04304.pdf&quot;&gt;Paulus, Romain et al. “A Deep Reinforced Model for Abstractive Summarization.” &lt;em&gt;CoRR&lt;/em&gt; abs/1705.04304 (2017): n. pag.&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1509.00685.pdf&quot;&gt;Rush, Alexander M. et al. “A Neural Attention Model for Abstractive Sentence Summarization.” &lt;em&gt;EMNLP&lt;/em&gt; (2015).&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1409.0473.pdf&quot;&gt;Bahdanau, Dzmitry, Kyunghyun Cho, and Yoshua Bengio. “Neural machine translation by jointly learning to align and translate.” &lt;em&gt;arXiv preprint arXiv:1409.0473&lt;/em&gt; (2014).&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1506.03340.pdf&quot;&gt;Hermann, Karl Moritz et al. “Teaching Machines to Read and Comprehend.” &lt;em&gt;NIPS&lt;/em&gt;(2015).&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=7d8e9ec1a8e3&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Thu, 12 Apr 2018 05:46:21 +0000</pubDate>
</item>
<item>
	<title>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde: Formal Proposal</title>
	<guid isPermaLink="true">http://sarahyu.weebly.com/cse-481n/formal-proposal</guid>
	<link>http://sarahyu.weebly.com/cse-481n/formal-proposal</link>
	<description>&lt;div class=&quot;paragraph&quot;&gt;Linguistic Accommodation for Self-Presentation as seen in Neurotypical vs. Neurodivergent Subreddits&lt;br /&gt;&lt;br /&gt;&lt;u&gt;Hypotheses:&lt;/u&gt; &lt;br /&gt;1) Users change their language depending on the community, represented by subreddits categorized as Neurotypical vs Neurodivergent&lt;br /&gt;      - The divergence from their own baseline is a&lt;span&gt; sign of assimilation through tuned self-presentation*&lt;/span&gt;&lt;br /&gt;2) Language Models, as used by the whole community, differ and not just in topic-specific jargon&lt;br /&gt;      - The language changes of the individual user and the change in delta from the community's language model is a sign of their attempt at assimilating language accommodation*&lt;br /&gt;          - Do certain users adapt better? If so, what is differentiating those users?&lt;br /&gt;&lt;font size=&quot;1&quot;&gt;*(subpoints are very similar, and I'm still working through if there is a nuance, or if they're the same)&lt;/font&gt;&lt;br /&gt;&lt;br /&gt;My &lt;strong&gt;objective&lt;/strong&gt;, then, is to address these hypotheses through the following approach:&lt;br /&gt;&lt;br /&gt;&lt;u&gt;Literature Survey:&lt;/u&gt;&lt;br /&gt;While this project is novel, mainly in the focus on neurotypical vs neurodivergent separation and the use of Reddit data, this project finds guidance from previous work done on similar questions. First, this project aims to extend upon the work of Danescu-Niculescu-Mizil et al. in&lt;em&gt; &lt;/em&gt;&lt;u&gt;&lt;em&gt;Mark My Words! Linguistic Style Accommodation in Social Media​.&lt;/em&gt;&lt;/u&gt; This was the first large-scale endeavor in identifying linguistic accommodation using social media. However, our project extends this work by taking advantage of the siloed nature of Reddit to identify linguistic accommodation employed by a single user across communities as opposed to the one-dimensional view of a user's linguistic accommodation to the general twittersphere in Danescu's paper. Also, this project is informed by Fast and Horvitz in &lt;u&gt;&lt;em&gt;Identifying Dogmatism in Social Media: Signals and Models&lt;/em&gt;&lt;/u&gt;, specifically in their methodologies and models; I attempt to extend upon these with more complex models. In this process, I also found several works that were similar in nature: Tamburrini et al. on language change based on social identity on Twitter, Nguyen and Rose on language socialization in online communities, and Michael and Otterbacher on herding in online review language. Two more relevant works for my project are De Choudhury et al.'s work on identifying the shift to Suicidal Ideation in social media and D&lt;span&gt;anescu-Niculescu-Mizil's work on the life-cycle of users in online communities. &lt;br /&gt;​&lt;br /&gt;&lt;u&gt;Proposed Methodologies&lt;/u&gt;: &lt;/span&gt;&lt;br /&gt;In it's most basic form, these questions can be explored with basic language models. First, we will identify a subset of neurotypical and neurodivergent subreddits to explore (100 or so respectively), chosen by a preliminary search on overlapping users posting between these. Based on this preliminary search, we will also gain a set of users who potentially post to both neurotypical and neurodivergent subreddits (we may need to look only at posts within a band of characters, but that is a parameter I'd like to explore). We will aggregate all of a user's posting history, not just in the subset aforementioned, to model the user's language use and do the same for the language of all posts made by any user (not just our set) to the subreddit to model the subreddit's language. I will supplement these models with the LIWC lexicon to characterize the differences between the communities and between users in different subreddits. (I may use a subset of the LIWC categories later on). A more complex model would be to use PPDB to find differences via paraphrasing. Yet another complex model would be to use a graphical model as inspired by Bamman et al's &lt;em&gt;&lt;u&gt;Learning Latent Personas of Film Characters&lt;/u&gt;&lt;/em&gt;. A stretch goal would be to train an RNN model for the language model of a neurotypical subreddit and that of a neurodivergent to see the probability of a post to belong to either of these categories. A stretch goal (not in complexity as in the RNN, but rather in interest) is to use the &lt;em&gt;Zelig Quotient&lt;/em&gt;, a proposed measure for normalizing linguistic accommodation by Jones et al and see how much this may affect our findings. &lt;br /&gt;One special consideration is the use of NSFW language. My only filter will be to disqualify the list of NSFW subreddits, as named by a reddit post (so meta) in being chosen for the subsets, but otherwise we will not do anything special for NSFW language in other subreddits. &lt;br /&gt;&lt;br /&gt;&lt;u&gt;Resources&lt;/u&gt;: Lots of Reddit fun!!!&lt;br /&gt;&lt;br /&gt;&lt;em&gt;​Here goes nothing...&lt;/em&gt;&lt;/div&gt;</description>
	<pubDate>Wed, 11 Apr 2018 07:00:00 +0000</pubDate>
</item>
<item>
	<title>Ananth Gottumukkala &lt;br/&gt; Team Turing Test: Project Proposal: Question-Based Knowledge Representation</title>
	<guid isPermaLink="false">http://deeplearningturingtest.wordpress.com/?p=14</guid>
	<link>https://deeplearningturingtest.wordpress.com/2018/04/11/project-proposal-question-based-knowledge-representation/</link>
	<description>&lt;p&gt;&lt;strong&gt;Project Objective:&lt;/strong&gt; The objective of this project is to create a model that can build a representation of the knowledge it’s gathered by reading the input text line by line and asking appropriate clarifying questions to a human for further insight.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Literature Survey:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;cite class=&quot;formatted-citation formatted-citation--style-mla&quot;&gt;Williams, Jason D. et al. “Hybrid Code Networks: practical and efficient end-to-end dialog control with supervised and reinforcement learning.” &lt;em&gt;ACL&lt;/em&gt; (2017).&lt;/cite&gt;&lt;/li&gt;
&lt;li&gt;
&lt;div class=&quot;padded&quot;&gt;&lt;cite class=&quot;formatted-citation formatted-citation--style-mla&quot;&gt;Zhang, Qianqian et al. “A Review on Entity Relation Extraction.” &lt;em&gt;2017 Second International Conference on Mechanical, Control and Computer Engineering (ICMCCE)&lt;/em&gt; (2017): 178-183.&lt;/cite&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;Arvind Neelakantan’s Doctoral Disseration: &lt;em&gt;Knowledge Representation and Reasoning with Deep Neural Networks (2017)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;
&lt;div class=&quot;padded&quot;&gt;&lt;cite class=&quot;formatted-citation formatted-citation--style-mla&quot;&gt;Zhao, Tiancheng and Maxine Eskénazi. “Towards End-to-End Learning for Dialog State Tracking and Management using Deep Reinforcement Learning.” &lt;em&gt;SIGDIAL Conference&lt;/em&gt; (2016).&lt;/cite&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Minimal Viable Action Plan:&lt;/strong&gt; My minimum action plan would be to implement and train an RL model to ask certain question template(s) as clarification as it processes input text line by line. Then a human (myself) would assign a reward to indicate the quality of the question and give a brief answer to the question. This brief answer would then be used to expand the model’s stored knowledge representation and the assigned reward would be used to train the RL model. This series of exchanges is treated like a one-on-one conversation even if it’s more like a one-sided lecture.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stretch Goals:&lt;/strong&gt; Stretch goals include extracting features from the existing knowledge base and feeding those into the model to further improve the relevancy of questions (for example not asking questions that the model should already know). Another stretch goal would be to translate the knowledge representation back into everyday English text for tasks such as answering reading comprehension questions. This can be done either by training a Machine Translation model, using a parser like ANTLR, or some other method.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposed Methodologies:&lt;/strong&gt; My proposed methodologies follows a similar outline as given by Williams et al. in their paper on Hybrid Code Networks (HCNs).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The input text is read in line-by-line and goes through various preprocessing steps like entity extraction, word embeddings layer, sentiment analysis, bag of words, etc. These features are concatenated and fed into the model.&lt;/li&gt;
&lt;li&gt;In the HCN paper, the model was an RNN followed by a softmax layer (probability distribution over the various actions to take).
&lt;ul&gt;
&lt;li&gt;In this problem, the “actions” to take are the different types of question templates to ask so copying this model and substituting their action templates with my question templates would work.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;An alternative approach would be to build a Deep Q Network model with an LSTM (or GRU) layer at the end, so the network would update the Q values for each question type that can be asked (and the one with the highest Q value can be greedily selected). For clarification, each input sentence would represent a time step.&lt;/li&gt;
&lt;li&gt;After a question type is selected with either of the 2 approaches above, nouns need to be substituted in to form an actual question (as in the HCN paper). For example, a question template might be “Is there a relationship between ______ and ______?” and the two blanks need to be filled in with nouns. If the substitution results in a good question, a good reward is assigned and otherwise, a very negative reward is assigned. If it’s a good question, then an answer is given to update the knowledge representation.
&lt;ul&gt;
&lt;li&gt;Some possible ways to create this knowledge representation is to use lists, trees, semantic networks, production rules, logical propositions and/or other existing NLP knowledge representation models (I haven’t decided on one yet).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Available Resources/Databases:&lt;/strong&gt; To train the model, any reading comprehension dataset like MS Marco (Microsoft), SQuAD (Stanford), RACE, etc. can be used. If my project is successful enough, I can even use these datasets for evaluation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Evaluation Plan:&lt;/strong&gt; If I only finish my minimum viable action plan, I’m not sure how I can qualitatively assess my knowledge representation except by comparing the representation against the information I wanted to be recorded (or have other people judge what knowledge should be stored). On the other hand, if I finish my stretch goals (translating knowledge representation to English) I can try to use the knowledge representation to train on and respond to queries in a reading comprehension dataset (which would be a much more qualitative evaluation).&lt;/p&gt;</description>
	<pubDate>Wed, 11 Apr 2018 06:59:08 +0000</pubDate>
</item>
<item>
	<title>Aaron Johnston, Lynsey Liu &lt;br/&gt; Team Viterbi Or Not To Be: Formal Project Proposal</title>
	<guid isPermaLink="false">https://medium.com/p/7b6d1a9ec67c</guid>
	<link>https://medium.com/@viterbi.or.not/formal-project-proposal-7b6d1a9ec67c?source=rss-c522ef075bb3------2</link>
	<description>&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*cr8jfKVLjgd9Y7YmxXWSYA.png&quot; /&gt;&lt;/figure&gt;&lt;p&gt;Introducing our project topic, &lt;strong&gt;automatic conversation summarization&lt;/strong&gt;! Our proposal will outline specific objectives, motivations, and plan we have for this project. We also cover here the resources we have gathered — related work, datasets (as promised), and evaluation frameworks, to demonstrate viability and give background on the topic.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Objective&lt;/strong&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*DmM6aXAhZi61Ec7Yhp6YBw.png&quot; /&gt;Example summarization of an email chain from the &lt;a href=&quot;https://www.cs.ubc.ca/cs-research/lci/research-groups/natural-language-processing/bc3.html&quot;&gt;W3C email threads corpus&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;In the field of automatic text summarization, there are numerous techniques that can be used to produce summaries of general text data. However, for our project, we seek to work on a more specific type of data by exploring and evaluating techniques for summarization of conversation logs. Therefore, the models we will attempt to implement and measure will take input in the form of natural text from conversations, such as email threads, chat logs, or transcribed spoken conversations, and output more concise summaries that capture the most important parts of the input.&lt;/p&gt;&lt;p&gt;While a document or paper typically sticks to a single topic at once and represents communication between an author and the reader, conversational data is characterized by a mixing of sub-topics and, in many cases, contributions from multiple different authors before one topic is finished. As a result, the objective of conversational summarization includes identifying topics and threads among a potentially chaotic conversation in order to make a sensible summarization even without the benefit of a single, linear topic progression.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Extractive vs. Abstractive&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;When considering text summarization, a distinction has to be made between two different approaches to summarization that offer different levels of implementation difficulty and usefulness. An extractive summary is produced by identifying the most important sentences from the input text and combining them to form a summary that is the concatenation of those sentences.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*iZujvW2rP_HSVU2KXLtvew.png&quot; /&gt;Example of a short chatlog and its corresponding extractive summary&lt;/figure&gt;&lt;p&gt;Alternatively, an abstractive summary consists of new text generated from the topics and important aspects of the input text, but requires the model to create new summary sentences rather than simply re-using existing ones. As a result of this generation process, abstractive summaries are typically considered to be more useful, because they consist of natural-sounding text while still paraphrasing the concepts that are important. However, current techniques perform much better at generating extractive summaries, which are considered much easier to implement because they only require assigning scores to the sentences of the input.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*1oiGv-MrfdubjbKv-Vp9fA.png&quot; /&gt;Example of a short chatlog and its corresponding abstractive summary&lt;/figure&gt;&lt;h4&gt;&lt;strong&gt;Motivation&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;The &lt;strong&gt;academic&lt;/strong&gt; motivations behind our project are to pursue a topic in summarization that has been relatively less explored. This means tackling the challenges that come with the conversation summarization domain — annotated conversation datasets are typically smaller and more unpredictable, and whereas tasks like document summary usually involve one topic written by one author/voice, conversations and involve many participants and have less well-defined topic segmentation.&lt;/p&gt;&lt;p&gt;The project is also motivated by the possibly impactful &lt;strong&gt;applications &lt;/strong&gt;of conversation summarization. Being able to summarize long chains of emails or group IMs is an increasingly important task to tackle in today’s world and can be a useful augmentation to digital group conversations.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Related Work&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;In our literature survey, we will first discuss the two papers that have been most impactful in helping establish our project plan.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*U0i-moKx4s_YB3My.&quot; /&gt;Graph of contributions of general feature categories to the performance of logistic regression classifiers&lt;/figure&gt;&lt;p&gt;&lt;a href=&quot;http://www.aclweb.org/anthology/D08-1081&quot;&gt;&lt;strong&gt;Summarizing Spoken and Written Conversations&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;¹ &lt;/strong&gt;uses meeting and email datasets. The authors of this paper approach extractive summarization with logistic regression classifiers and a mix of general summarization features as well as some basic conversation summarization features. The overall feature categories can be seen in the corresponding figure, which graphs the contributions of each feature category to the classifier’s performance. “Participant” category features were found to help achieve competitive results.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1010/0*wLl3u1tR-GKYuIql.&quot; /&gt;Table of performances of previously published models and the models used in the experiment (C4.5, NB, MLP, SVM)&lt;/figure&gt;&lt;p&gt;&lt;a href=&quot;http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf&quot;&gt;&lt;strong&gt;Summarizing Online Conversations: A Machine Learning Approach&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;²&lt;/strong&gt; uses chatlog and meeting datasets. The authors of this paper conduct experiments with Decision Tree, Naive Bayes classifier, Multilayer Perceptron (MLP) and Support Vector Machine (SVM) summarizers to create extractive summaries. The input feature vectors to these trainable summarizers use both general summarization features (sentence length, sentence position, similarity to title, etc.) as well as conversation specific summarization features that are more specialized than those mentioned in the previously discussed paper (is question, sentiment score, discourse markers). The paper overall found that the Naive Bayes classifier and MLP performed the best.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Datasets&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;The datasets we found cover a variety of conversation domains and are all human-annotated with summaries.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Email: &lt;/strong&gt;&lt;a href=&quot;https://www.cs.ubc.ca/cs-research/lci/research-groups/natural-language-processing/bc3.html&quot;&gt;&lt;strong&gt;W3C Email Threads&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;40 email threads of ~80 lines each&lt;/li&gt;&lt;li&gt;Extractive and Abstractive Summaries&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Chat: &lt;/strong&gt;&lt;a href=&quot;https://flossmole.org/content/software-archaeology-gnue-irc-data-summaries&quot;&gt;&lt;strong&gt;GNU Enterprise Chatlogs&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;~120 chats of ~1200 lines each&lt;/li&gt;&lt;li&gt;Abstractive Summaries&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Spoken Conversation: &lt;/strong&gt;&lt;a href=&quot;http://groups.inf.ed.ac.uk/ami/corpus/&quot;&gt;&lt;strong&gt;AMI Meeting Transcripts&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;140 meeting transcriptions of ~45 minutes each&lt;/li&gt;&lt;li&gt;Extractive and Abstractive Summaries&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;Evaluation&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;In terms of &lt;strong&gt;automated&lt;/strong&gt; methods of evaluation for the summaries that we will generate, there are a few frameworks we can use:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;BLEU&lt;/strong&gt; (BIlingual Evaluation Understudy)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Precision measure with some enhancements&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;METEOR&lt;/strong&gt; (Metric for Evaluation of Translation with Explicit ORdering)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Improves on BLEU by adding recall, synonyms&lt;/li&gt;&lt;li&gt;Better at sentence-level evaluation&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;ROUGE&lt;/strong&gt; (Recall-Oriented Understudy for Gisting Evaluation)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ROUGE-L&lt;/strong&gt;: Longest common subsequence&lt;/li&gt;&lt;li&gt;&lt;strong&gt;ROUGE-N&lt;/strong&gt;: Overlap of N-Grams between passages&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;However, for summarization tasks, &lt;strong&gt;human evaluation&lt;/strong&gt; is possibly most ideal and it is unclear if any automatic metric can be as effective.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Minimum Viable Product&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Our plan is to start with two &lt;strong&gt;baseline models&lt;/strong&gt; that replicate the best performing models (Naive Bayes and MLP approaches) of “Summarizing Online Conversations: A Machine Learning Approach” using the non-conversation specific features.&lt;/p&gt;&lt;p&gt;We would then experiment with tweaks to the baseline models that use conversation-specific features, both based off of the ones described in the paper and also based on some of our ideas about what kinds of domain-specific features might benefit conversation summarization. We can also continue to explore alternative models and compare model approaches.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Stretch Goals&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;There are a number of ideas we have for stretch goals that can push our project further:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Neural Network implementation: &lt;/strong&gt;Applying general summarization techniques to conversation&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Model entity relationships: &lt;/strong&gt;Identifying the role of a contributor or named entity, such as a supervisor in an email thread&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Abstractive summarization: &lt;/strong&gt;Convert a previously extractive summary to be natural-sounding and abstractive&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Optimize performance for a specific domain: &lt;/strong&gt;For example, in chats about bugfixes, use that specific context to try outperforming the general case&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Relate parameters from different types of data: &lt;/strong&gt;For example, use data from spoken corpus to improve results on email&lt;/p&gt;&lt;p&gt;We hope you enjoyed reading our project proposal and we are excited to get working!&lt;/p&gt;&lt;p&gt;[1] Murray, G. &amp;amp; Carenini, G. (2008). Summarizing Spoken and Written Conversations. &lt;em&gt;Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, &lt;/em&gt;773–782.&lt;/p&gt;&lt;p&gt;[2] Sood, A. &amp;amp; Varma, V. (2012). Summarizing Online Conversations: A Machine Learning Approach. &lt;em&gt;Centre for Search and Information Extraction Lab International Institute of Information Technology Hyderabad,&lt;/em&gt; 500.&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=7b6d1a9ec67c&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 11 Apr 2018 06:56:31 +0000</pubDate>
</item>
<item>
	<title>Kuikui Liu, Nicholas Ruhland &lt;br/&gt; Team INLP: NLP Capstone Post #3: Proposal</title>
	<guid isPermaLink="false">http://mathstoc.wordpress.com/?p=309</guid>
	<link>https://mathstoc.wordpress.com/2018/04/11/nlp-capstone-post-3-proposal/</link>
	<description>&lt;p&gt;Here, we finally present our project proposal in full.&lt;/p&gt;
&lt;h3&gt;Project Objectives:&lt;/h3&gt;
&lt;p&gt;Our goal for this project is to engineer a model that, given the instrumental (“karaoke”) music for a song in English represented as MIDI data, output a coherent sequence of words corresponding to lyrics for the music. The model will produce timings along with the words to align it with the background instrumentals. Additionally, given the output of the model and the input music, we will automate their combination into a song complete with lyrics and supporting instrumentals. This combined output will be playable and we intend to do live demonstration.&lt;/p&gt;
&lt;h3&gt;Proposed Methodology:&lt;/h3&gt;
&lt;p&gt;Here, we outline the steps we will need to take in detail.&lt;/p&gt;
&lt;li&gt;Data collection (datasets of songs, preferably with instrumentals and lyrics already separated)&lt;/li&gt;
&lt;li&gt;Decide on vocabulary and how to handle uncommon words&lt;/li&gt;
&lt;li&gt;Decide and implement any required preprocessing of the raw MIDI data. Strip lyrics from MIDI data if not already provided in dataset.&lt;/li&gt;
&lt;li&gt;Decide and implement model (see Model Design)&lt;/li&gt;
&lt;li&gt;Implement model sanity checks&lt;/li&gt;
&lt;li&gt;Model tweaking (we expect this will take the majority of the time; see Model Design)&lt;/li&gt;
&lt;li&gt;Implement automated combination of model output (lyrics) and model input (instrumentals)&lt;/li&gt;
&lt;li&gt;Further testing&lt;/li&gt;
&lt;li&gt;Assuming preceding steps are completed satisfactorily, proceed to stretch goals&lt;/li&gt;
&lt;li&gt;Presentation and write-up&lt;/li&gt;
&lt;h3&gt;Model Design:&lt;/h3&gt;
&lt;p&gt;We will pursue a seq2seq RNN approach, taking in input MIDI data represented as a sequence, and outputting a sequence of words from a specified vocabulary. This model will be referred to as the generator. We will employ adversarial training, simultaneously training a many-to-one RNN discriminator that, given the input instrumentals and corresponding lyrics, output if the lyrics were produced by the generator or not. We will follow approaches taken in previous works such as SeqGAN [2] (and [3, 4]), namely using policy gradient ideas from reinforcement learning to obtain gradients that can be backpropagated from the discriminator network through the generator network. We note that syntactic correctness can be enforced in this manner, as malformed lyrical output can be assigned arbitrarily small reward.&lt;/p&gt;
&lt;h3&gt;Stretch Goals:&lt;/h3&gt;
&lt;p&gt;There are several stretch goals we will consider, time permitted. They are as follows, in no particular order.&lt;/p&gt;
&lt;li&gt;Handling multiple languages, particularly those with less available data&lt;/li&gt;
&lt;li&gt;Given a specific songwriter/band, produce the instrumentals along with lyrics for a new song that is in the style of that songwriter/band&lt;/li&gt;
&lt;li&gt;Lyrics generation for duets, or multi-singer songs&lt;/li&gt;
&lt;li&gt;Playing with phoneme-level generation&lt;/li&gt;
&lt;h3&gt;Core Challenges:&lt;/h3&gt;
&lt;p&gt;The core challenges we will need to overcome include alignment of lyrics with the music, and production of sensible lyrics. On the more technical side, it is well-known that ensuring convergence in adversarial training is difficult.&lt;/p&gt;
&lt;h3&gt;Available Resources:&lt;/h3&gt;
&lt;p&gt;Existing music datasets for machine learning tasks are made up of audio samples (such as .wav or .mp3), or MIDI data that specifies timing and notes. For karaoke, lyrics are also provided either as a separate text file (.LRC) specifying the timing of each word, or can be embedded into the MIDI file directly (.KAR). It may also be useful to train a lyric model on a larger corpus of song lyrics, since lyrics are easier to collect than fully time-annotated karaoke files.&lt;/p&gt;
&lt;p&gt;The MusicNet dataset [9] provides 330 classical instrumental audio files, each of which has associated timing provided for every note. Since we are primarily interested in lyrical generation and alignment, this dataset is not going to be useful for creating a language model.&lt;/p&gt;
&lt;p&gt;An existing karaoke dataset called Kara1k [1] provides many features computed from 1000 lyric-annotated songs. This provides lots of metadata about each song, including annotated chords for each timestep of the song. According to the KaraMIR website, these features are extracted from audio samples using Vamp Plugins, which estimates chords with accuracy up to 70%. &lt;/p&gt;
&lt;p&gt;We propose a new dataset (name not yet determined) of MIDI karaoke data with embedded lyrics (.KAR). This dataset contains over 700 files, scraped from a karaoke content aggregator [11]. Timed lyrical data has been extracted from these files, and the precise timing of each note is already available by nature of the MIDI format.&lt;/p&gt;
&lt;p&gt;Additional datasets for training a lyric model may be useful, and many are available. One such dataset is the 55000+ Song Lyrics on Kaggle [10]. This could help our model generalize its lyrical output beyond the limited set of vocabulary available within the 1000 or fewer annotated karaoke songs.&lt;/p&gt;
&lt;h3&gt;Evaluation Plan:&lt;/h3&gt;
&lt;p&gt;Evaluation of our model can be done several ways. The first is simply to listen to the music ourselves. This is the most direct method of evaluation but is not efficient, as likely we will need many iterations of tuning; furthermore, will likely need to listen to several songs to be confident of the model’s quality. Hence, we will also design basic “sanity check” tests for our models.&lt;/p&gt;
&lt;p&gt;Recall that in our proposed methodology, we intend to use adversarial training. The discriminator network itself gives a direct evaluation of the generator. As long as the discriminator is of vetted quality, and the discriminator is run on sufficiently many examples (with roughly even number of generated and true examples mixed in), the generator will be deemed also of sufficient quality (as a “sanity check”).&lt;/p&gt;
&lt;p&gt;Of course, this leaves the question of ensuring the discriminator is good. We can run the discriminator on instrumentals combined with randomly generated words (according to some distribution), or on instrumentals combined with the original lyrics, which are perturbed in some fashion. As an example, one can perturb the original lyrics temporally (making an utterance off-beat when it should be precisely on the down-beat of a bar) or replacing a few words with randomly selected ones (according to some distribution over the vocabulary). These “test inputs” to the discriminator can be generated before-hand.&lt;/p&gt;
&lt;h3&gt;Literature Survey:&lt;/h3&gt;
&lt;p&gt;Here are some relevant papers (most were already included in preceding posts).&lt;/p&gt;
&lt;p&gt;[1] Y. Bayle, L. Marsik, M. Rusek, M. Robine, P. Hanna, K. Slaninova, J. Martinovic, J. Pokorny. “Kara1k: A Karaoke Dataset for Cover Song Identification and Singing Voice Analysis”. IEEE International Symposium on Multimedia (ISM), 2017. &lt;a href=&quot;https://ieeexplore.ieee.org/document/8241597/&quot; rel=&quot;nofollow&quot;&gt;https://ieeexplore.ieee.org/document/8241597/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] L. Yu, W. Zhang, J. Wang, Y. Yu. “SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient”. Proceedings of the Thirty-First AAAI Conference on Artificial Intelligence, 2017. &lt;a href=&quot;https://arxiv.org/abs/1609.05473&quot; rel=&quot;nofollow&quot;&gt;https://arxiv.org/abs/1609.05473&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] S. Lee, U. Hwang, S. Min, S. Yoon. “A SeqGAN for Polyphonic Music Generation”. 2017. &lt;a href=&quot;https://arxiv.org/abs/1710.11418&quot; rel=&quot;nofollow&quot;&gt;https://arxiv.org/abs/1710.11418&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] H. W. Dong, W. Y. Hsiao, L. C. Yang, Y. H. Yang. “MuseGAN: Multi-track Sequential Generative Adversarial Networks for Symbolic Music Generation and Accompaniment”. 2017. &lt;a href=&quot;https://arxiv.org/abs/1709.06298&quot; rel=&quot;nofollow&quot;&gt;https://arxiv.org/abs/1709.06298&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5] I. J. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, Y. Bengio. “Generative Adversarial Nets”. NIPS, 2014. &lt;a href=&quot;https://papers.nips.cc/paper/5423-generative-adversarial-nets&quot; rel=&quot;nofollow&quot;&gt;https://papers.nips.cc/paper/5423-generative-adversarial-nets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6] T. Salimans, I. J. Goodfellow, W. Zaremba, V. Cheung, A. Radford, X. Chen. “Improved Techniques for Training GANs”. NIPS, 2016. &lt;a href=&quot;https://arxiv.org/abs/1606.03498&quot; rel=&quot;nofollow&quot;&gt;https://arxiv.org/abs/1606.03498&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[7] M. Arjovsky,  S. Chintala, L. Bottou. “Wasserstein GAN”. 2017. &lt;a href=&quot;https://arxiv.org/abs/1701.07875&quot; rel=&quot;nofollow&quot;&gt;https://arxiv.org/abs/1701.07875&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[8] J. Faille, Y. Wang. “Using Deep Learning to Annotate Karaoke Songs”. 2016. &lt;a href=&quot;https://www.semanticscholar.org/paper/Using-Deep-Learning-to-Annotate-Karaoke-Songs-Faille-Wang/521361762a7327f8fcc77bd9d76eaa2b503f845a&quot; rel=&quot;nofollow&quot;&gt;https://www.semanticscholar.org/paper/Using-Deep-Learning-to-Annotate-Karaoke-Songs-Faille-Wang/521361762a7327f8fcc77bd9d76eaa2b503f845a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[9] J. Thickstun, Z. Harchaoui, S. Kakade. “Learning Features of Music from Scratch”. 2017. &lt;a href=&quot;https://arxiv.org/abs/1611.09827&quot; rel=&quot;nofollow&quot;&gt;https://arxiv.org/abs/1611.09827&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[10] Additional data &lt;a href=&quot;https://www.kaggle.com/mousehead/songlyrics&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[11] Even more additional data &lt;a href=&quot;http://vooch.narod.ru/midi/midi.htm&quot;&gt;here&lt;/a&gt;&lt;/p&gt;</description>
	<pubDate>Wed, 11 Apr 2018 06:45:55 +0000</pubDate>
</item>
<item>
	<title>Ron Fan, Aditya Saraf &lt;br/&gt; Team PrimeapeNLP: Blog Post #3</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-3753031463594823927.post-4531878816260312232</guid>
	<link>https://cse481n.blogspot.com/2018/04/blog-post-3.html</link>
	<description>&lt;h1 dir=&quot;ltr&quot; id=&quot;docs-internal-guid-ea0c9d97-b369-9237-6f13-3675807d7a60&quot; style=&quot;line-height: 1.38; margin-bottom: 6pt; margin-top: 20pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 20pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Project Objectives&lt;/span&gt;&lt;/h1&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Single document summarization (SDS) is one of the remaining challenging problems in natural language processing. Novel methods are presented frequently in new papers, but they often do not include specific code allowing for reproducibility and are evaluated on specific datasets that make comparisons between models meaningless and difficult.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;There are many approaches to SDS, but they can be broadly divided into combinatorial approaches and neural approaches. Neural approaches build a neural architecture, such as a seq2seq/encoder-decoder model or single sequence RNNs. Combinatorial approaches will either try to frame the problem as an optimization problem, and then use an ILP solver, or frame the problem as a classic NP-hard problem, like Knapsack or Maximum Coverage. We want to explore both approaches, and compare their performance on the same dataset.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;SDS is comprised of two tasks: extractive summarization and abstractive summarization. Extractive summarization compiles a summary by selecting sentences from the document’s text while abstractive summarization generates text for the summary (sentences that may not have been present in the document’s text). While abstractive summarization might have more intuitive appeal, our project will focus on extractive summarization to enable meaningful comparisons between neural and combinatorial approaches (combinatorial approaches often must be extractive).&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;In this project, we plan to implement at least one neural and one combinatorial model for extractive single document summarization. We hope to establish some meaningful ways to compare the differences between selections made by the different types of models. Our primary goal is to better understand the strengths and weaknesses of neural and combinatorial models for single document summarization - a particular important aspect of SDS given the general roughness of existing evaluation metrics. We will gauge our progress based on reaching acceptable performance on commonly-used evaluation metrics when we implement models.&lt;/span&gt;&lt;/div&gt;&lt;h1 dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 6pt; margin-top: 20pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 20pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Methodology&lt;/span&gt;&lt;/h1&gt;&lt;h3 dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 13.999999999999998pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Minimal Viable Action Plan&lt;/span&gt;&lt;/h3&gt;&lt;ol style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Build our data set using existing data. Specifically, convert data better suited for training abstractive summarization models into data that can be used for extractive summarization..&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Implement a simple combinatorial model (for example, we can do a simple maximum coverage problem, where we set up the “universe” to be the vocabulary of the document, and treat the sentences as sets of words).&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Implement a simple neural model (just treat the problem as a generic binary classification problem).&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Train models on identical data sets and do a baseline comparison -- how well does a simple neural model do vs. a simple combinatorial model? This doesn’t tell us much about the relative strengths of the two approaches (we can’t quantify “simple”), but with some error analysis, we might be able to see what sentences neural models are misidentifying vs. what sentences combinatorial models are misidentifying.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Build at least one state-of-the-art combinatorial model (adapting from a recent paper). We have two candidate papers: Hirao et al.’s Tree Knapsack approach and Durrett et al.’s Compression/Anaphoricity&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br /&gt;&lt;h3 dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 13.999999999999998pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Stretch Goals&lt;/span&gt;&lt;/h3&gt;&lt;ol style=&quot;margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Design our own model that is a combination of the strong points of the combinatorial and neural models. Ideally, our model would be as good as or better than the existing models we implemented on the quantitative and qualitative metrics we use.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Alternatively, we can use ideas from one domain to improve an aspect of a SOTA model in the other domain. For example, we might learn that neural models are great at dealing with named entities, and so incorporate a neural layer in a combinatorial model (perhaps by allowing the output of the neural layer to determine the weights of named entities).&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;li dir=&quot;ltr&quot; style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre;&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Design a common system for comparing performance of extractive summarization models. Rather than a differentiable evaluation metric, we think it may be useful to choose a set of “tough” documents to summarize and bundle them together with specific reasons for their difficulty, so that researchers may more easily identify weaknesses in models they are working on.&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 6pt; margin-top: 20pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 20pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Available Resources&lt;/span&gt;&lt;/h1&gt;&lt;h3 dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 13.999999999999998pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Dataset/Evaluation&lt;/span&gt;&lt;/h3&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;For this problem, we will be using the DailyMail/CNN dataset. From our initial research, this seems to be the standard dataset for both document summarization as well as basic reading comprehension. The dataset has 400,000 articles, and includes both the full text of the article as well as bullet point “highlights”. For reading comprehension, an important word is omitted from the highlights and the machine is asked to fill in the blank. For text summarization, the bullet points are considered the “gold standard” summaries -- machine generated summaries are evaluated against the bullet points, typically&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 700; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;using ROUGE metrics&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 700; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;(Lin, 2004). While this works fine for abstractive summarization, this training corpus is not annotated enough for extractive summarization. More specifically, extractive summarization requires sentence level binary annotations, to indicate whether each sentence does or doesn’t belong in the summary. So we need to first convert the bullet points into more fine grained annotations.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;We’ve looked at two papers which briefly touched on this. Nallapati et. al. used a greedy approach, where they added one sentence at a time to the extractive summary while seeking to maximize the Rouge score with respect to the abstractive summary (the bullet points). They also tried to use an RNN decoder in combination with the abstractive summaries to train the extractive model without using sentence-level annotations. However, this approach was slightly less successful than estimating sentence-level annotations. Cheng and Lapata used a different approach - they created a “rule-based system that determines whether a given sentence matches a highlight...The rules take into account the position of the sentence in the document, the unigram and bigram overlap between document sentences and highlights, [and] the number of entities appearing in the highlight and in the document sentence”. It’s not 100% clear what rules the authors used, but according to Nallapati et. al., the rule-based approach found a better “ground-truth” than the greedy approach.&lt;/span&gt;&lt;/div&gt;&lt;h3 dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 4pt; margin-top: 16pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 13.999999999999998pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;GitHub Repositories&lt;/span&gt;&lt;/h3&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Some researchers publish the code they used in their paper on GitHub. We can use repos for quick comparisons or to see how they design their code.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;a href=&quot;https://github.com/abisee/pointer-generator&quot; style=&quot;text-decoration: none;&quot;&gt;&lt;span&gt;https://github.com/abisee/pointer-generator&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;: This repo is for See et al.’s Pointer-Generator neural model.&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;&quot;&gt;&lt;a href=&quot;https://github.com/cheng6076/NeuralSum&quot; style=&quot;text-decoration: none;&quot;&gt;&lt;span&gt;https://github.com/cheng6076/NeuralSum&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;: This repo is for Cheng and Lapata’s neural model, that combines a sentence level RNN with a word level CNN.&lt;/span&gt;&lt;/div&gt;&lt;h1 dir=&quot;ltr&quot; style=&quot;line-height: 1.38; margin-bottom: 6pt; margin-top: 20pt;&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 20pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Related Work and References&lt;/span&gt;&lt;/h1&gt;&lt;br /&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Cheng, J., &amp;amp; Lapata, M. (2016). Neural Summarization by Extracting Sentences and Words. &lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;arXiv:1603.07252 [Cs]&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;. Retrieved from http://arxiv.org/abs/1603.07252&lt;/span&gt;&lt;/div&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Durrett, G., Berg-Kirkpatrick, T., &amp;amp; Klein, D. (2016). Learning-Based Single-Document Summarization with Compression and Anaphoricity Constraints. &lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;arXiv:1603.08887 [Cs]&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;. Retrieved from http://arxiv.org/abs/1603.08887&lt;/span&gt;&lt;/div&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Hirao, T., Yoshida, Y., Nishino, M., Yasuda, N., &amp;amp; Nagata, M. (2013). Single-Document Summarization as a Tree Knapsack Problem. In &lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt; (pp. 1515–1520). Seattle, Washington, USA: Association for Computational Linguistics. Retrieved from http://www.aclweb.org/anthology/D13-1158&lt;/span&gt;&lt;/div&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Lin, C.-Y. (2004). ROUGE: A Package for Automatic Evaluation of Summaries. In S. S. Marie-Francine Moens (Ed.), &lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Text Summarization Branches Out: Proceedings of the ACL-04 Workshop&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt; (pp. 74–81). Barcelona, Spain: Association for Computational Linguistics.&lt;/span&gt;&lt;/div&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;Nallapati, R., Zhai, F., &amp;amp; Zhou, B. (2016). SummaRuNNer: A Recurrent Neural Network based Sequence Model for Extractive Summarization of Documents. &lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;arXiv:1611.04230 [Cs]&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;. Retrieved from http://arxiv.org/abs/1611.04230&lt;/span&gt;&lt;/div&gt;&lt;div dir=&quot;ltr&quot;&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;See, A., Liu, P. J., &amp;amp; Manning, C. D. (2017). Get To The Point: Summarization with Pointer-Generator Networks. &lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;arXiv:1704.04368 [Cs]&lt;/span&gt;&lt;span style=&quot;background-color: transparent; color: black; font-family: Arial; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; white-space: pre;&quot;&gt;. Retrieved from http://arxiv.org/abs/1704.04368&lt;/span&gt;&lt;/div&gt;</description>
	<pubDate>Wed, 11 Apr 2018 06:33:00 +0000</pubDate>
	<author>noreply@blogger.com (Ron &amp; Aditya)</author>
</item>
<item>
	<title>Ananth Gottumukkala &lt;br/&gt; Team Turing Test: Warm Up: Testing a Codebase</title>
	<guid isPermaLink="false">http://deeplearningturingtest.wordpress.com/?p=12</guid>
	<link>https://deeplearningturingtest.wordpress.com/2018/04/06/warm-up-testing-a-codebase/</link>
	<description>&lt;p&gt;I installed both the Tensorflow and Pytorch API’s since I’m not sure which framework I will use yet. Then, I downloaded the following repository which implemented Hybrid Code Networks for Dialog State tracking in its respective research paper.&lt;/p&gt;
&lt;p&gt;Code base URL: &lt;a href=&quot;https://github.com/voicy-ai/DialogStateTracking&quot; rel=&quot;nofollow&quot;&gt;https://github.com/voicy-ai/DialogStateTracking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Research Paper URL: &lt;a href=&quot;https://www.semanticscholar.org/paper/Hybrid-Code-Networks%3A-practical-and-efficient-with-Williams-Asadi/0645905d70caf180433145be09c9af266a85c863&quot; rel=&quot;nofollow&quot;&gt;https://www.semanticscholar.org/paper/Hybrid-Code-Networks%3A-practical-and-efficient-with-Williams-Asadi/0645905d70caf180433145be09c9af266a85c863&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Their implementation uses Keras (built on Tensorflow) to build the network. The model stores a predetermined set of action templates to execute based on what the user requests. By feeding in features like the previous action taken, a bag of words vector, an entity tracking feature vector, etc. their RNN outputs a softmax distribution over the possible action templates. The action taken is the one with the highest probability. Because the conversation is restricted to a particular domain such as searching for a restaurant, the model performed well when I ran and tested it. The model generally recognized the type of request I was making, but its responses were extremely robotic and towards the end, gave me yes or no questions to answer to narrow down what action it should take. My goal is to generalize the type of information the model can store between time steps to be able to provide responses for requests outside of a restricted domain (like searching for a restaurant in this case).&lt;/p&gt;</description>
	<pubDate>Fri, 06 Apr 2018 06:58:40 +0000</pubDate>
</item>
<item>
	<title>Halden Lin &lt;br/&gt; Team undef.: NLP Capstone | 02: Getting Started</title>
	<guid isPermaLink="false">https://medium.com/p/96fb908765f5</guid>
	<link>https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5?source=rss-2759d54493c0------2</link>
	<description>&lt;p&gt;&lt;a href=&quot;https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5&quot;&gt;previous post&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Alright, it’s been only 2 days since my last entry, so this will be a relatively short post. The direction I proposed in &lt;strong&gt;Option 1 &lt;/strong&gt;of that post was towards a more robust, interpretable, and informative visualization of attention, particularly in the context of text summarization. A quick recap:&lt;/p&gt;&lt;blockquote&gt;Perhaps interaction can be used to create a more insightful and interpretable visualization framework for understanding attention. For example, text heat-maps are already used widely to visualize sentiment analysis.&lt;/blockquote&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*lsgeuBXGGBog4YkuQNgJVw.png&quot; /&gt;Lin et al. (2017) [6]. Visualization of sentiment analysis on a token-by-token basis.&lt;/figure&gt;&lt;blockquote&gt;In a static context, using this method for attention would require repeat of the same input sequence for each word in the output sequence. Using interaction, however, a model creator could brush over single or sequences of words in the output sequence to view corresponding soft-alignment in the input sequence. Aggregate visualizations could be shown to supplement this view (either aggregates over a particular input / output sequence, or aggregates over all input / output sequences).&lt;/blockquote&gt;&lt;p&gt;I’m currently working on laying out the groundwork for such a project. Task 1: implement a model. Without one, there’s no data to visualize!&lt;/p&gt;&lt;p&gt;With that in mind, here’s what I’ve been up to:&lt;/p&gt;&lt;h4&gt;Finding a Text Summarization Dataset&lt;/h4&gt;&lt;p&gt;A quick survey of recent research papers [1–5] on text summarization points, as well as online forums, points to three commonly used datasets.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://cs.nyu.edu/~kcho/DMQA/&quot;&gt;CNN/Daily Mail Corpus&lt;/a&gt;. A collection of articles and their bullet point summaries, with each bullet split for Q/A purposes. &lt;a href=&quot;https://github.com/abisee/cnn-dailymail&quot;&gt;A script&lt;/a&gt; [1] can be ran over the original dataset to restore the original bullet point summaries, to be used as a summarization corpus.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www-nlpir.nist.gov/projects/duc/data.html&quot;&gt;DUC Corpus&lt;/a&gt;. In particular, DUC 2003 and DUC 2004. These contain a collection of documents, each accompanied by a short (~10 word) summary. There is also a longer summary for each cluster of documents.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://catalog.ldc.upenn.edu/ldc2003t05&quot;&gt;Gigaword Corpus&lt;/a&gt;. An annotated collection of millions of documents. The summarization task here would be to predict the headline of each [5]&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The accessibility of the &lt;strong&gt;CNN/Daily Mail Corpus&lt;/strong&gt; (a process is required for the other two), in addition to the prevalence of projects that used it as a primary dataset [1, 2, 4], made it the most attractive option. The relatively longer summaries (~4 bullet points as opposed a short blurb in the other two datasets) also lends itself conveniently to the case of an interactive visualization with multi-token selection (e.g. select a whole bullet point and see where it attended). For a baseline, this will be my dataset!&lt;/p&gt;&lt;h4&gt;Identifying a Baseline Model&lt;/h4&gt;&lt;p&gt;See et al. (2017) [1] lay out a seq2seq attentional model as their baseline (a bidirectional LSTM). I’ll be using this as a baseline model with which to obtain data.&lt;/p&gt;&lt;h4&gt;Getting Some Code Up&lt;/h4&gt;&lt;p&gt;I’ll be using &lt;a href=&quot;http://pytorch.org/&quot;&gt;PyTorch&lt;/a&gt; and the &lt;a href=&quot;http://allennlp.org/&quot;&gt;AllenNLP&lt;/a&gt; toolkit [7] to implement my NN models. These are both ready to go on both my machine and Azure. I’m currently in the process of writing a DatasetReader for the dataset described above.&lt;/p&gt;&lt;h3&gt;Next Steps&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Finish writing the DatasetReader for the CNN/Daily Mail Corpus.&lt;/li&gt;&lt;li&gt;Begin work on a baseline seq2seq attentional model, as described in &lt;strong&gt;Identifying a Baseline Model&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Works Cited&lt;/h4&gt;&lt;p&gt;[1] &lt;a href=&quot;https://arxiv.org/pdf/1704.04368.pdf&quot;&gt;See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” &lt;em&gt;ACL&lt;/em&gt; (2017).&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[2] &lt;a href=&quot;https://arxiv.org/pdf/1712.06100.pdf&quot;&gt;Hasselqvist, Johan et al. “Query-Based Abstractive Summarization Using Neural Networks.” &lt;em&gt;CoRR&lt;/em&gt; abs/1712.06100 (2017): n. pag.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[3] &lt;a href=&quot;https://arxiv.org/pdf/1602.06023.pdf&quot;&gt;Nallapati, Ramesh et al. “Abstractive Text Summarization using Sequence-to-sequence RNNs and Beyond.” &lt;em&gt;CoNLL&lt;/em&gt; (2016).&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[4] &lt;a href=&quot;https://arxiv.org/pdf/1705.04304.pdf&quot;&gt;Paulus, Romain et al. “A Deep Reinforced Model for Abstractive Summarization.” &lt;em&gt;CoRR&lt;/em&gt; abs/1705.04304 (2017): n. pag.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[5] &lt;a href=&quot;https://arxiv.org/pdf/1509.00685.pdf&quot;&gt;Rush, Alexander M. et al. “A Neural Attention Model for Abstractive Sentence Summarization.” &lt;em&gt;EMNLP&lt;/em&gt; (2015).&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[6] &lt;a href=&quot;https://arxiv.org/pdf/1703.03130.pdf&quot;&gt;Lin, Zhouhan, &lt;em&gt;et al.&lt;/em&gt;, “A structured self-attentive sentence embedding.”&lt;em&gt;arXiv preprint arXiv:1703.03130&lt;/em&gt; (2017).&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[7] &lt;a href=&quot;https://pdfs.semanticscholar.org/a550/2187140cdd98d76ae711973dbcdaf1fef46d.pdf?_ga=2.150901366.1370831839.1522970228-1363309632.1522194596&quot;&gt;Gardner, Matt et al. “AllenNLP: A Deep Semantic Natural Language Processing Platform.” (2017).&lt;/a&gt;&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=96fb908765f5&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Fri, 06 Apr 2018 06:53:32 +0000</pubDate>
</item>
<item>
	<title>Aaron Johnston, Lynsey Liu &lt;br/&gt; Team Viterbi Or Not To Be: Warming Up</title>
	<guid isPermaLink="false">https://medium.com/p/278789e4d04a</guid>
	<link>https://medium.com/@viterbi.or.not/warming-up-278789e4d04a?source=rss-c522ef075bb3------2</link>
	<description>&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*qc9b3NkzkWe1kNnqmlHukA.png&quot; /&gt;&lt;/figure&gt;&lt;p&gt;In order to begin implementing our baseline model, for which we intend to duplicate the results presented in another research paper covering discussion summarization, we began by identifying software that was referenced by other papers as being useful for their implementations.&lt;/p&gt;&lt;p&gt;Using these leads, we decided to “warm up” by installing the software and gaining some familiarity with it. The main libraries that we identified are listed here:&lt;/p&gt;&lt;h4&gt;&lt;a href=&quot;https://www.nltk.org/&quot;&gt;&lt;strong&gt;Natural Language Toolkit (nltk)&lt;/strong&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Perhaps it is no surprise that this resource ended up first on our list, but it was a clear choice to familiarize ourselves with because of the sheer variety of tools it provides. While performing an initial survey of conversation summarization papers, we discovered a reference to the TextTiling algorithm, described in &lt;a href=&quot;http://www.aclweb.org/anthology/J97-1003&quot;&gt;this paper&lt;/a&gt; and referenced as a technique used in &lt;a href=&quot;http://www.aclweb.org/anthology/D08-1081&quot;&gt;another paper&lt;/a&gt; about summarization. Broadly, the algorithm detects boundaries between topics in text, so it was used by this summarization paper as part of a pipeline before assigning scores to those topics representing their importance. For our baseline model, one possibility is to implement a similar pipeline, so having access to an implementation of the TextTiling algorithm would allow us to quickly implement that component and spend more time on other design decisions and implementation details. The nltk library provides a &lt;a href=&quot;https://www.nltk.org/api/nltk.tokenize.html#module-nltk.tokenize.texttiling&quot;&gt;TextTiling module&lt;/a&gt; with this functionality.&lt;/p&gt;&lt;h4&gt;&lt;a href=&quot;http://scikit-learn.org/stable/&quot;&gt;&lt;strong&gt;SciKit-Learn&lt;/strong&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.aclweb.org/anthology/P05-1037&quot;&gt;Another research paper&lt;/a&gt; we found concerning the topic of conversation summarization had several sections dedicated to the task of identifying portions of a chatlog with direct relevance to one another — for example, a question asked by one contributor and answered by another contributor several messages down would be considered a pair of directly relevant sections. As part of their technique for identifying these pairs, the researchers used &lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html&quot;&gt;Support Vector Machines&lt;/a&gt; and &lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html&quot;&gt;Maximum Entropy&lt;/a&gt; models in order to determine the sections that most likely directly respond to previous portions of the conversation. SciKit-Learn provides these functionalities, and in order to familiarize ourselves with additional existing tools that might be useful in building a baseline model we have installed this tool and begun experimenting with it.&lt;/p&gt;&lt;h4&gt;&lt;a href=&quot;https://www.cs.waikato.ac.nz/ml/weka/&quot;&gt;&lt;strong&gt;Weka Toolkit&lt;/strong&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Another less commonly seen method for chat summarization can be found in a more recent (in comparison to the others we have referenced) &lt;a href=&quot;http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf&quot;&gt;research paper&lt;/a&gt; which explores the usage of Multilayer Perceptrons (MLP) for the task, among several other approaches. The MLP approach in the paper is broadly composed of a feedforward neural network with more layers between the input and output layers using backpropagation to train the network and built with the Weka toolkit, a collection of machine learning algorithms that can applied to a dataset and which contains tools for developing a variety of schemes for processing data. Although the paper finds an approach using Naive Bayes to be the most effective on the GNUe archives, their MLP implementation comes in relatively close second and we think the idea is worth pursuing further. For a baseline model, we could start by working on a similar MLP system to the one in the paper using the same Weka toolkit implementation and strive to improve from there.&lt;/p&gt;&lt;h4&gt;&lt;a href=&quot;http://pytorch.org/&quot;&gt;&lt;strong&gt;PyTorch&lt;/strong&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Though not referenced by any of the papers we have encountered so far, PyTorch would be a really helpful tool for us to further the explore the usage of neural network models in chat summarization, which we can use for the aforementioned MLP approach as well as apply to our stretch goal of working on a less commonly used deep learning based model.&lt;/p&gt;&lt;p&gt;In addition to researching libraries and tools that we might use in our project, we have begun the process of finding and enumerating datasets that might be useful for our project ideas — more to come on the datasets and other resources in our next blog post!&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=278789e4d04a&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Fri, 06 Apr 2018 06:41:19 +0000</pubDate>
</item>
<item>
	<title>Ron Fan, Aditya Saraf &lt;br/&gt; Team PrimeapeNLP: Blog Post #2</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-3753031463594823927.post-2253300890173394060</guid>
	<link>https://cse481n.blogspot.com/2018/04/blog-post-2.html</link>
	<description>&lt;div&gt;We’ve mostly settled on working on a single document summarization task. We want to pick a type of document to work on summarizing, although we haven’t decided on one specific category yet. &lt;/div&gt;&lt;br /&gt; &lt;div&gt;While we narrow down the details of the project, we have been reading a number of papers and other resources to become more familiar with the subject. We have setup PyTorch on our machines, which we are both familiar with, as well as Tensorflow, which we are still playing around with. We’ve found some interesting repositories on GitHub related to SDS that we are trying out: &lt;/div&gt; &lt;br /&gt; &lt;div&gt;&lt;a href=&quot;https://cse481n.blogspot.com/feeds/posts/default?alt=rss&quot;&gt;https://github.com/tensorflow/models/tree/master/research/textsum&lt;/a&gt;&lt;br /&gt; &lt;a href=&quot;https://cse481n.blogspot.com/feeds/posts/default?alt=rss&quot;&gt;https://github.com/gregdurrett/berkeley-doc-summarizer&lt;/a&gt;&lt;br /&gt; &lt;a href=&quot;https://cse481n.blogspot.com/feeds/posts/default?alt=rss&quot;&gt;https://github.com/chakki-works/sumeval&lt;/a&gt;&lt;br /&gt; &lt;a href=&quot;https://cse481n.blogspot.com/feeds/posts/default?alt=rss&quot;&gt;https://github.com/ceteri/pytextrank&lt;/a&gt;&lt;br /&gt; &lt;a href=&quot;https://cse481n.blogspot.com/feeds/posts/default?alt=rss&quot;&gt;https://github.com/adamfabish/Reduction&lt;/a&gt;&lt;br /&gt;&lt;/div&gt; &lt;br /&gt;&lt;div&gt;Not all of these tools use machine learning - many seem to be heuristic-based sentence extractors. Nonetheless, it is interesting to consider their ideas in the context of neural network approaches. &lt;/div&gt;&lt;br /&gt; &lt;div&gt;One of the reasons we chose to attack this problem is that there is a rich literature to consult; this problem has been worked on in one form or another since 1958 [1]. As one would imagine, this means that there have been many different approaches to this problem, to varying degrees of success. But unlike other problems, where all current approaches are based on deep learning, there is active research into non-neural solutions to SDS. &lt;/div&gt;&lt;br /&gt; &lt;div&gt;Many researchers have tried to solve SDS with combinatorial optimization, reducing it to the Knapsack problem, the Maximum Coverage problem, or the Budgeted Median problem. For example, the Maximum Coverage problem is: given a number k and a collection S, of m sets, choose less than k sets in S that maximize the number of covered elements. To frame SDS as a Maximum Coverage problem, you break the document into “conceptual units”. Conceptual units are supposed to represent a single concept - for example, “the man bought a book” and the “the man read a book”. But it’s not clear at what granularity these conceptual units should be defined. One easy (but not especially effective) solution is to simply make each word a conceptual unit. Then, the document = S, and each sentence is a set of words inside S. The problem is now to pick k sentences from the document that maximize the word coverage in the document [2]. &lt;/div&gt;&lt;br /&gt; &lt;div&gt;One example of a recent non-neural approach is from a paper published 5 years ago [3]. The paper solves SDS by reducing it to the so-called Tree Knapsack Problem. We’ve haven’t fully wrapped our heads around the Tree Knapsack problem (it’s actually not that easy to quickly state), but the researchers’ basically involved representing a document as a Rhetorical Structure Theory-based discourse tree (RST-DT) by “select[ing] textual units according to a preference ranking”. The researchers’ first transform the RST-DT into a dependency-based discourse tree (DEP-DT) in order to get a tree that contains textual units on all nodes (RST-DT only have textual units as leaves), and then trim the DEP-DT using the Tree Knapsack problem.  &lt;/div&gt;&lt;br /&gt; &lt;div&gt;We aim to find a suitable corpus, and implement multiple models directly from these papers as our baseline models. Hopefully, that will give us insight that’ll help us formulate the problem differently. We also want to explore some neural architectures for single document summarization.  &lt;/div&gt;&lt;br /&gt; &lt;div&gt;We also have to consider whether we want to build an extractive or abstractive text summarization - the former collects a set of sentences or phrases that summarize the document while the latter tries to “learn the internal language representation to generate more human-like summaries, paraphrasing the intent of the original text” [4]. We’re leaning towards an extractive model, although we may try both. &lt;/div&gt;&lt;br /&gt; &lt;div&gt;[1] = &lt;a target=&quot;&quot;&gt;https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781119004752.ch3&lt;/a&gt; &lt;br /&gt;[2] = &lt;a target=&quot;&quot;&gt;http://www.anthology.aclweb.org/E/E09/E09-1089.pdf&lt;/a&gt; &lt;br /&gt; [3] = &lt;a target=&quot;&quot;&gt;https://www.semanticscholar.org/paper/Single-Document-Summarization-as-a-Tree-Knapsack-Hirao-Yoshida/ed0c8a7ab911cdb30b7e95edada3a55c01eb22c5&lt;/a&gt;&lt;br /&gt; [4] = &lt;a target=&quot;&quot;&gt;https://rare-technologies.com/text-summarization-in-python-extractive-vs-abstractive-techniques-revisited/&lt;/a&gt;&lt;/div&gt;</description>
	<pubDate>Fri, 06 Apr 2018 06:31:00 +0000</pubDate>
	<author>noreply@blogger.com (Ron &amp; Aditya)</author>
</item>
<item>
	<title>Kuikui Liu, Nicholas Ruhland &lt;br/&gt; Team INLP: Milestone #2: Music as a Natural Language Task</title>
	<guid isPermaLink="false">http://mathstoc.wordpress.com/?p=304</guid>
	<link>https://mathstoc.wordpress.com/2018/04/06/milestone-2-music-as-a-natural-language-task/</link>
	<description>&lt;h3&gt;Framing the problem&lt;/h3&gt;
&lt;p&gt;The focus of Natural Language Processing relies on patterns in the structure of language and models that find ways to encode the complexities of these structures. Many forms of music also have large amounts of structure which could potentially be discovered using similar models as a standard natural language.&lt;/p&gt;
&lt;p&gt;Music datasets for machine learning purposes have recently become available through projects like MusicNet in 2016 [1]. This music is primarily classical, and provided as both audio and MIDI.&lt;/p&gt;
&lt;h3&gt;Project ideas&lt;/h3&gt;
&lt;p&gt;For our project we are interested in music with lyrical content – both for the potential to create a creative demo and for the interest of making this a language task. The current direction we are most interested in is the generation of lyrics for a song, given its nonlyrical content. This will be broken up into subtasks depending on the feasible scale of the project. Not all of the following points will necessarily be parts of our project, but we will use them as as starting point as we see the success of our models.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Creating a machine learning model for MIDI music&lt;/li&gt;
&lt;li&gt;Translating MIDI into specific artists or styles&lt;/li&gt;
&lt;li&gt;Creating models for the lyrical content of specific artists or styles of music&lt;/li&gt;
&lt;li&gt;Generating lyrics given an artist or style&lt;/li&gt;
&lt;li&gt;Seq2seq conversion of MIDI into lyrical content&lt;/li&gt;
&lt;li&gt;GANs for either side of the conversion – MIDI encoding or lyrical generating&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Using MIDIs in RNNs&lt;/h3&gt;
&lt;p&gt;Work by Pakhomov [2] has already used RNNs to create models for lyrics. In his &lt;a href=&quot;http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/&quot;&gt;blog post&lt;/a&gt; he additionally discusses a method for forming any MIDI into piano roll format. This is essentially a matrix where each column represents a different time step, and each row represents a different note. Having a 1 corresponds to that note sounding at that time. The individual time vectors can be used as the inputs to an RNN at each time step to create a model representing the various songs.&lt;/p&gt;
&lt;p&gt;One possible data source for our project is karaoke data available from various sources online. If available in large enough quantities this could be extremely convenient because it already contains many pairings of MIDI music to their lyrics.&lt;/p&gt;
&lt;h3&gt;Azure&lt;/h3&gt;
&lt;p&gt;We intend to use PyTorch to train our models, and have begun setting up an instance on Microsoft Azure.&lt;/p&gt;
&lt;h3&gt;Relevant work&lt;/h3&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://homes.cs.washington.edu/~thickstn/musicnet.html&quot; rel=&quot;nofollow&quot;&gt;https://homes.cs.washington.edu/~thickstn/musicnet.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/&quot; rel=&quot;nofollow&quot;&gt;http://warmspringwinds.github.io/pytorch/rnns/2018/01/27/learning-to-generate-lyrics-and-music-with-recurrent-neural-networks/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] Dong, Hao-Wen. 2017. MuseGAN: Multi-track Sequential Generative Adversarial Networks for Symbolic Music Generation and Accompaniment. &lt;a href=&quot;https://arxiv.org/pdf/1709.06298&quot; rel=&quot;nofollow&quot;&gt;https://arxiv.org/pdf/1709.06298&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] Yu, Lantao. 2016. SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient. &lt;a href=&quot;https://arxiv.org/abs/1609.05473&quot; rel=&quot;nofollow&quot;&gt;https://arxiv.org/abs/1609.05473&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5] Lee, Sang-gil. 2017. A SeqGAN for Polyphonic Music Generation. &lt;a href=&quot;https://arxiv.org/abs/1710.11418&quot; rel=&quot;nofollow&quot;&gt;https://arxiv.org/abs/1710.11418&lt;/a&gt;&lt;/p&gt;</description>
	<pubDate>Fri, 06 Apr 2018 06:30:14 +0000</pubDate>
</item>
<item>
	<title>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde: Technical Details (Blog Post #2)</title>
	<guid isPermaLink="true">http://sarahyu.weebly.com/cse-481n/technical-details-blog-post-2</guid>
	<link>http://sarahyu.weebly.com/cse-481n/technical-details-blog-post-2</link>
	<description>&lt;div class=&quot;paragraph&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;For my project I am planning to do some deep learning at the end if I have time and if the results up to that point lead to that track. (I have pytorch installed from NLP so that's nice to have). &lt;br /&gt;&lt;br /&gt;With that said, I've been working with the Reddit API's and Reddit datadumps to get started on gathering the necessary data for pursuing the Language Accommodation project. I've been trying to figure out if the best approach is to work with the limited requests, the direct json files, or if some of the data dumps will suffice. I hope to have most of that and some basic data visualizations ready in the next couple of days to inform some of the choices I should make regarding the data (i.e. what time period to gather data from, what subreddits to pull from, etc.)&lt;/span&gt;&lt;br /&gt;&lt;/div&gt;</description>
	<pubDate>Fri, 06 Apr 2018 00:10:50 +0000</pubDate>
</item>
<item>
	<title>Aaron Johnston, Lynsey Liu &lt;br/&gt; Team Viterbi Or Not To Be: Project Ideas</title>
	<guid isPermaLink="false">https://medium.com/p/9a0f5382cff5</guid>
	<link>https://medium.com/@viterbi.or.not/preliminary-ideas-9a0f5382cff5?source=rss-c522ef075bb3------2</link>
	<description>&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*5yHodb3mhK0Ec-CEkw4o-A.png&quot; /&gt;&lt;/figure&gt;&lt;p&gt;Welcome to Team Viterbi Or Not To Be’s first blog post, where we will be discussing our top three project ideas and linking them to the preliminary research we’ve done. As a start for our to-be-determined project, we’ve created a &lt;a href=&quot;https://github.com/viterbi-or-not-to-be/viterbi-or-not-to-be&quot;&gt;git repository&lt;/a&gt; where you can access our code and see our progress!&lt;/p&gt;&lt;p&gt;While considering various ideas to explore, our team ultimately decided to approach the project in “research mode”, with a greater focus on novel models and analysis of their performance. Although it would be exciting to build a complete platform incorporating Natural Language Processing techniques, we decided it would be more educational overall to examine the workings of the models themselves. With that overarching direction in mind, we began to think about the issues in the field that would be most interesting to work with, and settled on a few ideas:&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Automatic Conversation Summarization&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;One idea is to explore various approaches for the automatic summarization of written conversations. As a topic, the usefulness of written conversation summaries is undeniable — as so many methods of communication are being powered through online e-mail or chat interfaces, there is value in being able to extract relevant topics or action items from conversations just as there is for documents or news articles. As a task, however, there are plenty of challenges to overcome to determine what properties of a topic in a discussion influence its importance to the overall summary and how a summary can be generated based off that data.&lt;/p&gt;&lt;p&gt;In our preliminary research, we found that relatively few efforts to automatically summarize natural language text have focused on conversational input specifically, but those that have show promise. One paper in particular examines the &lt;a href=&quot;https://pdfs.semanticscholar.org/efe0/fffe080ac4b1a943f62cc56f2baa27c6e195.pdf&quot;&gt;summarization of both spoken and written conversations&lt;/a&gt;, and notes that there are substantial differences in the two types of data. Although the results of the summarization efforts presented in this paper are well below the baseline established by human summarizers, we think it would be interesting to implement a comparable system and explore modifications that could be made or alternative models that could be used to get a more complete picture of the possibilities. By reading the research papers of related projects, we have identified a number of datasets that would allow us to train our model, including &lt;a href=&quot;http://groups.inf.ed.ac.uk/ami/corpus/&quot;&gt;meeting summaries&lt;/a&gt;, &lt;a href=&quot;https://www.cs.cmu.edu/~./enron/&quot;&gt;summaries of email threads&lt;/a&gt;, and &lt;a href=&quot;https://flossmole.org/content/software-archaeology-gnue-irc-data-summaries&quot;&gt;summaries of chat logs&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;If we were to pursue this option, we would initially focus on replicating the approaches used by previous research projects to automatically summarize conversations as a baseline. Once that is working, we would move toward creating a minimum viable product by examining the features and models used in past approaches and performing an analysis of possible alternatives. Although it may not be within the scope of this quarter-long project to apply an entirely novel model to the problem, at a minimum we would seek to determine the relationship between different features and the various types of conversation available through experimentation.&lt;/p&gt;&lt;p&gt;Beyond the minimum viable product, there are several stretch goals we would like to tackle. One of the more seemingly impactful would be using model parameters and features extracted from one type of data to improve the model’s performance on another, such as using the result of training a model on spoken meeting data to improve the automatic summarization of emails. In the previously linked research paper, the authors mention that a future goal for their research is to implement such a system, and they assert that preliminary results are promising. Another stretch goal would be attempting to beat previous approaches by focusing on one specific domain and using the unique properties of that data to produce better summaries. An example could be to focus on chat logs from the GNU dataset that deal specifically with bugfixes — by restricting the domain to a set of code-related topics that likely share a much smaller vocabulary and a consistent notion of “importance”, such as action items during the lifecycle of a bugfix, it may be possible to produce better summaries than in the case of general summarization. Finally, we are interested in comparing the results of extractive and abstractive summarization — while the former works by identifying the most important sentences in a text and combining them, the latter attempts to make a more “human” summary by identifying topics in a text and generating new sentences that paraphrase the intent. One extension could therefore be to try extending extractive models proposed previously to be abstractive.&lt;/p&gt;&lt;p&gt;While our primary interest would be in conversation summarization, we would also consider doing a similar summarization project based on research papers if the conversation data proved to be insufficient. To do so, we would identify corpuses of research papers, and use the author-written abstracts as the summaries for our training data.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Multiple Premise Entailment&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Another idea is to pursue a project that tackles the problem of Multiple Premise Entailment, which involves being able to make inferences based on multiple premises, as shown in the example below. This would contribute to the making of more “knowledgeable” models that aim to use and understand contexts across multiple ideas, a more challenging problem than making inferences from a single sentence as is done in standard entailment tasks.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*7M-V9YHW9UtascpkTEK5Nw.png&quot; /&gt;Example of a Multiple Premise Entailment, Lai et al. 2017&lt;/figure&gt;&lt;p&gt;If we were to take on this challenge, we would start by looking at &lt;a href=&quot;http://aclweb.org/anthology/I17-1011&quot;&gt;existing research&lt;/a&gt; and begin our approach in a similar way, first using baseline neural models for standard entailment. Once this is running on the MPE dataset, we would do some study and error analysis of these runs, then aim to improve upon these models in a way that takes our findings on the baseline models into account and includes adaptations to tackle multiple premises to create a minimum viable product.&lt;/p&gt;&lt;p&gt;Beyond the minimum viable product, a stretch goal for this problem would be to present a unique model that possibly uses a novel approach from the baseline models to tackle multiple premises in a way that best suits this new challenge, relying less on models for standard entailment.&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Natural Language Visual Reasoning&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;The last idea we are interested in involves the &lt;a href=&quot;http://lic.nlp.cornell.edu/nlvr/&quot;&gt;Cornell Natural Language Visual Reasoning dataset&lt;/a&gt;, which contains 92.244 pairs of natural language statements grounded in synthetic images like the one shown below. The challenge that involves language is to determine whether a statement about the image is true or false. Doing so would typically involve reasoning based on spatial relations, quantities, and other qualities about sets of objects that might appear in the NLVR dataset images.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*Y4-XNexoEp2I5lGKm9MTmg.png&quot; /&gt;Examples of image-statement pairs from the NLVR dataset, Suhr et al. 2017&lt;/figure&gt;&lt;p&gt;If we were to work on this problem, we would focus first on reimplementation of the &lt;a href=&quot;https://arxiv.org/pdf/1511.02799.pdf&quot;&gt;state of the art model&lt;/a&gt; from UC Berkeley. As noted in the “Future Work” section of the UC Berkeley paper, their model maintains a strict separation between predicting network structures and learning network parameters. As a stretch goal, we could work on integrating the current approach with existing tools for learning semantic parsers to achieve an integration between the two components that would possibly improve performance or make way for a novel approach to the problem.&lt;/p&gt;&lt;p&gt;Edited 4/5 to fix formatting, revise introduction (plus dog mascot!), and add example images.&lt;/p&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=9a0f5382cff5&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 04 Apr 2018 07:03:32 +0000</pubDate>
</item>
<item>
	<title>Kuikui Liu, Nicholas Ruhland &lt;br/&gt; Team INLP: NLP Capstone Post #1: Ideation</title>
	<guid isPermaLink="false">http://mathstoc.wordpress.com/?p=277</guid>
	<link>https://mathstoc.wordpress.com/2018/04/04/nlp-capstone-post-1-ideation/</link>
	<description>&lt;p&gt;In this post, I’d like to briefly discuss three different ideas I have for my capstone project.&lt;/p&gt;
&lt;p&gt;UPDATE (04/05/2018): I am fortunate to be joined by a fellow student, Nicholas Ruhland, for this capstone project.&lt;/p&gt;
&lt;h1&gt;A Theoretical Analysis of RNNs (Research Mode):&lt;/h1&gt;
&lt;p&gt; A recent &lt;a href=&quot;https://arxiv.org/abs/1703.00810&quot;&gt;paper of Professor Naftali Tishby&lt;/a&gt; provided some useful observations on the behavior of feedforward neural networks, and proposed a promising approach to understanding their performance. Earlier empirical work done in the vision community showed that when a convolutional neural network is trained, layers closer to the input learn lower level features (such as edges and corners) and layers closer to the output learn higher level features (“this part of the image resembles a nose, and this other part resembles an eye”). One might expect similar behavior to occur with general feedforward neural networks: that earlier layers learn lower level features of the input and later levels learn higher level features of the input. The key insight here was to think of each layer of a neural network as a Markov chain, where each layer &lt;img alt=&quot;L_{i}&quot; class=&quot;latex&quot; src=&quot;https://s0.wp.com/latex.php?latex=L_%7Bi%7D&amp;amp;bg=ffffff&amp;amp;fg=000000&amp;amp;s=0&quot; title=&quot;L_{i}&quot; /&gt; is a (vector-valued) random variable that is conditionally independent of &lt;img alt=&quot;L_{j}&quot; class=&quot;latex&quot; src=&quot;https://s0.wp.com/latex.php?latex=L_%7Bj%7D&amp;amp;bg=ffffff&amp;amp;fg=000000&amp;amp;s=0&quot; title=&quot;L_{j}&quot; /&gt; for all &lt;img alt=&quot;j &amp;lt; i - 1&quot; class=&quot;latex&quot; src=&quot;https://s0.wp.com/latex.php?latex=j+%3C+i+-+1&amp;amp;bg=ffffff&amp;amp;fg=000000&amp;amp;s=0&quot; title=&quot;j &amp;lt; i - 1&quot; /&gt; given &lt;img alt=&quot;L_{i-1}&quot; class=&quot;latex&quot; src=&quot;https://s0.wp.com/latex.php?latex=L_%7Bi-1%7D&amp;amp;bg=ffffff&amp;amp;fg=000000&amp;amp;s=0&quot; title=&quot;L_{i-1}&quot; /&gt;. In this way, information flowing forward in the network can be quantified via notions of entropy from traditional information theory.&lt;/p&gt;
&lt;p&gt;The paper contains some empirical work, observing that there are generally two phases to learning artificial neural networks via stochastic gradient descent: the fitting phase, and the compression phase. The fitting phase is the shorter phase, where the model is quickly tuning itself to minimize the empirical loss function. At the end of this phase, we don't necessarily have a model that will generalize to new data. The compression phase is where the model begins to learn the relevant features in the input, with the intuition that there are many irrelevant parts of the input (I don't need to know every atom in an object to identify it). &lt;/p&gt;
&lt;p&gt;The goal of this project would be to perform a similar theoretical analysis and empirical work for RNN architectures (whose &quot;natural&quot; Markov chain isn't as simple, as there are cycles) on some traditional NLP task, such as Machine Translation, with the goal of studying the flow of information in an RNN architecture, rather than performing comparably to state-of-the-art Machine Translation models (although this can be a stretch goal).&lt;/p&gt;
&lt;p&gt;The relevant steps in this project will likely look like the following:&lt;br /&gt;
1. Reading up on the relevant work by Tishby et. al. (and any other theoretical papers on deep learning).&lt;br /&gt;
2. Understand basic and traditional RNN architectures.&lt;br /&gt;
3. Learning PyTorch.&lt;br /&gt;
4. Implementing several of these architectures and testing (for example, to see if learning also comes in two distinct phases: fitting and compression)&lt;br /&gt;
5. Using these empirical observations, and information theory to analyze these architectures.&lt;br /&gt;
6. Time permitted, play around with new RNN architectures.&lt;/p&gt;
&lt;h1&gt;Musical Style Learning from Musical Scores (Research/Start-Up Mode):&lt;/h1&gt;
&lt;p&gt; This idea lies somewhat outside traditional NLP in that it tackles the language of music. While the alphabet of a musical score consist chiefly of the 12 musical notes, there is added challenge in that several notes may be played simultaneously, especially if there are several instruments involved or simply the two hands of a pianist. Furthermore, the exact timing of each note played matters, note merely the ordering of the notes.&lt;/p&gt;
&lt;p&gt;The idea here is simply to, given the score of a musical piece, represented as a sequence of notes at each time, predict the era (Baroque, Classical, Romantic, etc.) or even, the composer of the piece (Bach, Beethoven, Brahms, etc.) There are several problems to be solved step by step for this project.&lt;/p&gt;
&lt;p&gt;1. Data collection from a large library of musical scores (ex: &lt;a href=&quot;http://imslp.org/&quot;&gt;IMSLP&lt;/a&gt;)&lt;br /&gt;
2. Data formatting so as to be usable.&lt;br /&gt;
3. Model selection.&lt;br /&gt;
4. Model implementation (PyTorch).&lt;br /&gt;
5. Model testing.&lt;/p&gt;
&lt;p&gt;There are also several extensions that can be viewed as stretch goals. For these, the first two can be reused.&lt;/p&gt;
&lt;h3&gt;Musical Score Generation:&lt;/h3&gt;
&lt;p&gt; Now, we learn how to compose a piece that “sounds” similar to a given composer. This will involve learning from the pieces written by a given input composer, and outputting a new piece. One core challenge here is ensuring that the output is syntactically correct.&lt;/p&gt;
&lt;h1&gt;Story Illustration (Start-Up Mode):&lt;/h1&gt;
&lt;p&gt; Given a short story and a specific scene (or place in the text), produce an image that is representative of the scene. This project combines aspects of NLP and vision. This project may also explore generative adversarial methods. One well-known challenge here is convergence.&lt;/p&gt;
&lt;p&gt;Here are the general steps for this project:&lt;br /&gt;
1. Data collection (image captioning dataset can be helpful)&lt;br /&gt;
2. Model selection.&lt;br /&gt;
3. Model implementation (PyTorch).&lt;br /&gt;
4. Model testing.&lt;/p&gt;
&lt;p&gt;As an extension, one can also generate several frames to form a short “movie”. Another can be comic book pane generation.&lt;/p&gt;</description>
	<pubDate>Wed, 04 Apr 2018 06:53:35 +0000</pubDate>
</item>
<item>
	<title>Halden Lin &lt;br/&gt; Team undef.: NLP Capstone | 01: Options</title>
	<guid isPermaLink="false">https://medium.com/p/ee873b6885d5</guid>
	<link>https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5?source=rss-2759d54493c0------2</link>
	<description>&lt;p&gt;Hello! This post is the first in a series that will document my progression through CSE 481n, taught by Prof. Yejin Choi at the University of Washington.&lt;/p&gt;&lt;p&gt;My github for this project can be found at: &lt;a href=&quot;https://github.com/haldenl/nlpcapstone&quot;&gt;https://github.com/haldenl/nlpcapstone&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;What I hope to explore&lt;/h3&gt;&lt;p&gt;Over the course of the next 10 weeks, I intend to explore the intersection of V&lt;strong&gt;isualization (Vis) and Natural Language Processing (NLP)&lt;/strong&gt;. I am particularly excited to explore the avenues through which Vis can be used to augment the interpretability of Neural Networks (NNs). I’ve spent the past year working around Vis (through classes and research) and am excited to bring what I’ve learned to problems in NLP. I intend to take a &lt;strong&gt;research oriented approach&lt;/strong&gt; to this project.&lt;/p&gt;&lt;h3&gt;Relevant Work (a brief and incomplete list)&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1506.02078.pdf&quot;&gt;Visualizing and Understanding Recurrent Neural Networks, Karpathy et al. (2015)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.aclweb.org/anthology/N16-1082&quot;&gt;Visualizing and Understanding Neural Networks in NLP, Li et al. (2016)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://distill.pub/2018/building-blocks/&quot;&gt;The Building Blocks of Interpretability, Olah et al. (2017)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1612.08220.pdf&quot;&gt;Understanding Neural Networks through Representation Erasure, Li et al. (2017)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://ufal.mff.cuni.cz/pbml/109/art-rikters-fishel-bojar.pdf&quot;&gt;Visualizing Neural Machine Translation Attention and Confidence, Rikters et al. (2017)&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Directions for Exploration&lt;/h3&gt;&lt;h4&gt;Option 1: Attention&lt;/h4&gt;&lt;p&gt;Visualizing and understanding &lt;strong&gt;attention&lt;/strong&gt;, with a focus on its role in text summarization.&lt;/p&gt;&lt;p&gt;This is my most realized idea at this time, so I will spend more time here explaining my thoughts.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Background:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Visualizations of attention are often used in an effort to understand, and subsequently improve, decisions made by neural networks. To my knowledge, the most common way of visualization attention in seq2seq models is via a 2-dimensional heat-map, wherein the attention each decoding unit gives to each input token can be seen.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/612/1*KvfXxucogv8flZHndSJvHg.png&quot; /&gt;Rikters et al. (2017). An attention visualization for a seq2seq problem (in this case, translation). Whiter cells represent higher attention.&lt;/figure&gt;&lt;p&gt;There are a few issues with this format: (1) it is difficult to fit the words (as seen above) on the x-axis, harming readability; (2) this does not scale well with large input or output (e.g. summarization); and (3) we do not read single-tokens at a time (i.e. y-axis), and input and output are generally not in this format either.&lt;/p&gt;&lt;p&gt;As a whole, this format, while simple, is lacking in interpretability. The cognitive work-load of a viewer is less than optimal.&lt;/p&gt;&lt;p&gt;Alternatives can be found in literature, such as the following from Rikters et al. (2017).&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*jtRrxf5pIB-OCBsoqUjgJQ.png&quot; /&gt;Rikters et al. (2017). The input sequence is seen on top — output on bottom. Thicker lines denote higher attention.&lt;/figure&gt;&lt;p&gt;However, this also suffers from similar interpretability and scalability issues. Moreover, the thickness of lines as an encoding scheme does not lend itself easily to comparison between words.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Proposed Exploration:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Perhaps interaction can be used to create a more insightful and interpretable visualization framework for understanding attention. For example, text heat-maps are already used widely to visualize sentiment analysis.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*lsgeuBXGGBog4YkuQNgJVw.png&quot; /&gt;Lin et al. (2017). Visualization of sentiment analysis on a token-by-token basis.&lt;/figure&gt;&lt;p&gt;In a static context, using this method for attention would require repeat of the same input sequence for each word in the output sequence. Using interaction, however, a model creator could brush over single or sequences of words in the output sequence to view corresponding soft-alignment in the input sequence. Aggregate visualizations could be shown to supplement this view (either aggregates over a particular input / output sequence, or aggregates over all input / output sequences).&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Baseline: &lt;/strong&gt;A user-interface for an interactive visualization of attention for seq2seq models (e.g. text summarization models). Exploration of how this visualization method can be used to either improve an existing models or understand the differences between models. This would, of course, require building a model from which to obtain data.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Reach: &lt;/strong&gt;Integration into an existing platform, e.g. in PyTorch to be viewable in TensorBoard.&lt;/p&gt;&lt;h4&gt;Option 2: Neural Network Cells&lt;/h4&gt;&lt;p&gt;Visualizing and understanding the role of cells in a neural network. In particular, the meaning of each cell within a model.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Background:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Though more exploration of relevant work will be required if this becomes the path of choice, Kaparthy et al. (2015) present work that serves as the basis for this idea. They show that the role of cells in a neural network can be interpreted by viewing their activations at each point in a given passage. For example, they found in their model a cell that fired at the end of a line (top left).&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*6yoF78PlE5ETNc9-kbya6w.png&quot; /&gt;Kaparthy et al. (2015). Different cells fire in different contexts.&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;Proposed Exploration:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Perhaps a deeper exploration of the activations of neural network cells could lead to insights for visualizations that may aid the interpretability of neural networks.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Baseline: &lt;/strong&gt;Create a program or UI that generates a visualization (either interactive or static), of the activations of each cell in a neural network. Use this information to posit the meanings of each cell and build further visualizations as needed for exploration. This would require building a model from which to obtain observations.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Reach:&lt;/strong&gt; This is a little loose, as it is unclear how much exploration will be needed to produce results. Perhaps as in Option 1, integration of whatever tool created into an existing framework.&lt;/p&gt;&lt;h4&gt;Option 3: Gates and Value flow in RNN models.&lt;/h4&gt;&lt;p&gt;Visualizing and understanding the flow of values through gates in a Recurrent Neural Network (RNN). In particular, allowing for interpretability of gates and the ‘memory’ of cells.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Background:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;My motivation for this idea is largely anecdotal. I recall while taking the undergraduate NLP course that the concepts of ‘gates’ and ‘memory’ in RNN models (e.g. GRU, LSTM) were difficult for me to wrap my head around. We have these giant networks with variable length ‘memory’ determined by gates that preform well as a result of this mechanism, but how exactly is this mechanism is used, and on what tokens at what points? Kaparthy et al. (2015) present a way of visualizing the ‘memory’ of cells in an LSTM model via plotting of cells and the time spent right or left saturated (right saturated cells remember values for longer periods of time).&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/975/1*Qq9KrefGEl7tM4mPxUi99g.png&quot; /&gt;Kaparthy et al. (2015). Visualizing the cells and their time spent right or left saturated.&lt;/figure&gt;&lt;p&gt;Data-flow graphs have already been developed for neural networks (e.g. Wongsuphasawat et al. (2017)). An RNN specific model with a focus on interpretability of gates may be valuable for the NLP community.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Proposed Exploration:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Perhaps producing visualizations of a network of cells using information similar to above could lead to improvements in interpretability and aid model improvement.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Baseline: &lt;/strong&gt;Create a program or UI to generate a visualization, as described above, of an small RNN models. Use this generate insight into the model’s behavior (e.g. compare between models), and explore further from there.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Reach: &lt;/strong&gt;Support larger-scale networks. Integration into existing frameworks.&lt;/p&gt;&lt;h3&gt;Works Cited&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1506.02078.pdf&quot;&gt;Karpathy, Andrej, Justin Johnson, and Li Fei-Fei. “Visualizing and understanding recurrent networks.” &lt;em&gt;arXiv preprint arXiv:1506.02078&lt;/em&gt; (2015).&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1506.01066.pdf&quot;&gt;Li, Jiwei, &lt;em&gt;et al.&lt;/em&gt; “Visualizing and understanding neural models in NLP.” &lt;em&gt;arXiv preprint arXiv:1506.01066&lt;/em&gt; (2015).&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1612.08220.pdf&quot;&gt;Li, Jiwei, Will Monroe, and Dan Jurafsky. “Understanding neural networks through representation erasure.” &lt;em&gt;arXiv preprint arXiv:1612.08220&lt;/em&gt; (2016).&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://ufal.mff.cuni.cz/pbml/109/art-rikters-fishel-bojar.pdf&quot;&gt;Rikters, Matīss, Mark Fishel, and Ondřej Bojar. “Visualizing neural machine translation attention and confidence.” &lt;em&gt;The Prague Bulletin of Mathematical Linguistics&lt;/em&gt; 109.1 (2017): 39–50.&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://idl.cs.washington.edu/files/2018-TensorFlowGraph-VAST.pdf&quot;&gt;K. Wongsuphasawat &lt;em&gt;et al&lt;/em&gt;., “Visualizing Dataflow Graphs of Deep Learning Models in TensorFlow,” in &lt;em&gt;IEEE Transactions on Visualization and Computer Graphics&lt;/em&gt;, vol. 24, no. 1, pp. 1–12, Jan. 2018.&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1703.03130.pdf&quot;&gt;Lin, Zhouhan, &lt;em&gt;et al.&lt;/em&gt;, “A structured self-attentive sentence embedding.” &lt;em&gt;arXiv preprint arXiv:1703.03130&lt;/em&gt; (2017).&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img height=&quot;1&quot; src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=ee873b6885d5&quot; width=&quot;1&quot; /&gt;</description>
	<pubDate>Wed, 04 Apr 2018 06:43:21 +0000</pubDate>
</item>
<item>
	<title>Ananth Gottumukkala &lt;br/&gt; Team Turing Test: Top 3 Project Ideas I’m Excited For</title>
	<guid isPermaLink="false">http://deeplearningturingtest.wordpress.com/?p=3</guid>
	<link>https://deeplearningturingtest.wordpress.com/2018/04/04/the-journey-begins/</link>
	<description>&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Visualizing a text-based description:&lt;/strong&gt; Train a model to learn a language to image mapping with simple descriptions. The minimum plan would be to feed the model short text descriptions like “white hat” and “black cat” with their corresponding visual outputs. Then, if the text “white cat” is input at test time, the model should output the cat with the same shade of white as the hat. Stretch goals include visualizing multiple objects in the same picture and/or visualizing them in different spatial orientations with respect to each other (e.g. on top of, inside, underneath, next to, etc.).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generating Multimodal Word Embeddings:&lt;/strong&gt; The goal is to create word embeddings that describe a word more holistically from multiple modalities like audio and visual inputs. One possible approach is to concatenate pre-trained word embeddings (e.g. GloVe vector) with additional features based on what context the word is in the present sentence. Then, concatenate this with features generated from a deep fully connected layer of a ConvNet where the input is an image of the actual word (e.g. car). Stretch goals include using these augmented embeddings to enhance performance in applications like sentiment analysis or further augmenting these embeddings with audio features of the word being pronounced (which can help distinguish different meanings of the word).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dialogue and Information State Tracking:&lt;/strong&gt; The goal is to create a model that can either receive contextual information as text or probe the environment with questions and receive an answer as text. This text can either be input into a linear or tree LSTM for entity extraction, coreference resolution, parsing, and/or other algorithms which can extract valuable contextual information. Then, this text can be used to update the current dialogue and/or information state using deep reinforcement learning. The policy then uses the updated state to choose the next action and hopefully keep repeating this until the text is satisfactorily understood. Stretch goals include using this model to answer test questions about the reading material using a machine comprehension model like the ReasoNet architecture.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;Git Repo URL: &lt;a href=&quot;https://gitlab.cs.washington.edu/ananthgo/cse481n-capstone&quot; rel=&quot;nofollow&quot;&gt;https://gitlab.cs.washington.edu/ananthgo/cse481n-capstone&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This project is in research mode with a heavy focus on making improvements in keeping track of the meaning behind lines of input text.&lt;/p&gt;</description>
	<pubDate>Wed, 04 Apr 2018 05:42:14 +0000</pubDate>
</item>
<item>
	<title>Sarah Yu &lt;br/&gt; Team Jekyll-Hyde: Inaugural Blog Post</title>
	<guid isPermaLink="true">http://sarahyu.weebly.com/cse-481n/inaugural-blog-post</guid>
	<link>http://sarahyu.weebly.com/cse-481n/inaugural-blog-post</link>
	<description>&lt;div class=&quot;paragraph&quot;&gt;Welcome to the first blog post of &lt;u&gt;&lt;em&gt;Jekyll-Hyde&lt;/em&gt;&lt;/u&gt;&lt;em&gt; &lt;/em&gt;&lt;u&gt;(&lt;/u&gt;my very cool and somewhat related group-of-1 name).&lt;br /&gt;As the name might reveal, I’m interested in using NLP to uncover the duality of language, the ability to simultaneously present both sides of a coin, whether in everyday conversation or more curated prose. Because language matters; so much so that we mend and mold our language to navigate the different social environments and spaces we inhabit, whether for power, survival, or acceptance, and often in the most primitive and subconscious ways. And because in today’s (supposedly) civilized world, the language we employ with another can be a sort of proxy for the relationship we share. I'd like to get at some of these ideas through the NLP capstone and think the next three topics are a potential start. &lt;br /&gt;&lt;br /&gt;1) Language Accommodation (or my unlikely paper title: &lt;em&gt;Nice Guy by Day, A**hole by Night: Language Accommodation for Self-Presentation in Subreddit Communities)&lt;/em&gt;&lt;ul&gt;&lt;li&gt;​MVP: Scrape Reddit user data, identify language baselines for a given subreddit or capture linguistic differences of a single user across subreddits&lt;/li&gt;&lt;li&gt;Stretch Goals: Do both (subreddit baselines and user difference) and not only identify a user's language accommodation, but how they fall in line with the communities' baseline (a kind of hive mentality)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;2) Identifying Condescension (another working title: &quot;&lt;em&gt;Well, Actually&quot;: Identifying Ambiguities in emails from 'helpful' colleagues&lt;/em&gt;)&lt;ul&gt;&lt;li&gt;​MVP: Identify an appropriate data source (ideally emails or more personal interactions), manually identify possible ambiguities, train model (maybe one that doesn't require a large dataset) to identify ambiguous spans of a sentence. &lt;/li&gt;&lt;li&gt;Stretch Goals: Begin identifying entity-entity-relationships with cues from ambiguous interactions or maybe something cooler about context and the different meanings if ambiguous...&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;3) Identifying Disrespect (might as well for consistency: &lt;em&gt;Linguistic (dis)R.E.S.P.E.C.T. - Addressing 90% of Comment Sections)&lt;/em&gt;&lt;ul&gt;&lt;li&gt;​MVP: Scrape Youtube comment data, classify comments as hateful/not hateful, train model on classified comments, test and tune&lt;/li&gt;&lt;li&gt;Stretch Goals: Train a portable model that can work with content from other mediums such as Twitter and Reddit&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;I'll be pursuing one of these ideas in &lt;strong&gt;research mode&lt;/strong&gt; and you can follow along at:&lt;br /&gt;                                      https://github.com/sarahyu17/481n&lt;/div&gt;  &lt;div class=&quot;wsite-spacer&quot; style=&quot;height: 50px;&quot;&gt;&lt;/div&gt;  &lt;div&gt; 				&lt;form action=&quot;http://www.weebly.com/weebly/apps/formSubmit.php&quot; enctype=&quot;multipart/form-data&quot; id=&quot;form-147197638403517045&quot; method=&quot;POST&quot;&gt; 					&lt;div class=&quot;wsite-form-container&quot; id=&quot;147197638403517045-form-parent&quot; style=&quot;margin-top: 10px;&quot;&gt; 						&lt;ul class=&quot;formlist&quot; id=&quot;147197638403517045-form-list&quot;&gt; 							&lt;h2 class=&quot;wsite-content-title&quot;&gt;Any Favorite Paper Titles?&lt;/h2&gt;  &lt;label class=&quot;wsite-form-label wsite-form-fields-required-label&quot;&gt;&lt;span class=&quot;form-required&quot;&gt;*&lt;/span&gt; Indicates required field&lt;/label&gt;&lt;div&gt;&lt;div class=&quot;wsite-form-field&quot; style=&quot;margin: 5px 0px 0px 0px;&quot;&gt;   &lt;label class=&quot;wsite-form-label&quot; for=&quot;input-789590629342031487&quot;&gt;Paper Title &lt;span class=&quot;form-required&quot;&gt;*&lt;/span&gt;&lt;/label&gt;   &lt;div class=&quot;wsite-form-radio-container&quot;&gt;     &lt;span class=&quot;form-radio-container&quot;&gt;&lt;input id=&quot;radio-0-_u789590629342031487&quot; name=&quot;_u789590629342031487&quot; type=&quot;radio&quot; value=&quot;#1&quot; /&gt;&lt;label for=&quot;radio-0-_u789590629342031487&quot;&gt;#1&lt;/label&gt;&lt;/span&gt;&lt;span class=&quot;form-radio-container&quot;&gt;&lt;input id=&quot;radio-1-_u789590629342031487&quot; name=&quot;_u789590629342031487&quot; type=&quot;radio&quot; value=&quot;#2&quot; /&gt;&lt;label for=&quot;radio-1-_u789590629342031487&quot;&gt;#2&lt;/label&gt;&lt;/span&gt;&lt;span class=&quot;form-radio-container&quot;&gt;&lt;input id=&quot;radio-2-_u789590629342031487&quot; name=&quot;_u789590629342031487&quot; type=&quot;radio&quot; value=&quot;#3&quot; /&gt;&lt;label for=&quot;radio-2-_u789590629342031487&quot;&gt;#3&lt;/label&gt;&lt;/span&gt;   &lt;/div&gt;   &lt;div class=&quot;wsite-form-instructions&quot; id=&quot;instructions-Paper Title&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 						&lt;/ul&gt; 					&lt;/div&gt; 					&lt;div style=&quot;display: none;&quot;&gt; 						&lt;input name=&quot;weebly_subject&quot; type=&quot;text&quot; /&gt; 					&lt;/div&gt; 					&lt;div style=&quot;text-align: left; margin-top: 10px; margin-bottom: 10px;&quot;&gt; 						&lt;input name=&quot;form_version&quot; type=&quot;hidden&quot; value=&quot;2&quot; /&gt; 						&lt;input id=&quot;weebly-approved&quot; name=&quot;weebly_approved&quot; type=&quot;hidden&quot; value=&quot;approved&quot; /&gt; 						&lt;input name=&quot;ucfid&quot; type=&quot;hidden&quot; value=&quot;147197638403517045&quot; /&gt; 						&lt;input name=&quot;recaptcha_token&quot; type=&quot;hidden&quot; /&gt; 						&lt;input name=&quot;opted_in&quot; type=&quot;hidden&quot; value=&quot;0&quot; /&gt; 						&lt;input type=&quot;submit&quot; /&gt; 						&lt;a class=&quot;wsite-button&quot;&gt; 							&lt;span class=&quot;wsite-button-inner&quot;&gt;vote&lt;/span&gt; 						&lt;/a&gt; 					&lt;/div&gt; 				&lt;/form&gt; 				&lt;div class=&quot;recaptcha&quot; id=&quot;g-recaptcha-147197638403517045&quot;&gt;&lt;/div&gt; 			  			&lt;/div&gt;</description>
	<pubDate>Tue, 03 Apr 2018 07:00:00 +0000</pubDate>
</item>
<item>
	<title>Ron Fan, Aditya Saraf &lt;br/&gt; Team PrimeapeNLP: Blog Post #1</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-3753031463594823927.post-6307882466820480344</guid>
	<link>https://cse481n.blogspot.com/2018/04/blog-post-1.html</link>
	<description>&lt;div style=&quot;font-family: Verdana; text-align: left;&quot;&gt;    &lt;div&gt;Temporary GitHub URL: &lt;a href=&quot;https://github.com/rococode/primeapeNLP&quot; target=&quot;_blank&quot;&gt;https://github.com/rococode/primeapeNLP&lt;/a&gt;&lt;/div&gt;    &lt;div&gt;We plan to be in “research mode” for this capstone.&lt;/div&gt;    &lt;div style=&quot;font-size: 1.1rem;&quot;&gt;Three possible ideas:&lt;/div&gt;     &lt;div style=&quot;font-size: 1.1rem;&quot;&gt;1. New evaluation methods for text generation models&lt;/div&gt;    &lt;div&gt;There don’t seem to be many good ways to evaluate the output of machine generated text (such as in the problem of creating hotel reviews). We want our models to generate text that’s indistinguishable from human text, but it’s hard to quantify how similar generated text is to human text, so it’s hard to see when progress is being made. However, it feels like the problem of actually generating human-like text should be harder than the problem of just checking if that text seems human. As a baseline approach, we would like to explore building a regression model for the “humanness” of a piece of unfamiliar text.&lt;/div&gt;    &lt;div&gt;&lt;strong&gt;        M&lt;span style=&quot;font-size: 0.7rem; font-weight: normal;&quot;&gt;(inimal)&lt;/span&gt;        V&lt;span style=&quot;font-size: 0.7rem; font-weight: normal;&quot;&gt;(iable)&lt;/span&gt;        P&lt;span style=&quot;font-size: 0.7rem; font-weight: normal;&quot;&gt;(lan)&lt;/span&gt;    :&lt;/strong&gt;&lt;/div&gt;    &lt;ol&gt;        &lt;li&gt;Build a reasonably large dataset using a combination of web scraping, existing datasets, and existing generative models&lt;/li&gt;        &lt;li&gt;Build a regression model with decent performance on training set&lt;/li&gt;        &lt;li&gt;Build a regression model with decent performance on development and test sets&lt;/li&gt;    &lt;/ol&gt;    &lt;div&gt;&lt;strong&gt;Stretch goals:&lt;/strong&gt;&lt;/div&gt;    &lt;ol&gt;        &lt;li&gt;Use our model to score various generative models and compare our model’s rankings for these generative models to commonly agreed-upon rankings by researchers&lt;/li&gt;        &lt;li&gt;Integrate model scores into a “generate a lot of possibilities, then search for the best one” approach for text generation&lt;/li&gt;    &lt;/ol&gt;    &lt;div&gt;We would also explore non-neural methods for evaluating Natural Language Generation (NLG). One idea would be to compare the probability distribution of generated sentences to real sentences. A common problem is that generated text repeats the most probable sentences over and over. Thus, the distribution of sentences is front-loaded. We hypothesize that generated text with a sentence distribution that closely mirrors real text would be more difficult to distinguish from real text. However, we first need to investigate what real world sentence distributions look like. It may be likely that individual sentences are not likely to repeat - in that case, the distribution would be more-or-less uniform across all sentences. We may need to come up with a novel method to categorize similar sentences. We would have to decide whether to use semantic similarity or syntactic similarity.&lt;/div&gt;    &lt;div&gt;&lt;strong&gt;MVP:&lt;/strong&gt;&lt;/div&gt;    &lt;ol&gt;        &lt;li&gt;Gather a data set - perhaps the data set Ari showed us for hotel reviews.&lt;/li&gt;        &lt;li&gt;Examine the existing probability distribution at the sentence-level in the corpus. If the distribution is too uniform, design a method to place similar sentences in the same “bucket” and re-compute the probability distribution.&lt;/li&gt;        &lt;li&gt;Design metrics to compute the similarity of two distributions; if a model is “good”, the distribution of the generated sentences will match the distribution of the training corpus.&lt;/li&gt;        &lt;li&gt;Use our metric to score generated text models found in the literature.&lt;/li&gt;    &lt;/ol&gt;    &lt;div&gt;&lt;strong&gt;Stretch goals:&lt;/strong&gt;&lt;/div&gt;    &lt;ul&gt;        &lt;li&gt;Use insights from our metrics to improve on current approaches to NLG.&lt;/li&gt;    &lt;/ul&gt;    &lt;div style=&quot;font-size: 1.1rem;&quot;&gt;2. Single-document summarization&lt;/div&gt;    &lt;div&gt;Single document summarization (SDS) models typically label each sentence in the document as in the summary or not in the summary. The problem then becomes a binary classification problem, and many people train a NN with supervised learning. However, there are other non-neural approaches to this problem that have been tried successfully. One paper shows how SDS can be thought of as a tree based Knapsack problem, which is then solved by a Integer Linear Programming (ILP) solver (see: &lt;a href=&quot;https://www.semanticscholar.org/paper/Single-Document-Summarization-as-a-Tree-Knapsack-Hirao-Yoshida/ed0c8a7ab911cdb30b7e95edada3a55c01eb22c5&quot;&gt;https://www.semanticscholar.org/paper/Single-Document-Summarization-as-a-Tree-Knapsack-Hirao-Yoshida/ed0c8a7ab911cdb30b7e95edada3a55c01eb22c5&lt;/a&gt;). We would like to explore both neural models and non-neural approaches to SDS. &lt;/div&gt;    &lt;div&gt;&lt;strong&gt;MVP:&lt;/strong&gt;&lt;/div&gt;    &lt;ol&gt;        &lt;li&gt;As a baseline approach, build neural models from current papers that solve SDS. Evaluate the performance using F1 as well as ROUGE metrics (see: &lt;a href=&quot;https://en.wikipedia.org/wiki/ROUGE_(metric)&quot;&gt;https://en.wikipedia.org/wiki/ROUGE_(metric)&lt;/a&gt;).&lt;/li&gt;        &lt;li&gt;Build neural models from current papers that focus on non-neural approaches, such as the combinatorial approach described above.&lt;/li&gt;        &lt;li&gt;Evaluate neural and non-neural approaches: what do these approaches have in common? What key insights are they leveraging? Are there any generalizations of the problem that can be extracted? Hopefully, this study will allow us to either improve the SOTA neural models or fine tune some non-neural approach.&lt;/li&gt;    &lt;/ol&gt;    &lt;div&gt;&lt;strong&gt;Stretch goal:&lt;/strong&gt;&lt;/div&gt;    &lt;ul&gt;        &lt;li&gt;Use insights from our studies to formulate and solve SDS in a unique way. Evaluate our approach using F1 and ROUGE metrics.&lt;/li&gt;    &lt;/ul&gt;    &lt;div style=&quot;font-size: 1.1rem;&quot;&gt;3. Multi-span comprehension&lt;/div&gt;    &lt;div&gt;Reading comprehension models generally operate by extracting an answer to a question by outputting a start and end index on the original passage. This is not a very human-like way of answering questions, and makes it impossible to generate good answers to some simple factual questions using common sentence structures. We would like to explore ways of answering questions from passages without being limited to a single span from the passage text.&lt;/div&gt;    &lt;div&gt;&lt;strong&gt;MVP:&lt;/strong&gt;&lt;/div&gt;    &lt;ol&gt;        &lt;li&gt;Implement a baseline model that performs near state of the art levels on the SQuAD dataset.&lt;/li&gt;        &lt;li&gt;Build a dataset that requires information from multiple spans to answer the questions well. We will likely create this dataset by hand.&lt;/li&gt;        &lt;li&gt;Build a model that answers questions about a passage by generating multiple spans. We envision designing our model to output a sequence of indices such that every pair of indices corresponds to one part of the answer. This model should perform almost as well as the baseline model on SQuAD, since that’s just a specific case (one span) of a multi-span answer.&lt;/li&gt;        &lt;li&gt;Build upon the previous model by using the output spans to generate a formal answer through a generative model, using the output spans and the question sentence as inputs.&lt;/li&gt;    &lt;/ol&gt;    &lt;div&gt;&lt;strong&gt;Stretch goal:&lt;/strong&gt;&lt;/div&gt;    &lt;ul&gt;        &lt;li&gt;Optimize model to actually be effective at answering multispan questions. We expect this to be quite difficult, so while building a functioning model is part of the MVP, actually having it perform comparatively well is a stretch goal.&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;</description>
	<pubDate>Mon, 02 Apr 2018 04:32:00 +0000</pubDate>
	<author>noreply@blogger.com (Ron &amp; Aditya)</author>
</item>

</channel>
</rss>
