<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>











<head>
<title>NLP Capstone Spring 2018</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="generator" content="http://intertwingly.net/code/venus/">
<link rel="stylesheet" href="planet.css" type="text/css">
<link rel="alternate" href="https://nlpcapstone.github.io/atom.xml" title="" type="application/atom+xml">
</head>

<body>
<h1>NLP Capstone Spring 2018</h1>

<div class="daygroup">
<h2>May 29, 2018</h2>

<div class="channelgroup">







<h3><a href="http://sarahyu.weebly.com/cse-481n" title="Sarah yu - CSE 481N">Sarah Yu <br/> Team Jekyll-Hyde</a></h3>


<div class="entrygroup" id="http://sarahyu.weebly.com/cse-481n/last-update">
<h4><a href="http://sarahyu.weebly.com/cse-481n/last-update">Last Update</a></h4>
<div class="entry">
<div class="content">
<div class="paragraph">The final update for the project! Unfortunately, there is not as much to report on results as usual and not as many fun visualizations. For the 2nd Advanced Model, my plan was to begin on the stretch goals I had initially outlined and train a neural model for Reddit Post classification and Generation. The idea took cue from the Affect-LM paper. Basically it would be similar to this model</div>  <div><div class="wsite-multicol"><div class="wsite-multicol-table-wrap"> 	<table class="wsite-multicol-table"> 		<tbody class="wsite-multicol-tbody"> 			<tr class="wsite-multicol-tr"> 				<td class="wsite-multicol-col" style="width: 13.331751602564%; padding: 0 15px;"> 					 						  <div class="wsite-spacer" style="height: 50px;"></div>   					 				</td>				<td class="wsite-multicol-col" style="width: 68.227199377828%; padding: 0 15px;"> 					 						  <div><div class="wsite-image wsite-image-border-none " style="padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;"> <a> <img alt="Picture" src="http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/screen-shot-2018-05-29-at-9-42-04-am_orig.png" style="width: auto;" /> </a> <div style="display: block; font-size: 90%;"></div> </div></div>   					 				</td>				<td class="wsite-multicol-col" style="width: 18.441049019608%; padding: 0 15px;"> 					 						  <div class="wsite-spacer" style="height: 50px;"></div>   					 				</td>			</tr> 		</tbody> 	</table> </div></div></div>  <div class="paragraph">which has inputs of the context words, on which to build up the rest of the sentence from; the Affect category which is chosen beforehand to generate the desired output; and an Affect strength to determine the intensity of the affect category defined. <br /><br />My model would be similar to this, but instead look more like the following where we take out the strength factor and choose the mental category  to be fed into the Mental LM.</div>  <div><div class="wsite-multicol"><div class="wsite-multicol-table-wrap"> 	<table class="wsite-multicol-table"> 		<tbody class="wsite-multicol-tbody"> 			<tr class="wsite-multicol-tr"> 				<td class="wsite-multicol-col" style="width: 24.666352941176%; padding: 0 15px;"> 					 						  <div class="wsite-spacer" style="height: 50px;"></div>   					 				</td>				<td class="wsite-multicol-col" style="width: 56.902274509804%; padding: 0 15px;"> 					 						  <div><div class="wsite-image wsite-image-border-none " style="padding-top: 10px; padding-bottom: 10px; margin-left: 0; margin-right: 0; text-align: center;"> <a> <img alt="Picture" src="http://sarahyu.weebly.com/uploads/2/4/3/0/24307463/published/screen-shot-2018-05-29-at-10-56-19-pm.png?1527659857" style="width: auto;" /> </a> <div style="display: block; font-size: 90%;"></div> </div></div>   					 				</td>				<td class="wsite-multicol-col" style="width: 18.43137254902%; padding: 0 15px;"> 					 						  <div class="wsite-spacer" style="height: 50px;"></div>   					 				</td>			</tr> 		</tbody> 	</table> </div></div></div>  <div class="paragraph">My current model seems to have some issues generating posts containing any language beyond the exact topic of the mental category itself (i.e. using the word depressed for the F30 category), with the model using the cross entropy loss. <br /><br />At this point, the game plan is to fix the bugs and get a working model to test out the post generation. The results will be interesting to see in and of themselves, but I will also compare the language model of the generated posts against the metrics we hav seen throughout the quarter (vennclouds, idp). </div></div>







<p class="date">
<a href="http://sarahyu.weebly.com/cse-481n/last-update">May 29, 2018 05:35 PM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2" title="Stories by Ryan Pham on Medium">Ryan Pham <br/> Team NeuralEmpty</a></h3>


<div class="entrygroup" id="https://medium.com/p/81ba6be6634">
<h4><a href="https://medium.com/@ryanp97/data-subsets-parent-feeding-and-future-work-81ba6be6634?source=rss-6378d85d3a9b------2">Data Subsets, Parent Feeding, and Future Work</a></h4>
<div class="entry">
<div class="content">
<p>In the last week, I’ve been training more models on different subsets of the data and began working on implementing parent feeding. Though I don’t think I will have parent feeding done in time for the final presentation, it’ll be a nice checkpoint to start at after this capstone finishes.</p><h4>Data Subsets</h4><p>The model trained on all of Michael Goodman’s data last week had an issue with SMATCH (which is why the SMATCH score was omitted in last week’s blogpost). It turns out that there were a couple translation pairs in which the unicode character U+3000 (ideographic/wide space) was used as a token causing it to appear as a surface predicate in some development examples. As a result, SMATCH had issues dealing with these and crashed. Considering how infrequently this surface predicate actually occurred, I decided to invalidate the graphs that contained them during post-processing. This model ‘achieved’ a SMATCH score of 0.54. For reference, when treating the predicates as a bag of words, the model had an F1 score of 0.52.</p><p>Considering the Kyoto Corpus suffers the issue of having many uncommon named entities, I decided to train a model on just the Japanese WordNet corpus. This dataset is significantly smaller with ~105,000 training examples compared to ~325,000 training examples for the combined corpus. I figured this dataset would have significantly fewer named entities and not mis-predict the named abstract predicate so often. This model did, in fact, achieve a better SMATCH score with a F1 of 0.57 and an F1 score of 0.54 when treating the predicates as a bag of words. Notably, the named abstract predicate was mis-predicted less often, though it was still in the top 10 mis-predicted predicates. This resulted in a higher abstract predicate precision, ~0.04 above. Surprisingly, however, the surface predicate precision drop ~0.04. I’m not entirely sure why quite yet, but it may be due to the ratio of number of surface predicates to number of abstract predicates in each dataset.</p><p>I’m currently training a model with all of the data from Michael Goodman and adding all the training examples I had parsed from the Tanaka Corpus. In theory this model should perform slightly better than the model trained with solely Michael Goodman’s dataset, though I won’t be able to tell until late tomorrow considering the time it takes to train a single epoch.</p><h4>Parent Feeding</h4><p>Working with OpenNMT’s codebase has been quite a pain. Though I’ve implemented a short method to calculate the parent indicies of a single graph, I have had lots of trouble figuring out where exactly they should be calculated and how they will be stored. For now I’ve placed it as a step in ShardedTextCorpusIterator. So the pipeline for generating the input to OpenNMT is still the same. The preprocess.py script takes the same inputs and outputs as usual. The only thing that is different now is the saved files will now also contain parent indicies for each example.</p><p>I haven’t been able to figure out how batching will work with this quite yet, so I’m meeting up with Jan later this week to discuss how we should do batching for this. Once Jan clears up how batching works on Wednesday, I should have a good enough understanding to attempt to modify/write a decoder that also uses parent feeding.</p><h4>ELMo Embeddings</h4><p>After discussing with Jan more, I likely would not see significantly improved results with ELMo embeddings unless I was able to scrape more data to train these embeddings with. Since the vocabulary the model is trying to predict are predicates and edges, I would have to generate graphs after scraping more data for both languages. Considering how little time I have left, I decided to leave this for future work.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=81ba6be6634" width="1" /></div>







<p class="date">
<a href="https://medium.com/@ryanp97/data-subsets-parent-feeding-and-future-work-81ba6be6634?source=rss-6378d85d3a9b------2">by Ryan Pham at May 29, 2018 12:20 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>May 23, 2018</h2>

<div class="channelgroup">







<h3><a href="https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2" title="Stories by Viterbi Or Not To Be on Medium">Aaron Johnston, Lynsey Liu <br/> Team Viterbi Or Not To Be</a></h3>


<div class="entrygroup" id="https://medium.com/p/d4957f6e802">
<h4><a href="https://medium.com/@viterbi.or.not/advanced-model-2-part-2-d4957f6e802?source=rss-c522ef075bb3------2">Advanced Model #2, Part 2</a></h4>
<div class="entry">
<div class="content">
<p>Now that we’ve finished our minimum viable product, for Part 2 we’re focusing on further analysis and improvement of our advanced model, working on a demo to showcase our results, and drawing up a final action plan to wrap up the project!</p><h4><strong>Demo</strong></h4><p>One of the big things that we have been working on in the past week is a demo to illustrate a possible use case for our model. Our goal for the demo is ultimately to provide an interface in which users can simulate having a conversation or opening a long conversation and subsequently being able to access a useful summary of the topics and ideas that were discussed.</p><p>While coming up with our concept for the demo, we had to first make a choice about the input format that would be presented to users. After much discussion, we decided that the interface would have the most impact if it could operate on “live” data — that is, rather than simply uploading an existing conversation, if users could interact with a summary in realtime during a conversation it would help show exactly how our model works. Furthermore, although we set out to explore this project mainly for its technical merit and to understand both the universal features of language and the techniques used in summarization, we believe that our findings would be most directly useful as an augmentation for an application that already handles conversations. That way, a user has the opportunity to get immediate assistance after falling behind in a group conversation, and to explore their records of conversations via summaries rather than perusing the entire conversation.</p><p>All of these requirements, from the realtime interaction to the use case as an augmentation to an existing app, pointed us toward using chat data for the demo. We ultimately decided to create a simplistic chat interface that would allow users to stage a conversation and generate summaries directly from that — our idea being that generating the summary, chatting more in the conversation, and then seeing how the summary changes would be the most effective feedback loop for allowing users to understand what our model is doing.</p><p>As it currently exists, our demo is extremely bare-bones and serves as a proof of concept more than anything else. Users can chat in realtime, and summaries can be requested using an API call to pull the summary from a pre-trained model in our backend. We are currently working on improving the interface to be more usable, and on hosting the demo so that people can give it a try in more situations than just locally from within our repository.</p><h4><strong>Plans for Demo Expansion: Summary Visualization</strong></h4><p>In order to make the summary more usable, we want to “weave” it into the conversation so that it can serve as an augmentation rather than a totally separate feature. After all, because our model currently produces only extractive summaries, it makes sense to tie the exact sentences chosen for extraction back to the conversation. Right now, we are working on making the summary interactive in the sense that a user can click the sentences in the summary in one pane and jump to those points in the conversation, using the summary almost as a table of contents. We believe this design showcases our summary effectively and uses it as a convenient entry point for the user while still allowing them to get more detailed information if needed.</p><p>Another possibility would be to allow the user to adjust the compression ratio used in the summary, to specify if they want the summary to be only 10% of the conversation or 50%. This has the possibility of making it more user-friendly because they can create a summary for a specific use case, such as an extremely high-level summary being more useful for someone’s records as a simple reminder of a conversation they have already read, while a more in-depth summary might serve better in the use case of catching up on a conversation that has had many messages since the user last visited. However, there is also a downside to this option — by allowing users to specify a hard and fast percentage, our model loses the ability to dynamically adapt the length of the summary based on what is important. In other words, if there are n sentences available in the summary and n+1 nearly equally important sentences to fully capture the thread’s meaning, enforcing the n sentences would cause the summary to lose value while using an absolute threshold would make the summary longer if there is truly more content to display.</p><h4><strong>Plans for Expansion: Feature Visualization</strong></h4><p>One additional thing we have been exploring is the option for users to visualize the factors that lead to a sentence being selected for the summary. This would be a more technical option than those described above, because it would expose the actual features our model uses. To make this work, we would need to come up with a reliable way to calculate the “basis” for each sentence’s classification, which is a somewhat nebulous concept and therefore something we are still discussing. In general, it is possible to determine the weight that our model places on each of the features, but we would need to also understand the boundary used for each feature in order to provide useful information about a specific sentence. For example, consider a feature like the intensity of the sentiment score for a given sentence: we might be able to determine that our model places a higher-than-average weight on this feature, but we would need information about whether a higher or lower sentiment score is more likely to lead to classification as part of the summary in order to display to the user whether or not that had led to the specific sentence’s labelling. In addition, the high number of features we have in our feature set threatens to overwhelm any interface we include them in.</p><p>If individual features for sentences cannot be applied, another approach we have considered is displaying information such as the topic segmentation that has been applied or which sentences have been modified based on our preprocessing. Doing so would allow the user of our demo to easily understand how our model responds to certain types of data, which would also allow us to potentially debug our model as we make improvements over the next few weeks.</p><h4><strong>Process of Chat Integration</strong></h4><p>Because a large part of our overall project plan is to incorporate both chatlog and email data, a lot of our effort over the past few weeks has been in standardizing our feature set and project pipeline to be able to support chat data. While a big portion of that has been focused on parsing and preprocessing in order to be able to train and evaluate on chat data, this past week we have been running tests to understand the differences between the different types of data and the limitations of using the enormous chatlog dataset.</p><p>In particular, we noticed that despite having so much data available, the chatlog dataset was effectively unusable as a training set when using a Naive Bayes model. Although that model had previously been most effective for almost all of our feature sets, we noticed that when applied to the chatlog data it had the distinct tendency to produce summaries in which 0 (or very, very few) sentences were selected. This problem did not show up using Decision Trees, which had decent results based on both ROUGE scores and human evaluation.</p><p>Although we are still not entirely sure about the cause of the issue with Naive Bayes, one possible explanation is that the number of sentences included in the reference summary for each training thread is so small that the model ended up having the best chance of classifying a sentence correctly by simply discluding every sentence. It is possible that the structural differences between the Naive Bayes and Decision Tree models caused the latter model to create trees of such a depth that they were able to learn the difference between included and excluded sentences even with so few examples. We definitely have more analysis to do in the coming weeks to understand this disparity better, but more than anything else it alerted us to the fact that the vastness of the chatlog data is a double-edged sword — although it provides more data on which to train, it also brings a new problem of extremely sparse reference summaries.</p><h4><strong>Fixing using Regression SVM</strong></h4><p>Normally, using Decision Trees over Naive Bayes would not be a major setback, because although Naive Bayes performed slightly better for most applications in the email dataset they were relatively comparable. However, with the introduction of the compression ratio that we discussed in last week’s blog post, we found that additional work was necessary to use the compression ratio with the chatlog data. Because the Naive Bayes regression implementation we had been using never labelled sentences as being part of the summary during our testing, we eventually decided to incorporate SKLearn’s SVM Regression model in order to provide regression functionality for the chatlog data and enable us to manually tune the compression ratio.</p><h4><strong>Participant Tracking</strong></h4><p>In an effort to capture more conversation-specific aspects of the data, we added a feature to take into account the author of a sentence when vectorizing. The author frequency feature is calculated by taking the count of contributions from the sentence’s author to the thread and normalizing it by the total number of sentences. This measure represents the amount of weight a participant has in a conversation which can translate to indicating how important the contributions of specific participants are.</p><h4><strong>Discourse Tracking</strong></h4><p>To track conversation flow, we also added a feature to give more conversational context to the current sentence. The previous TF-ISF feature is the TF-ISF score of the chunk that the sentence is in reply to, giving it more information about the conversation up to the current point. If a sentence is in reply to an important chunk, it may indicate that the sentence should also be included in the summary.</p><h4><strong>Plans for Abstractive Summarization</strong></h4><p>To tackle our stretch goal of generating abstractive summaries, we would most likely take the approach of using the extracted sentences along with corresponding metadata as a starting point as we have mentioned before. More specifically, we would like to capture the authors of each sentence so we can create sentences that do a better job of describing the conversation (for example, “Person A said &lt;extracted content&gt;. Person B then replied…” and so on).</p><p>We have also thought about various strategies to generate more natural text from the extracted sentences. These include training and using a language model on the abstractive summary annotations that some of our datasets have, looking at techniques for sentence compression, and applying tense correction.</p><p>Sentence compression would help us progress beyond needing to use direct quotes from the corpus in our summary by being able to get a short and sweet version of the sentence that still retains its main meaning and purpose. This could mean, for example, reducing a sentence like “I would really like to have a delicious cup of coffee” to simply “I want coffee.”</p><p>Applying tense correction would partner with the idea of including who said what in the abstractive summary. For example, if Person A says “I want coffee” adding the author attribution would result in a sentence like “Person A said I want coffee.” To make this a more natural sentence, we can correct the first person “I” to a third person “they” — resulting in “Person A said they want coffee” which would read better in an abstractive summary.</p><h4><strong>Plans for Semantic Features</strong></h4><p>Something we have noticed about our current feature set is that it does not include any features based off of semantic properties of the sentences. Being able to determine the purpose of a sentence within a chunk or thread would be really helpful information for deciding its importance to the conversation. For example, sentences in an email can be broken down into categories like ‘Greeting,’ ‘Background / Context,’ ‘Problem,’ ‘Elaboration,’ ‘Solution,’ and ‘Sign-off.’ Some of the more obvious uses of these categories would be inferring that Greeting and Sign-off are not meaningful content in the conversation and should not be included in a summary.</p><p>To do this, we would like to look more into incorporating Rhetorical Structure Theory (RST), particularly in reference to the relations between sentences in a chunk, to identify the category of a sentence. We can also approach this feature by looking for certain cue words (perhaps words like “because,” “if,” “since,” “so”) to categorize the sentence.</p><p>Overall, we’ve had a lot of fun (and learned a lot!) working on this model, and we hope you enjoyed reading about it too!</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d4957f6e802" width="1" /></div>







<p class="date">
<a href="https://medium.com/@viterbi.or.not/advanced-model-2-part-2-d4957f6e802?source=rss-c522ef075bb3------2">by Viterbi Or Not To Be at May 23, 2018 06:58 AM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" title="Stories by Halden Lin on Medium">Halden Lin <br/> Team undef.</a></h3>


<div class="entrygroup" id="https://medium.com/p/b7c31ac45ecc">
<h4><a href="https://medium.com/@halden.lin/nlp-capstone-09-any-summary-b7c31ac45ecc?source=rss-2759d54493c0------2">NLP Capstone | 09: Any Summary</a></h4>
<div class="entry">
<div class="content">
<p><em>previous posts: </em><a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5"><em>01</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5"><em>02</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3"><em>03</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-04-first-steps-be87c31976b7"><em>04</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-05-experimenting-306dca636d3a"><em>05</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-06-uncertainty-6f773ae418d0"><em>06</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-07-formalizing-a2d837ecf66b"><em>07</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-08-human-summaries-33072535817f"><em>08</em></a></p><p>In my last post, I stated a main goal of mine was to visualization <strong>human summaries</strong>. After talking with Prof. Jeff Heer this past week, I’ve developed a more concrete goal for this segment of my project.</p><p>If we are able to develop a method for approximating human ‘attention’ between source and summary, we can use it in the following ways.</p><ol><li><strong>Evaluation tool.</strong> Current evaluation requires reading article, summary, and thinking critically to map between the two in order to determine whether or not the summary is ‘good’.</li><li><strong>Enable cross-model comparison and analysis.</strong> How do different models produce summaries for the same article? Automatic measures, such as Rouge and Meteor, are generally poor indicators of proper quality. Currently, one may read summaries and source text and attempt to qualify proper coverage of key ideas. By introducing a visualization that can be generated from <strong>any</strong> source-summary pair, we can enable more principled analysis.</li><li><strong>Enable model to human comparison and analysis.</strong> This I discussed in the previous post. What do human summaries have that our models are missing? Missing coverage? Missing entities? This visualization tool could answer these questions.</li></ol><p><strong>In general, this tool would allow researchers to gain insights about both human and machine summaries.</strong></p><p>With this in mind, I’ll go into the approaches I’ve been experimenting with in the past week.</p><h4>Hierarchical Similarity</h4><p>Last week, I attempted token-on-token similarity. The results can be seen the gif below. The weight between input and output token <em>x </em>and <em>y</em>, respectively, can be described as so:</p><p><em>a(x, y) = similarity(x, y)</em></p><p>Where similarity is calculated using a standard word embedding API (in this case, <a href="https://spacy.io/">spaCy</a>). The issue with this approach was that context is lost, and so a word will often attend to nearly the entire document with no regard to the ideas coming out of each portion (in summaries, we expect a sentence or phrase to summarize a specific part or few parts of the original document).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*-ganHe0RsisBYzaPKOuHhA.gif" />Token-on-token similarity pays no heed to context — problematic.</figure><p>In attempt to remedy this, I added a factor to each weight that represents the similarity of the tokens’ respective sentences. That is, the weight of a given <em>x, y</em> pair is determined by the similarity of the sentence of <em>x </em>and the sentence of <em>y</em>, multiplied by the similarity of the tokens themselves. To both normalize weights (over output token) and exaggerate salient pairs, I also add a soft-max transformation for each similarity score. The equation below describes this formula.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*WE0z9rPYF_Nb_X4Y." /></figure><p>The <em>theta</em> terms here are important in properly exaggerating salient pairs, and so require some tuning.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*QJFNJ0ty3NimB1nBAnTdXg.gif" />Hierarchical Similarity shows some promise, but has a few issues.</figure><p>This approach shows some promise. Context is taken into account, at least at a sentence-by-sentence level. However, there are a few shortcomings that become apparent with more abstractive summaries. In particular:</p><ul><li><strong>Context is better but far from perfect.</strong> Sometimes ideas span multiple sentences, difficult to model. Additionally, repeating words in a sentence get equal ‘attention’ even though one may make more sense from a token-by-token generation standpoint.</li></ul><p>I’ll be exploring this approach further in the next week, but I have concerns about its ability to generalize well, per issues described above.</p><h4>Hidden Markov Model</h4><p>At a high level, we can imagine ‘attention’ as the words and phrases from the source text to that one would draw from to write a portion of a summary. This makes sense: we tend to focus on specific areas of a document at a time when writing summaries. Breaking this into token-by-token time-steps, summary token is <strong>conditioned</strong> on the ‘attention’ vector for that time-step.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/151/1*6wNP-KSn13tGSSwDjmDXxw.png" />Summary tokens are conditioned on attention vectors over the source text.</figure><p>Further, we can reason that attention vectors change from time-step to time-step, dependent on the previous attention vector.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/361/1*krjZPlauErnawaKymE5LAA.png" />Attention vectors are conditioned on each other.</figure><p>This of course is an simplification — the way our minds work is likely far more complex — but it allows us to model the ‘attention’ between source and summary as a Hidden Markov Model (HMM).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/611/1*3wfXRV8pMJZQ74Ux1OGjDA.png" />Source to summary modeled as a Hidden Markov Model.</figure><p>We can then use this model to predict attention vectors at each time-step (e.g. Viterbi, Forward-Backward). This is similar to how HMMs are used to predict part-of-speech tags (where POS tags are conditioned on each other and tokens are conditioned on those tags). Emissions (the edge weight going from distribution to summary token) can be defined by token similarity, but there are still a challenges here.</p><ol><li>How to define transition probabilities?</li><li>Treat attention states as distributions or single tokens (e.g. argmax in vector)?</li></ol><p>I’ll need to consider this approach further to see if I can work out these kinks.</p><h4>POS Tags</h4><p>I’ve also been slowly improving the visualization tool itself. I’ll briefly describe my progress on this front.</p><p>Using <a href="https://www.nltk.org/">NLTK</a>, I was able to part-of-speech tag machine-generated summaries. At the top right of the visualization, users are presented a panel of the POS Tags used by the <a href="https://catalog.ldc.upenn.edu/ldc99t42">Penn Tree Bank</a>, which NLTK sources from. Non-present tags are greyed-out.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*i87AaOJBtCzk4h_G5b5z9A.gif" />Users can highlight tokens to view the corresponding tag, or mouse over tags to highlight all corresponding tokens.</figure><p>This should allow more in-depth analysis of the attention vectors produced by the machine. Eventually I’d like to work towards highlighting named entities in the source / summary to allow users to identify present / missing ideas centered on important entities.</p><h4>Upcoming Work</h4><ol><li>Continue working on visualizing source-summary alignment.</li><li>Continue improving visualization.</li></ol><p>I have lots, lots, lots to do. Until next time!</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b7c31ac45ecc" width="1" /></div>







<p class="date">
<a href="https://medium.com/@halden.lin/nlp-capstone-09-any-summary-b7c31ac45ecc?source=rss-2759d54493c0------2">by Halden Lin at May 23, 2018 06:43 AM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2" title="Stories by Belinda Zou Li on Medium">Belinda Li <br/> Team Sentimentity</a></h3>


<div class="entrygroup" id="https://medium.com/p/db16f27c255d">
<h4><a href="https://medium.com/@be.li.nda/nlp-capstone-blog-9-additions-to-advanced-model-db16f27c255d?source=rss-fad49d942bf3------2">NLP Capstone Blog #9: Additions to Advanced Model</a></h4>
<div class="entry">
<div class="content">
<p>This week, I took into account my error analysis from last week and made some modifications to my model to try and improve F1 scores.</p><h3>Modification to Architecture</h3><p>I modified the architecture of my model a little to better aggregate across mentions. Instead of taking the mean across all mentions for each entity as I had done previously, I paired up all mentions of the holder/target entity, concatenated them, and then aggregated each pair through an attentive sum.</p><p>More specifically, holder/target aggregation is computed as follows:</p><p>Let [<em>h_0, h_1, …, h_n</em>] be the encoded holder mentions and [<em>t_0, t_1, …, t_m</em>] be the encoded target mentions.</p><p>I took all pairwise combinations of the mentions and concatenated them, creating (<em>n</em> x <em>m</em>) pairs in total:</p><p>[<em>h_0, t_0</em>], [<em>h_1, t_0</em>], …, [<em>h_n, t_0</em>]</p><p>[<em>h_0, t_1</em>], [<em>h_1, t_1</em>], …, [<em>h_n, t_1</em>]</p><p>…</p><p>[<em>h_0, t_m</em>], [<em>h_1, t_m</em>], …, [<em>h_n, t_m</em>]</p><p>I then passed each concatenated pair through a linear layer to compute attention</p><p><em>α_ij = </em><strong>w</strong><em>_α </em>*<em> </em>[<em>h_i, t_j</em>]<em> + b_α</em></p><p><em>a_ij</em> = softmax(<em>α_ij</em>)</p><p>…and computed the final representation <em>x </em>of the holder/target pair through an attentive sum:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/199/1*kq036bF6zKqsTBN1OKL5uQ.png" /></figure><p>Afterwards, I append embeddings for any features <em>Φ(x)</em><strong> </strong>to <em>x</em>, and pass it through a final linear layer to compute the final scores.</p><p><em>v = </em>[<em>x</em>, <em>Φ_1(x)</em>,<em> Φ_2(x)</em>, <em>Φ_3(x)</em>, <em>Φ_4(x)</em>, <em>Φ_5(x)</em>]</p><p>scores = <strong>w</strong><em>_α </em>*<em> v + b_α</em></p><p>The aggregation mechanism is still suboptimal, however, given that I’m basically doing the equivalent of just summing up weighted copies of the encoded holder and target entities — more experimentation is necessary on this point. Moreover, I’d like to take into account the proximity of the holder and target mentions into the attention mechanism — giving more attention to entity pairs that are closer or co-occur in a sentence.</p><h3>Addition of Features</h3><p>The second thing I did this week was add features to my model in accordance with my error analysis from last week. 50-dimensional embeddings for each features are appended to the entity pair representation right before the last step of the model, where the entire vector is then passed through a linear layer to compute the final scores.</p><p>I took into account 5 features total:</p><ol><li><strong>Co-occurrence feature</strong>: a feature for the number of sentences in which the holder/target entity co-occurs</li><li><strong>Holder mention frequency feature</strong>: a feature for the number of times the holder entity is mentioned in the document</li><li><strong>Target mention frequency feature</strong>: a feature for the number of times the target entity is mentioned in the document</li><li><strong>Holder mention rank feature</strong>: a feature for the rank of the holder entity, relative to all other entities, and its number of mentions in the document</li><li><strong>Target mention rank feature</strong>: a feature for the rank of the target entity, relative to all other entities, and its number of mentions in the document</li></ol><p>As my ablation studies show, all of the features are helpful in improving the score:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/722/1*qllhecRTNgittY0GTyBQmQ.png" />Ablation studies, where I removed the one of the features each time and ran the model on the dev data.</figure><h3>Final Plan</h3><ol><li>Train separate classifiers for co-occurring and non-co-occurring entities</li><li>Experiment with aggregation functions</li><li>Encode restraints in the loss function (if time suffices)</li><li>Write the final paper and get a demo up and running</li></ol><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=db16f27c255d" width="1" /></div>







<p class="date">
<a href="https://medium.com/@be.li.nda/nlp-capstone-blog-9-additions-to-advanced-model-db16f27c255d?source=rss-fad49d942bf3------2">by Belinda Zou Li at May 23, 2018 05:53 AM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4" title="NLP Capstone Blog - Medium">Tam Dang, Karishma Mandyam <br/> Team Illimitatum</a></h3>


<div class="entrygroup" id="https://medium.com/p/ef93c2149aa2">
<h4><a href="https://medium.com/nlp-capstone-blog/advanced-model-update-from-definition-extraction-to-entity-discovery-ef93c2149aa2?source=rss----9ba3897b6688---4">Advanced Model Update: From Definition Extraction to Entity Discovery</a></h4>
<div class="entry">
<div class="content">
<p>Over the past few weeks, developing a dataset to test our model and flesh out this novel task has proven to be a difficult task in itself. Here, we discuss what worked, what didn’t work, and how the development of our dataset has influenced our perspective of the task, and ultimately, what we will now expect out of our advanced model.</p><p>To recap, we began making preliminary version of our dataset using ROUGE, cosine similarity, and skip-bigrams. In particular, given a definition-document pair, we aimed to extract sentences from the document that were most conducive to describing and re-creating the definition. From there, our model can compute latent representations of the term, sentences, and document as a whole, in order to learn how to extract these sentences we’ve chosen.</p><h3>The Heuristics that Failed</h3><p>Unfortunately, we can’t all be winners.</p><h4><strong>Cosine Similarity</strong></h4><p>We used <a href="https://spacy.io/usage/vectors-similarity">spaCy’s</a> implementation of cosine similarity using context vectors. Admittedly, cosine similarity does a great job of ruling out sentences that have nothing to do with the current definition when extracting. However, there was much too little variation in the scores that sentence-definition pairs received. Often, they would range from 0.80 to 0.94, and tended to cluster around 0.83–0.87 and 0.90 to 0.93. Not only are so many sentence-definition pairs scoring so highly, it becomes a very fine line between what we should keep and what we shouldn’t.</p><p>We attempted to be extremely strict and only keep pairs that scored 0.94; but this often led to many great pairs being ruled out. We speculate that medical language in general tends to cluster together with respect to the rest of the vocabulary in which spaCy’s word vectors were trained. We also speculate that being a bag-of-words method in defining similarity, much of the richness in context and order that makes differences and similarity obvious at a glance are washed away. Despite the method clearly being able to separate contrived sentence-definition pairs, in the landscape of our data, it fails to draw the line the way we’d like it to.</p><h4>Skip-bigrams</h4><p>This heuristic in particular was troublesome in that, many UMLS definitions were 1–2 sentences long, while others were several paragraphs. So the idea of using the number of overlapping skip-bigrams between a sentence-definition pair will severely punish shorter glosses. Because of this, longer definitions having little relevance to a sentence may likely still match to it.</p><h3>The Heursitics that Worked</h3><p>After several attempts at tuning the above heuristics, we decided to look for more. The following heuristics are how our final dataset will be constructed.</p><h4>Google’s Top 10,000 Words</h4><p>There’s currently a <a href="https://github.com/first20hours/google-10000-english">repository</a> containing the top 1000 and top 10000 words according to n-gram frequency analysis of Google’s Trillion Word Corpus. In particular we are using the <strong>no swears </strong>list.</p><p>Given the roughly 800,000 glosses that UMLS provides us, we shave this down to roughly 165,000 by removing all definitions that contain an synonym that is also contained within the Google no-swears top 10k list. This drastically reduces our search space when creating examples, and ultimately we are okay with it since common words are trivial to define.</p><h4>First 15%</h4><p>Given a definition-document pair, only attempt extraction if at least one of the aliases (synonyms) that the definition defines occurs within the first 15% of the sentences.</p><h4>Word Embeddings</h4><p>Following the first two heuristics, given definition-document pairs that make it through these filters we then extract <strong>all</strong> sentences containing <strong>any </strong>of the alias for the document.</p><p>We then calculate a similarity score between each sentence and the gold standard definition of the term. We do so by using pre-trained word vectors, namely Glove vectors, to better represent sentences. Each sentence is represented as the average of all its word vectors and similarity is defined as the Euclidean distance between the gold standard vector and the sentence vector. Given these distances, we sort them and choose the smallest 5 sentences if there are that many. We believe that through this, we are using better representations of sentences as opposed to the heuristics we tried previously. Although we did consider training our own set of word vectors (the large size of the Semantic Scholar corpus would allow us to do this), we felt that given the time constraints, Glove vectors were sufficient for now.</p><p>We then filter out the document to include only mentions of the entity that we are trying to extract (or its aliases). This approach is made possible by UMLS pairing all definitions with all of the aliases that it defines.</p><p>After choosing the sentences for each term-document pair, we then incorporate aliases when creating the final training examples. Recall that each training example includes a term, a gold standard definition, sentences within the document, and the target vector. In order to encourage the model to associate synonyms with each other, we can swap out the terms and its aliases in the target sentences, randomly inserting an alias or the term in places that another alias or term might be. This will not only give us a way to produce more training examples, it will also help the model understand the contexts of similar words, which might help it discover entities.</p><h3>Reframing the Problem to Entity Discovery</h3><p>Originally, our task was to generate definitions of entities consistent with our corpus. We then reframed the task as an extractive process.</p><p>The dataset described above however, will allow us to solve a task that could be described as a ‘superclass’ of definition extraction, which essentially aims to extract all sentences <strong>relevant</strong> to an entity as opposed to only sentences that help <strong>define </strong>it. We call it ‘Entity Discovery’, a term coined by AI2 when they originally proposed this type of task during the early stages of the capstone. Given our ranking scheme, we will still tend towards selecting sentences conducive to definitions, but we’re not quite confident enough that every sentence our heuristics will choose resemble a definition or add to one.</p><p>Rather, we now see the potential of our model (which, given this dataset, does not have to change at all!). This new dataset will allow us to train a model to learn latent representations of queries and map them to latent representations of sentences. Note that often times, chemical and medical terms have numerous aliases that take different but systematic forms. Given a reasonably trained model on such data, it should theoretically generalize to novel terms and learn what synonyms would look like and the contexts in which they would appear, ones that have not been added to KBs yet, aiding researchers and medical students to learn about ill-defined terms that have synonyms and reference that have not yet been fully documented.</p><p>We call this a ‘superclass’ of definition extraction presumably because, if we were successful at extracting all sentences pertinent to an entity, that definition extraction would simply take a subset of these sentences.</p><h3>In Conclusion</h3><p>It has taken some time and experimentation to find our footing in creating this dataset, but we’ve found it. The scripts are running, the data looks reasonable, and we are excited to finally see how our model will perform.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ef93c2149aa2" width="1" /><hr /><p><a href="https://medium.com/nlp-capstone-blog/advanced-model-update-from-definition-extraction-to-entity-discovery-ef93c2149aa2">Advanced Model Update: From Definition Extraction to Entity Discovery</a> was originally published in <a href="https://medium.com/nlp-capstone-blog">NLP Capstone Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></div>







<p class="date">
<a href="https://medium.com/nlp-capstone-blog/advanced-model-update-from-definition-extraction-to-entity-discovery-ef93c2149aa2?source=rss----9ba3897b6688---4">by Tam Dang at May 23, 2018 05:34 AM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2" title="Stories by Ryan Pham on Medium">Ryan Pham <br/> Team NeuralEmpty</a></h3>


<div class="entrygroup" id="https://medium.com/p/ff44ae10d41e">
<h4><a href="https://medium.com/@ryanp97/incorporating-more-data-ff44ae10d41e?source=rss-6378d85d3a9b------2">Incorporating more Data</a></h4>
<div class="entry">
<div class="content">
<p>Based on the results of last week’s hyper-parameter tuning, I wanted to incorporate more data to see if the issue was with the dataset or not. So this week I worked on adding the Kyoto corpus as well as Japanese WordNet (parallel corpus) definitions and examples into my dataset.</p><p>I began parsing the graphs from the Kyoto Corpus similar to how I did with the Tanaka Corpus earlier this week until Michael Goodman, the linguistics grad student I have also been working with gave me access to his preprocessed version. Michael had split up the data in many tiny chunks for each corpus such that each subdirectory was a subset of the actual data. Also the data was stored in a different format than I was expecting, but it was easily converted to the Penman format using the mrs-to-penman script mentioned in earlier blog posts.</p><p>In total, this allowed me to triple the size of my dataset from ~124,000 examples to ~325,000 examples (the result of combining Tanaka, Kyoto, and WordNet corpora from Michael). Although this is not as significant as I was hoping, it adds a lot of variety to the types of sentences and graphs that the model has been trained on up until this point.</p><p>The Tanaka Corpus is very casual in nature since it was essentially crowd-sourced by a teacher asking his students to translate sentences for him. As a result, the sentences are usually in casual speech form, some examples are from songs, some of the translations include mistakes, etc. The Kyoto Corpus, on the other hand, was created from manual translation of Wikipedia articles with the purpose of the data being used for travel brochures and similar tasks in mind. As a result, a translation pair from the Kyoto Corpus is likely to contain named entities that are not often found in the other translation pairs in the dataset, which causes errors mentioned later in this post. The Japanese WordNet examples are the definitions of words and examples of the words being used in sentences. This also seems like it may contribute to the issues mentioned later.</p><p>Something to note is that the preprocessed data I got from Michael contained a different version of the Tanaka Corpus than the one I am currently using. It seems to have been segmented differently and/or seems that it might be a non-current version since it was shipped with the Jacy grammar. So the Tanaka Corpus that came with Michael’s data accounts for ~1,000/325,000 examples which is significantly fewer parsed graphs than I was able to obtain.</p><p>In the coming week, I want to experiment with training a model with the Michael’s dataset combined with my current dataset as well as different subsets of the data (i.e. just the Kyoto Corpus or just the Japanese WordNet corpus).</p><h4>Retraining the Baseline</h4><p>After I preprocessed the data from Michael, I chose the best model from my previous attempts (though they were all pretty similar in performance), which happened to be my initial baseline, and trained it on Michael’s combined dataset. I was optimistically hoping for improved performance in terms of predicate precision and recall, but the model performed much worse.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IhuwDSj7OrdW4n_Z9bivNA.png" /></figure><p>Using the same concept as last week, I calculated the most commonly mis-predicted/overly-predicted predicates:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XGtwfRJBrQcPyptwMBth5Q.png" /></figure><p>Just like with the previous models and dataset, the model still has issues mis-predicting abstract predicates and grammar concepts like particles. Something new to the list is the named abstract predicate. This was not even in the top 20 mis-predicted predicates in any of the previous models, but it shot up to the top of the charts with this new dataset. Like I mentioned earlier, the cause for this can most likely be attributed to the Kyoto Corpus and Japanese WordNet translation pairs containing many more named entities compared to the Tanaka Corpus.</p><p>Something else that I noticed is that this new dataset resulted in many more predictions having large length differences. In the baseline model, ~2,200/12,000 translation pairs differed by 5 or more predicates. With this new dataset, ~4,400/13,000 translation pairs differed by 5 or more predicates. One possible reason for this is the Kyoto Corpus — the Kyoto Corpus has translation pairs for both titles and summaries. The length difference between these is usually quite large since summaries are just longer by nature and carry much more semantic meaning.</p><h4>Future Work</h4><p>Like I mentioned earlier, I want to continue experimenting with different subsets of the data for training the model. I mentioned last week that I wanted to try implementing parent feeding into the decoder to try and force the model to really learn the semantic meanings of the non-terminals. I didn’t have time to do that for this blog post, but it is something that is a possibility for the next blogpost and/or the final presentation. Something else that I plan to try is ELMo embeddings as suggested by Yejin. OpenNMT currently does not have ELMo embedding support, as far as I am aware, so I may switch back over to AllenNLP to explore this addition to the model.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ff44ae10d41e" width="1" /></div>







<p class="date">
<a href="https://medium.com/@ryanp97/incorporating-more-data-ff44ae10d41e?source=rss-6378d85d3a9b------2">by Ryan Pham at May 23, 2018 04:48 AM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="http://cse481n-capstone.azurewebsites.net" title="Team Watch Your Language!">Boyan Li, Dennis Orzikh, Lanhao Wu <br/> Team Watch Your Language!</a></h3>


<div class="entrygroup" id="http://cse481n-capstone.azurewebsites.net/?p=114">
<h4 lang="en-US"><a href="http://cse481n-capstone.azurewebsites.net/2018/05/22/adversarial-data-collection-pilot-reddit-comment-storage-design-advanced-attempt-ii-continue/">Adversarial Data Collection Pilot &amp; Reddit Comment Storage Design (Advanced Attempt II Continue)</a></h4>
<div class="entry">
<div class="content" lang="en-US">
<h3>Adversarial Data Collection</h3>
<h4>Motivation for adversarial Data collection</h4>
<p><span style="font-weight: 400;">As we had shown previously, our model is very fixated with certain keywords when deciding that something is hate speech. For example, consider this sentence from a support subreddit:</span></p>
<p>“My wife was raped My wife tonight was raped, she doesn’t want to go to the police.”</p>
<p><span style="font-weight: 400;">Our best model considers this to be hate with 89% certainty. In particular it thinks the use of “raped” and “wife” (as opposed to “husband”) demonstrates hate speech. We think this has a lot to do with hateful speech online being commonly sexist against women while there isn’t as much obvious sexism against men. </span></p>
<p><span style="font-weight: 400;">However, we still want it to learn more sophisticated patterns. We decided that the best way to do this would be to find examples that we know are not hateful but that use the same keywords as the sentences the model deems hateful. This would add more uncertainty to the dataset, allowing us to train a more complex model. </span></p>
<p><span style="font-weight: 400;">Since we do not have any labeled data to choose from, we had to pick some sort of unlabeled data that we know in advance is going to almost always be not hateful. For this purpose, we decided to use news article headlines. Thus, these headlines are our adversarial data. They have the keywords that our model thinks are hateful, but they are almost guaranteed to not be hateful at all. </span></p>
<p><span style="font-weight: 400;">We considered two choices for collecting news article headlines. We could either use Reddit again, or use the Bing News search API through Azure. With Reddit, we would have to filter out everything except for a whitelist of news congregation subreddits and then search through the titles of the posts there for our keywords. In this type of subreddit, it’s enforced by moderators that the title of the post be the same as the headline of the article being linked. Because of our existing data collection experience, we would not need to learn anything new to go this route. With Bing, we would have to get access to their Search API resource in Azure and then pass it our keywords and manipulate the results. We ended up going with Bing because we decided that, as a search engine, Bing would be better at deciding the most relevant headlines for our keywords and thus provide us with better data for less effort.</span></p>
<h4>Pilot pipeline</h4>
<p><span style="font-weight: 400;">First, we want to extract ngrams from reddit posts that are labeled as hate by our current best model. These ngrams would later be ranked using document frequencies, and the most frequent ngrams would be used to search for news titles through Bing Search API.</span></p>
<p><span style="font-weight: 400;">We used the model with gru seq2vec encoder, 50d glove twitter embeddings, and ELMo, trained on combined twitter dataset to make predictions on 18k collected reddit posts (removing all posts with less than 4 tokens after preprocessing). We then extracted all posts labeled “hate” by this model. A total number of 3410 posts were labeled “hate”. Then we extracted all 1-3 ngrams after removing stop words and punctuations but keeping the special character apostrophe (‘) in place because there are words like can’t, won’t, don’t, etc. The output file contains multiple lines of lists. Each list consists of all 1-3 grams of a posts classified as “hate”, and each line is for each post.</span></p>
<p><span style="font-weight: 400;">After we generated a list of ngrams for each post, we need to process it to get ngrams that our model feels really hateful. Therefore, we decided to find the most frequent ngrams that appeared in all posts that are labeled as hate.</span></p>
<p><span style="font-weight: 400;">First, we need to do some data preprocessing.</span></p>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">We turned all words into lowercase and removed all non-alphabetic characters (including numbers) except punctionations within word like “can’t”. </span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Then we split each ngram into words, for each word, we used NLTK toolkit to tag it, and lemmatized back to the stem form. </span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Lastly, we decided to remove all unigrams after previous steps, because we found unigrams less descriptive comparing to bigram or trigrams.</span></li>
</ol>
<p><span style="font-weight: 400;">Then we compute the document frequency, and come up with a list of top 100 ngrams for us to explore on search engine.</span></p>
<p><span style="font-weight: 400;">For example, our ngrams looks like [“year old”, “what’s difference”, “year ago”, “old girl”, “year old girl”, “walk bar” ….]. We are aware that words like “year old”, “year old girl” looks really similar, and we would like to combine them, however, because this requires a lot more engineering and this is a pilot, we think it would be worth doing as a future work.</span></p>
<p><span style="font-weight: 400;">Once we have the ngrams we want to use as keywords for finding headlines, we send them through Bing’s news search feature. This required some experimenting to get right because if you just give Bing the keywords it will find articles that have them in the body, or sometimes just on the same website as the article. We had to make sure to use the “intitle:” restriction for each keyword of the ngram in question. As well, we found that Bing will silently filter out keywords that it thinks are offensive. For example, if you just search for articles with “intitle: jew” it removes that keyword and does an empty news search instead, which just returns the most recent articles published. This led to us doing a second round of filtering on top of the Bing results to make sure the sentences we give to the model actually have the keywords we want to test it against. As well, because our Azure tier doesn’t include Bing search, we had to use a 7-day free trial. For future work on this project we would have to change our Azure tier to keep using Bing, or we would have to switch to using Reddit for article headlines.</span></p>
<p><span style="font-weight: 400;">In the end we took the top 100 ngrams from the hate predicted posts and got up to 20 articles for each one. This resulted in almost 900 article headlines. However, when we ran these through our model we only got 73 of them labeled hate. This was an unexpected result, because we were expecting these headlines to confuse the model. On further investigation, we realized that because of Bing’s built in silent filtering, we were much less likely to get headlines that had these potentially controversial phrases in them. This happens even with safe-search turned off. If we had known about this when we were first brainstorming, we would have probably gone with using Reddit to get headlines instead.</span></p>
<p><span style="font-weight: 400;">Here are a few of the headlines that made it through Bing’s silent filter that the model did think were hate speech:</span></p>
<ul>
<li><em>Teen scarred for life after masked thug hurled acid over her in racially-motivated attack because she dated a black guy</em></li>
<li><em>I had to brutally murder the black gay guy because he hit on me</em></li>
<li><em>Starbucks drops the Jewish group Anti-Defamation League from its racial bias training after activists criticized their support of Israel and their failure to endorse Black …</em></li>
<li><em>Neo-Nazi who beat a black man with a 2-by-4 in Charlottesville pleads guilty</em></li>
<li><em>Kansas Cops Detain Black Man Because Of Vegetation On His Windshield</em></li>
<li><em>Can a Black Person Truly Love Black People if They Date Outside the Race?</em></li>
<li><em>Community responds after woman calls police on black people barbecuing</em></li>
<li><em>University survey asking if students want to know whether ‘black people hate America’ draws ire</em></li>
<li><em>Community responds after woman calls police on black people barbecuing</em></li>
<li><em>Oakland Residents Throw “BBQing While Black” Party After White Woman Called Police on Black Men for Grilling</em></li>
<li><em>3 are arrested in the stabbing of black man that officials call a hate crime</em></li>
<li><em>WATCH: Racist campers call black man a ‘n*gger’ 30 times after he asks them to leave his street</em></li>
<li><em>Understanding why you don’t call a black man a boy</em></li>
<li><em>Woman can’t get DirecTV to cancel service</em></li>
<li><em>Why you can’t get ‘Chelsea Dagger’ out of your head</em></li>
<li><em>Madonna: I Can’t Get Taylor Swift’s Songs Out of My Head</em></li>
<li><em>Spieth can’t seem to get anything right at Sawgrass</em></li>
<li><em>‘I hate her, can’t stand the b’: Daniel Heazlewood jailed for 11 years for killing his mother</em></li>
<li><em>You Can’t Tell Kids to ‘Just Say No’ to Legal Weed</em></li>
</ul>
<p><span style="font-weight: 400;">It’s clear that these were chosen based on keyword matching. We hope that including them in the training dataset in the future could make the model better, but we might have to iterate on this process using Reddit for headlines instead if we want more and better adversarial data.</span></p>
<h4>future work</h4>
<p><span style="font-weight: 400;">As mentioned above, currently we are using the most common non-trivial ngrams in all posts that are classified as hateful. However, we talked about another interesting way: found ngrams that have greatest ratio of df in predicted hate posts to df in predicted none posts. By doing so, we would be more sure about these ngrams’ contribution to the hatefulness of the post. This is a data processing step we can do in a future iteration to increase the adversarial impact of the data, since right now it is actually mostly clear to the model that these headlines should be labeled none.</span></p>
<p><span style="font-weight: 400;">Also, from our chosen ngrams, we found a lot of words that looks really similar. For example, we may have “year old” and “year old girl” appear at the same time, we can use other techniques to get rid one of them, like stemming and lemmatization . However, it might be computational challenging because of the large amount of ngrams we have. We think this is definitely a direction to look into.</span></p>
<p><span style="font-weight: 400;">Currently we are still working with unlabeled data, so we just used everything the model predicted as hate. Once our initial set of reddit data is labeled we could use that to make better decisions about what ngrams to use, such as by leaving out ngrams from true positives and true negatives from the start, and just dealing with the examples the model gets wrong. </span></p>
<p><span style="font-weight: 400;">Finally, we would like to try out other ways to collect headlines in the future, especially if there is no way around Bing’s silent filter. Using Reddit news subreddits like described up above is a possible alternative.</span></p>
<h3>Context extraction for Reddit Comment Design</h3>
<p><span style="font-weight: 400;">Here we present a high-level idea about how to store Reddit comment objects in DBMS for future context retrieval.  This is a substantial project on its own, therefore the implementation might not happen this quarter. We hope our exploration on this subject would pave the path for future work. </span></p>
<p><span style="font-weight: 400;">Last week, we presented an interesting paper, Anyone Can Become a Troll:</span><span style="font-weight: 400;"><br />
</span><span style="font-weight: 400;">Causes of Trolling Behavior in Online Discussions by Cheng et. al. To recap, the paper concludes that Negative Mood and Negative Discussion Context are the two causes of trolling behavior online. Moreover, the paper states that when training and evaluating a logistic regression classifier, “features relating to discussion context are most informative” (Cheng et. al.). </span></p>
<p><span style="font-weight: 400;">This gives us an idea that could potentially improve our model performance on reddit comments. Since a reddit post/discussion format is very much like CNN.com’s comment section where the post takes the role of an article, and all subsequent comments either spawn directly from the post or from previous comments, we believe the context of comments would also be a very useful feature for us to use when we use reddit comment data in the future (note: we are collecting reddit posts at this moment, but the data collection pipeline could easily be ported to reddit comments). </span></p>
<p><span style="font-weight: 400;">A reddit comment JSON object looks like this in the comment dumps we get from pushshift.io: </span></p>
<pre><span style="font-weight: 400;">{
    'author': 'LysergicOracle',</span>

<span style="font-weight: 400;">    'author_flair_css_class': None,</span>

<span style="font-weight: 400;">    'author_flair_text': None,</span>

<span style="font-weight: 400;">    'body': '&lt;3',</span>

<span style="font-weight: 400;">    'can_gild': True,</span>

<span style="font-weight: 400;">    'controversiality': 0,</span>

<span style="font-weight: 400;">    'created_utc': 1512086400,</span>

<span style="font-weight: 400;">    'distinguished': None,</span>

<span style="font-weight: 400;">    'edited': False,</span>

<span style="font-weight: 400;">    'gilded': 0,</span>

<span style="font-weight: 400;">    'id': 'dql1dzn',</span>

<span style="font-weight: 400;">    'is_submitter': False,</span>

<span style="font-weight: 400;">    'link_id': 't3_7go27t',</span>

<span style="font-weight: 400;">    'parent_id': 't1_dql0d4o',</span>

<span style="font-weight: 400;">    'permalink': '/r/freefolk/comments/7go27t/jonerys_first_fight_306_ac_colorized/dql1dzn/',</span>

<span style="font-weight: 400;">    'retrieved_on': 1514212661,</span>

<span style="font-weight: 400;">    'score': 2,</span>

<span style="font-weight: 400;">    'stickied': False,</span>

<span style="font-weight: 400;">    'subreddit': 'freefolk',</span>

<span style="font-weight: 400;">    'subreddit_id': 't5_37tpy',</span>

<span style="font-weight: 400;">    'subreddit_type': 'public',</span>
<span style="font-weight: 400;">}</span></pre>
<p><span style="font-weight: 400;">Here we get a comment from subreddit freefolks and the comment’s content is ‘&lt;3’. “link_id” is the id of the post under which this comment is posted, and “parent_id” is the id of the comment or post under which this comment is posted. In the case where the current comment is a top-level comment (directly posted under the post, with no parent comment), “link_id” and “parent_id” would be the same. We can also use “created_utc” to figure out which comment was created first if they are siblings, thus knowing which comment could have had an influence on the other.  </span></p>
<p><span style="font-weight: 400;">To recreate the discussion context of a comment, we are thinking of two kinds of queries: 1) queries that find all “ancestor comments” of the current comment; 2) queries that finds all “sibling comments” that were posted at an earlier timestamp than the current comment. Then we can incorporate the level of negativity of these comments as features when learning or making predictions of the current comment.</span></p>
<p><span style="font-weight: 400;">To store these comment objects in a DBMS for fast retrieval and context construction, we did some research on which DBMS to use. There are many DBMS systems out there that support JSON datatype, but the two we mainly looked at were MongoDB and PostgreSQL. Both of them are open source projects. MongoDB supports native JSON storage and has its own set of query commands. PostgreSQL was initially designed to be a SQL database, but it has supported JSON datatype for a few years. While both were valid choices, PostgreSQL supports SQL like query language on JSON data. It also supports recursive queries, which is perfect for the purpose of context tree construction. Therefore, we decided PostgreSQL is a better choice for Reddit comment storage.</span></p>
<p><span style="font-weight: 400;">For future work, we would spin up a PostgreSQL server and write a client-side package for comment context retrieval.</span></p>
<h3>Advanced Model Attempt Update</h3>
<p><span style="font-weight: 400;">Last week, we implemented an attention LSTM model and we reported that there was a bug in pytorch. However, after doing some checking, we realized that there was a dimension error on our side.</span></p>
<p><span style="font-weight: 400;">Now we have complete statistics for our attention LSTM/GRU model:</span></p>
<p><span style="font-weight: 400;">All models are trained and evaluated on twitter Waseem dataset.</span></p>
<table>
<tbody>
<tr>
<td>50d</td>
<td>LSTM w/o ELMo</td>
<td>LSTM w/ ELMo</td>
<td>GRU w/o ELMo</td>
<td>GRU w/ ELMo</td>
</tr>
<tr>
<td>F1</td>
<td>0.7907</td>
<td>0.7879</td>
<td>0.7823</td>
<td>0.7770</td>
</tr>
<tr>
<td>Precision</td>
<td>0.7961</td>
<td>0.8018</td>
<td>0.7781</td>
<td>0.7851</td>
</tr>
<tr>
<td>Recall</td>
<td>0.7862</td>
<td>0.7784</td>
<td>0.7875</td>
<td>0.7708</td>
</tr>
<tr>
<td>Accuracy</td>
<td>0.8194</td>
<td>0.8207</td>
<td>0.8056</td>
<td>0.8091</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td>100d</td>
<td>LSTM w/o ELMo</td>
<td>LSTM w/ ELMo</td>
<td>GRU w/o ELMo</td>
<td>GRU w/ ELMo</td>
</tr>
<tr>
<td>F1</td>
<td>0.7907</td>
<td>0.7864</td>
<td>0.7913</td>
<td>0.7931</td>
</tr>
<tr>
<td>Precision</td>
<td>0.8076</td>
<td>0.7873</td>
<td>0.7931</td>
<td>0.7999</td>
</tr>
<tr>
<td>Recall</td>
<td>0.7798</td>
<td>0.7854</td>
<td>0.7895</td>
<td>0.7876</td>
</tr>
<tr>
<td>Accuracy</td>
<td>0.8242</td>
<td>0.8132</td>
<td>0.8180</td>
<td>0.8221</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td>200d</td>
<td>LSTM w/o ELMo</td>
<td>LSTM w/ ELMo</td>
<td>GRU w/o ELMo</td>
<td>GRU w/ ELMo</td>
</tr>
<tr>
<td>F1</td>
<td>0.7944</td>
<td>0.7745</td>
<td>0.7948</td>
<td>0.7725</td>
</tr>
<tr>
<td>Precision</td>
<td>0.7902</td>
<td>0.7870</td>
<td>0.7874</td>
<td>0.8001</td>
</tr>
<tr>
<td>Recall</td>
<td>0.7995</td>
<td>0.7659</td>
<td>0.8074</td>
<td>0.7580</td>
</tr>
<tr>
<td>Accuracy</td>
<td>0.8166</td>
<td>0.8091</td>
<td>0.8132</td>
<td>0.8132</td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;">From our results, we see a very consistent performance (~0.79 F1 score) when attention is used. And it seems ELMo, in this case, does not introduce any help. </span></p>
<p><span style="font-weight: 400;">The reason might be attention with ELMo need much more data in order to have a performance improvement. We will train on the combined dataset in the coming days and update our statistics.</span></p>
<h3>Work Cited</h3>
<p><a href="https://files.clr3.com/papers/2017_anyone.pdf"><span style="font-weight: 400;">Cheng, Justin et al. “Anyone Can Become a Troll: Causes of Trolling Behavior in Online Discussions.” CSCW : proceedings of the Conference on Computer-Supported Cooperative Work. Conference on Computer-Supported Cooperative Work 2017 (2017): 1217-1230.</span></a></p></div>







<p class="date">
<a href="http://cse481n-capstone.azurewebsites.net/2018/05/22/adversarial-data-collection-pilot-reddit-comment-storage-design-advanced-attempt-ii-continue/">by Team Watch Your Language! at May 23, 2018 02:11 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>May 22, 2018</h2>

<div class="channelgroup">







<h3><a href="https://nlpcapstonesemparse.blogspot.com/" title="NlpCapstone">Rajas Agashe <br/> Team Han Flying Solo</a></h3>


<div class="entrygroup" id="tag:blogger.com,1999:blog-5600014144802012716.post-7945337673285975235">
<h4><a href="https://nlpcapstonesemparse.blogspot.com/2018/05/blog-9.html">Blog 9</a></h4>
<div class="entry">
<div class="content">
<div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Decided to edit code prototypes. The motivation comes from a high baseline score which uses this </span><br /><span>approach. Namely, when generating a method, if the closest method by maximum comment Jaccard </span><br /><span>distance is picked, a bleu score of .34 is achieved, almost 15 points higher than the actual model! </span><br /><span>Though note em is 0 for this baseline since it's picking a different method.</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span><br /></span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>I’ve run some experiments with the code prototypes. None seem to be working that well but I have </span><br /><span>some ideas as to why.</span></div><b id="docs-internal-guid-4c49591c-89e4-bc06-8efe-ea78d3b9b1e1" style="font-weight: normal;"><br /></b><br /><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>Since the dataset is slightly altered the baseline is at .336 bleu and .128 em.</span></div><div dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span>The prototype model which concats encoded prototype and utterance is at .331</span><br /><span> bleu and .119 em, meaning it’s not using the prototype information and is the same </span><br /><span>as the baseline. This is evident after examining the model outputs.</span></div><div><span><br /></span></div><div><span><span style="font-size: 14.6667px; white-space: pre-wrap;">The model needs to be designed better in order to figure out what parts of the prototype to copy. This is what I'm currently figuring out.</span></span></div></div>







<p class="date">
<a href="https://nlpcapstonesemparse.blogspot.com/2018/05/blog-9.html">by nlpcapstone (noreply@blogger.com) at May 22, 2018 11:38 PM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>May 17, 2018</h2>

<div class="channelgroup">







<h3><a href="https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2" title="Stories by Viterbi Or Not To Be on Medium">Aaron Johnston, Lynsey Liu <br/> Team Viterbi Or Not To Be</a></h3>


<div class="entrygroup" id="https://medium.com/p/29b207b75065">
<h4><a href="https://medium.com/@viterbi.or.not/advanced-model-2-part-1-29b207b75065?source=rss-c522ef075bb3------2">Advanced Model #2, Part 1</a></h4>
<div class="entry">
<div class="content">
<p>This week, we started working on our second advanced model attempt! The chatlog data is fully integrated this time, though we are still working on making our model effective across all types of text conversation. In addition to finishing construction of our proposed pipeline, we’ve also upgraded almost all of the previously existing components (pre-processor, feature vectorizer, model) to make the first big steps towards completing our final advanced model.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*FIza3SY9EreLeCf1." />Pipeline for integrating different datasets with a common feature set into our model, now completed!</figure><h4><strong>Adding the Chatlog Dataset — For Real This Time!</strong></h4><p>Achieving one of our major goals for the advanced model, we have finished integrating chatlog data into our model! This involved a considerable amount more effort than we anticipated because the chat data ended up being much more noisy and varied than the email data, leading to a significant portion of our time being spent re-formatting and parsing the original data files to get it into the same input structure as the email data.</p><p>Even in our initial testing, the impact from adding chatlog data has been noticeable. There are two major benefits that we have identified for the importance of incorporating this second data source. The first, and perhaps most obvious, is that it expands the domain in which our model is able to operate — because conversation data in the modern age increasingly happens over both email and chat, it increases the helpfulness of our model to be able to produce summaries for chatlogs as well.</p><p>However, the other benefit is that the chatlog dataset has considerably more data points available than the email dataset, perhaps due to the nature of chat as a noisy, casual medium. A single email thread consists of about 80 sentences on average, and we only have 32 email threads to train with when we are using an 80% / 20% split in k-fold cross validation. That means the email data has only about 2500 sentences of training data.</p><p>By contrast, the chatlog dataset is considerably larger. Again using 80% of the data as training data, we have 1118 threads of about 1200 sentences each, meaning the chatlog data has about 1,341,600 sentences or approximately 500 times the data points that were previously available. Through the use of this added data, our goal is ultimately to improve the performance of our model on a smaller dataset, such as email, solely by virtue of the massively increased amount of training data that is available by combining different data types.</p><p>Of course, to make this arrangement work, it is necessary to use a universal feature set that can apply to any type of data. That way, the model is trained on the same set of features regardless of how the data was originally structured, and it has universal applicability for any future datasets that might be added. One of the more unique aspects of our project is this combination of different text conversation mediums and the utility of our features across all conversation types.</p><h4><strong>Text Segmentation</strong></h4><p>An interesting challenge we encountered while incorporating both email and chat data was finding analogous parts and features between the two formats. Email threads were easily separated into emails, but chatlogs being one long, unstructured flow of conversation made it more difficult to process. To help with this problem, we added preprocessing of chatlogs into Longest Contiguous Messages (LCM). To capture LCM, we concatenated subsequent messages of the same user and identified a boundary when the user changes or when a period is encountered.</p><p>The effect of this incorporation was to create email-like “chunks” of the conversation, which we were then able to use for certain document-dependent features like TF-ISF that rely on having messages segmented into individual documents.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*gW-GdW9aTe7v05OL." />A before (left) and after (right) of applying LCM on a chat excerpt, taken from Sood et. al.</figure><h4><strong>Input Structure</strong></h4><p>To improve the context our features are able to operate with, we changed the input format of our data to have one more level of granularity. In our previous iterations of the model, our input structure was a list of threads, each thread being a list of sentences. Our new input format has one more nested layer — each thread is now a list of ‘chunks’ and each chunk is a list of sentences. For emails, a chunk is naturally a single email in the thread. For chatlogs, a chunk is determined by LCM text segmentation, with each chunk consisting of the contiguous messages by a single user.</p><p>This changes the sentence position feature to mean the sentence position within a chunk rather than within the whole thread, which we believe is more relevant to the sentence’s importance. This also allows us to add a “position from end of the chunk” feature which is helpful for eliminating ending lines (like sign-offs or parting words) and other features that might depend on chunk granularity context.</p><h4><strong>Results of Cross-Training</strong></h4><p>In order to examine the efficacy of our multi-dataset training approach, we ran some experiments to look at the ROUGE scores that are produced. Our first attempt was to use the Naive Bayes model in order to try this cross-training approach, as it had generally been the most successful in prior experiments. Unfortunately, we discovered that the Naive Bayes model performed extremely poorly in many combinations — after training on the chat data and evaluating on email data, for example, it would cause the vast majority of the email summaries to be blank after determining that every single sentence sentence should be classified as not being included in the summary. However, we were able to use the Decision Tree model instead to produce promising results. We are still attempting to determine the cause of this discrepancy, although one possibility might be that the Naive Bayes model ascribed too much significance to a certain feature that is significantly different between chat and email, such as sentence length or some quirk of proper punctuation.</p><p>The following table shows our results while training using the chat and evaluating using the email data, with self-trained email data provided as a comparison. In order to determine the effect of data size on the ROUGE score, we experimented with varying sizes of chat examples:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pXyyq6x_CVDaNGxx3DpsSw.png" />Results of various cross-training configurations using email and chat data</figure><p>As can be seen from the above table, from a ROUGE score standpoint, the effect of training on more data is considerably more important than the effect of training on the same type of data as is being used for evaluation. Having 12,000 sentences upon which to train causes the model’s ROUGE scores to shoot up significantly higher than having 2,500 sentences, regardless of the type of data.</p><p>Another thing we have been experimenting with is training on both types of data before evaluating on a single type of data. In this case, it would mean training on both email and chat before evaluating on either email or chat data. The theoretical advantage of this approach would be that it maximizes the amount of available data, and if there are significant differences between the types of data, it would be sure to incorporate the type of data that the model will be evaluated on.</p><p>However, in practical use, it seems as though training on multiple data sources will not contribute significantly to the success of our model because of the fact that the chatlog dataset so completely eclipses the amount of data available in the email dataset. Therefore, from a numerical perspective, training on both types of data would add only a 0.2% increase in data from training on just the chatlog data. In addition, it stands to reason that having such a numerical disadvantage means any significant benefit from training on the same type of data that the model is being evaluated on would be negligible. We are continuing to develop this capability, but for the time being it seems like a low priority.</p><h4><strong>Topic Segmentation</strong></h4><p>In addition to segmenting by the author of contiguous chat messages, we also wanted to add a new feature for our model that incorporates the changing of topics throughout a message. The idea behind this feature is to use the changing structure of text to determine the boundaries between different topics through an existing algorithm for topic detection called TextTiling (More detail can be found in the <a href="http://www.aclweb.org/anthology/J97-1003">paper describing TextTiling</a>). We used an implementation of TextTiling found within NLTK.</p><p>While the paper we used for our baseline model mentioned using TextTiling, they only used the algorithm as a preliminary attempt to segment the chatlog into different chunks. We found that approach to be ineffective, likely because the chunks in an email thread (emails) are separated by author, while TextTiling topics cover multiple authors but cover a single topic, and therefore the two are largely incomparable. To support our concept of a universal feature set, we instead used TextTiling as a separate feature, offering context for sentences.</p><p>Currently, our models are capable of using TextTiling in order to determine the position of a sentence within a topic and incorporate the relative position within the topic as a feature. Unfortunately, we have only been able to successfully run TextTiling for tiny datasets so far due to errors that manifest for noisier data, and as a result we are not ready to report results using it.</p><h4><strong>Compression Ratio</strong></h4><p>One of the major problems we noted in the summaries our model was generating was that while they scored well in ROUGE metrics, the model seemed to place importance on too many sentences and the summaries themselves often ended up too long to be practical. Indeed, summaries for some threads would be composed of over 50% of the “actual” contents of the thread (the parts that were kept after preprocessing), making our summaries close to general reproductions of the original text.</p><p>As a solution, we experimented with using a regression model instead of a classifier, giving each sentence a score rather than a binary 1 or 0 (include in the summary or not). With a regression model, we gain the ability to control the compression ratio by changing the threshold of score we accept to include in the summary.</p><h4><strong>Results of Compression Ratio</strong></h4><p>With these updates to our model, we experimented with tuning regression the running using the new possible training and validation configurations to get the following results.</p><p>We first conducted an experiment with the threshold for our regression model to determine the optimal threshold value:</p><pre>python main.py bc3/full --type email --model regression_br --threshold &lt;t value&gt;</pre><p>For those following along at home, the above command is what we used to generate the values for the following table.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*cNtKD45MlqM822FrIv3R1w.png" />Results of experimenting with the threshold value using the regression model</figure><p>Based on the results, we chose a threshold of 0.3 to continue with. The following table compares the regression model with the Naive Bayes classifier using the full email dataset:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dixp1JhnxIxOVdM3DZ97_A.png" />Comparison between our best regression model and classifier model</figure><p>In general, the “best” regression model did not have an enormous impact on the ROUGE scores as compared to the best results from the classification models (Naive Bayes), increasing some ROUGE metrics slightly and decreasing others. However, because the regression model allows configuration of the number of sentences that are output by changing the threshold hyperparameter, it adds an additional capability to the model whereby a user can select an optimal “size” of summary.</p><p>We developed this feature in response to the problem of “reproducing” the original text in our summaries, and by human standards it seems to be a big improvement. Consider the following email thread summary, produced using our Naive Bayes classifier model:</p><pre>Chris Lilley, Brian Stell and others have been discussing the rash of irate, &amp;quot;get me off this list&amp;quot; mesages the listserv has received, lately.</pre><pre>Well, folks: YOU CAN'T UNSUBSCRIBE FROM THIS LIST!</pre><pre>I've tried for 2 months to get off this list, I've followed the rules, I've tried variations of the theme, looking for some hidden code--all to no avail.</pre><pre>So, the last resort of those who have tried everything else is to post to the list they want to be rid of.</pre><pre>PLEASE GET ME OFF THIS LIST@!%$#$/-\%</pre><pre>Well, that explains a lot!</pre><pre>I've been trying for awhile too, and I can't seem to get off.</pre><pre>Please remain calm.</pre><pre>Our automated list manager works very well.</pre><pre>Sometimes there are problems due to:</pre><pre>- you being subscribed under another name/address --</pre><pre>this was the case for the first among the two recent messages.</pre><pre>Well, after receiving a message that informed me of this, I responded with an unsubscribe e-mail with my unaliased e-mail address, and today received an automated response informing me that your software could not find my name on your list.</pre><pre>I am very calm.</pre><pre>Thanks for the helpful info, but I just received a message saying that I have been removed from the list.</pre><pre>Because I posted my difficulties to the list.</pre><pre>Sorry I had to burden you all with my problems, but as you can see, it worked.</pre><pre>Sam Berlow</pre><pre>UNSUBSCRIBE.SIGROLLY</pre><p>By contrast, here is the summary for the same email thread, but using a Bayesian Ridge regression model and incorporating a threshold of 0.55 in order to produce a much smaller summary:</p><pre>Chris Lilley, Brian Stell and others have been discussing the rash of irate, “get me off this list” mesages the listserv has received, lately.</pre><pre>I've tried for 2 months to get off this list, I've followed the rules, I've tried variations of the theme, looking for some hidden code--all to no avail.</pre><pre>Well, after receiving a message that informed me of this, I responded with an unsubscribe e-mail with my unaliased e-mail address, and today received an automated response informing me that your software could not find my name on your list.</pre><pre>Thanks for the helpful info, but I just received a message saying that I have been removed from the list.</pre><p>The difference is quite pronounced, with almost half the sentences in the former being removed when a regression model and higher threshold is used. However, from a human perspective, the second summary is nearly just as informative, and in fact there are several extraneous sentences in the first summary that are dropped. Because the ROUGE scores are roughly the same in both cases, but the second summary is somewhat better from a human viewpoint, we would consider the use of a compression ratio to be a success in improving our model.</p><h4><strong>Next Steps</strong></h4><p>So far we’ve trained on single data sources (email or chat) before evaluation since we weren’t quite able to get training on both sources at once working yet in this part 1 attempt. We aim to fix this next week and be able to train on multiple data sources and fine tune the cross-training.</p><p>We think there is a lot of potential in features based on topic segmentation, semantic meaning, and the conversation-specific aspect of the authorship of a sentence. So, we also aim to finish our implementation of TextTiling-based feature, a feature that incorporates Rhetorical Structure Theory (RST) output, and feature that includes information from tracking the contributions of different participants throughout the conversation.</p><p>After completing these improvements, we would like to take a crack at our stretch goal of generating abstractive summaries and make a demo of our summarizer on a chat interface!</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=29b207b75065" width="1" /></div>







<p class="date">
<a href="https://medium.com/@viterbi.or.not/advanced-model-2-part-1-29b207b75065?source=rss-c522ef075bb3------2">by Viterbi Or Not To Be at May 17, 2018 06:56 AM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2" title="Stories by Belinda Zou Li on Medium">Belinda Li <br/> Team Sentimentity</a></h3>


<div class="entrygroup" id="https://medium.com/p/922aee66f717">
<h4><a href="https://medium.com/@be.li.nda/nlp-capstone-blog-8-more-detailed-error-analysis-922aee66f717?source=rss-fad49d942bf3------2">NLP Capstone Blog #8: More Detailed Error Analysis</a></h4>
<div class="entry">
<div class="content">
<p>This week, I spent quite a bit of time doing error analysis and trying to figure out what was wrong with my advanced model, and more specific ways of improving it.</p><p>Here is the breakdown of how the model classified various examples on the dev data, as well as what the actual label should’ve been:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/420/1*AnX6uRWHLcySgkKcuAGpRg.png" /></figure><p>Clearly, it seems that a lot of “no sentiment” examples are being identified as “positive” or “negative.” This is congruous with my previous findings that recall had been much higher than precision for positive and negative examples, as the model was falsely predicting many no sentiment examples to be positive/negative. In fact, the recall seems to be much better than the best recalls from the <a href="https://homes.cs.washington.edu/~eunsol/papers/acl2016.pdf">Choi et al.</a>:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/514/1*FEr4Kogbpu3vSdpoiYxHdw.png" /></figure><p>However, poor precision prevents the F1 scores from surpassing the previous paper’s.</p><p>To help with this, I tried experimenting a little with adjusting the thresholds. Instead of always picking the “most probable” class as the label for the example, I set the thresholds such that even if the model was 10% sure that the example is “no sentiment,” it would classify it as such. Unfortunately, this did not seem to be extremely effective on the non-training sets, and only seemed to decrease the recall in initial epochs. Eventually, as the model kept iterating through epochs, the recall surpassed precision again and F1 scores on positive and negative were ~0.2, similar to before.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/758/1*g89-UZtyPcaME8IRVLXSdg.png" />Results on Development Set: With and without thresholds.</figure><h3>Adding Features for Number of Mentions</h3><p>Looking at the dataset, it became apparent that the entity pairs which hold polarity (are positive/negative) are the most frequently mentioned entities in the document, while nearly all of the rest of the entity pairs expressed “no sentiment.” However, the predictions the model is making so far doesn’t necessarily reflect that:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/856/1*-UEY0RulJNJHbt4fIMAP6g.png" />Average # of mentions for each label: across all 3 datasets, the apparent trend is that mention pairs labelled “no sentiment” has less mentions than those labelled “positive” or “negative”.</figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/593/1*peoDMPxJLBC7DzlDHLegCA.png" />Average # of mentions based off the predicted labels: especially on the development set, the pairs predicted “no sentiment” actually have a greater number of holder and target mentions, contrary to what should be the case.</figure><p>This suggests that adding features for the number of times the holder and target entities are mentioned may be useful.</p><h3>Is the Model Just Memorizing Entity Pairs?</h3><p>To answer this question, I looked into how the model classified the same pair of entity in multiple document. For example,the pair “China” to “US” occurred in 4 different documents. I wondered if each time the pair appeared, they were being classified the same way (“uniformly”) — i.e., was the model memorizing a label for the pairs and assigning it each time the pair came up? Given the architecture of my model, I hypothesized that this shouldn’t be the case. My error analysis results seemed to corroborate this hypothesis. My model wasn’t predicting the same pairs of entity the same way throughout each document. In fact, the actual labels were uniform more often than my predictions.</p><p>On MPQA Test Data,</p><ul><li>Total # of entity pairs: 3601</li><li># of pairs appearing multiple times (* conservative estimate): 155</li></ul><p>(* Note: This represents a conservative estimate as I used exact token matching to determine whether entity pairs appeared more than once. That is to say, entities “US” and “United States” would’ve been considered different entities, and thus “US-&gt;China” and “United States-&gt;China” would not be considered appearing multiple times.)</p><p>The table below depicts how “uniform” and non-“uniform” pairs are actually classified, vs. how they are predicted. “Uniform” refers to the pair having the same sentiment label for each document it appears in. “Non-uniform” refers to the pair having a different sentiment label for at least one document.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/485/1*IGyWKDu43Qn084XzyIprNw.png" />Note that entity pairs are actually uniform more than they are predicted to be uniform, suggesting that the model is not memorizing pairs and assigning labels accordingly.</figure><h3>Is the Model Classifying Solely Based Off of Co-occurring Sentences?</h3><p>From last time, I had added a feature to my model specifying how many sentences the entity pair co-occurred in. This led to the question of whether the model was paying too much attention to this feature and simply classifying low co-occurrence pairs as having no sentiments. However, analysis seemed to show this was not the case:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/486/1*pnr9nyTBh2171ej75G4CGA.png" /></figure><p>Had the model just been classifying pairs that did not co-occurred frequently as no sentiment, we would’ve seen predicted “0” and “2” be much higher than predicted “1”.</p><h3>Entity Pairs Per Document</h3><p>Currently, my model is not training and labeling examples by document (i.e. one document at a time). However, doing so may improve results.</p><p>For each documents, most entity pairs are labelled as “no sentiments,” with a few (the most major/important entity pairs in the document) being classified as positive or negative. However, my model’s predictions do not follow that trend.</p><p>A typical example for a single document:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/343/1*xPQjwbBDXksKuYTSHHzM-Q.png" /></figure><h3>Future Directions</h3><ol><li>Under Eunsol’s suggestion, implementing separate models for co-occurring and non-co-occurring entity pairs in documents, and integrating the two.</li><li>Implementing transitivity and other constraints within the loss function.</li><li>Adding features for # of times holder/target entities are mentioned in the document.</li><li>Training by document.</li></ol><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=922aee66f717" width="1" /></div>







<p class="date">
<a href="https://medium.com/@be.li.nda/nlp-capstone-blog-8-more-detailed-error-analysis-922aee66f717?source=rss-fad49d942bf3------2">by Belinda Zou Li at May 17, 2018 04:25 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>May 16, 2018</h2>

<div class="channelgroup">







<h3><a href="https://deeplearningturingtest.wordpress.com" title="NLP Capstone Project Updates – Ananth">Ananth Gottumukkala <br/> Team Turing Test</a></h3>


<div class="entrygroup" id="http://deeplearningturingtest.wordpress.com/?p=25">
<h4 lang="en"><a href="https://deeplearningturingtest.wordpress.com/2018/05/16/advanced-model-attempt-2-part-1/">Advanced Model Attempt 2 (Part 1)</a></h4>
<div class="entry">
<div class="content" lang="en">
<p>This week I was able to greatly improve upon the results from last week. Last week my average reward got to about -23 at best, but this week by tweaking my reward function I was able to greatly speed up convergence and bump my model up to about +70 reward on average. I made my reward function more strict about interpreting the user response correctly by giving a +6 reward for correct interpretation, -6 reward for the opposite interpretation and 0 reward for interpreting as unknown (model is unsure).</p>
<p>One way I tried to improve over last week was reducing my CNN architecture to simplify the state representation, but surprisingly this had the opposite effect of underfitting on the user responses and misinterpreting them more. In fact, I later found out that my reward function was the main reason my model didn’t converge and in the end I actually ended up increasing the number of filters in my CNN architecture.</p>
<p>At this point, my model is able to win between 3 and 4 out of 5 games on average because there is 1 out of my 31 questions for which it learned the wrong Q values, probably due to insufficient exposure to the right answer, so I’ll increase the amount of exploration the model takes until these values are straightened out and the model wins 5 out of 5 games. Then I’ll evaluate the model performance on a separate database of 100 different people. While I expect the end result to be the same (winning 100% of games), I expect the model to take longer to win on average because the order of questions it asks to eliminate people is tailored towards the training database.</p>
<p>My goals for this week are reporting more exact quantitative results of model performance in terms of games won and reward gained, both on the training database and a validation database of 100 different people. Furthermore, I’ll experiment with a slightly more complicated dialogue scenario but I probably won’t go too deep considering I only have about a week left.</p></div>







<p class="date">
<a href="https://deeplearningturingtest.wordpress.com/2018/05/16/advanced-model-attempt-2-part-1/">by ananthgo at May 16, 2018 06:55 AM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4" title="NLP Capstone Blog - Medium">Tam Dang, Karishma Mandyam <br/> Team Illimitatum</a></h3>


<div class="entrygroup" id="https://medium.com/p/ca5a7f69db85">
<h4><a href="https://medium.com/nlp-capstone-blog/advanced-model-2-ca5a7f69db85?source=rss----9ba3897b6688---4">Advanced Model # 2</a></h4>
<div class="entry">
<div class="content">
<p>As explained in our previous blog post, our current challenge is involves constructing the dataset in an efficient and effective manner. This blog post will detail the progress made in the past week in relation to data construction and the challenges we have faced. We will also briefly highlight our plan for the next week.</p><h4>Training</h4><p>We’ve attempted training on a small subset of the data in the format the model should expect, and ran into an issue with batching.</p><p>As of now, we backpropagate once per batch. But at this point, latent representations of sentences and the document have already been computed. Meaning, the RNNs have already encoded every word in the document before parameters are updated. This, in conjunction with the series of affines for each sentence will likely produce a computation graph that we won’t have enough memory to backprop on.</p><p>We’ve now switched to backpropagation once per sentence, which will hopefully lead to faster learning.</p><h4>New Heuristics</h4><p>Last week we described a method of BIO tagging sentences that involved using ROUGE. While this method might produce good tags, we found that ROUGE was incredibly slow to run. Since we run ROUGE once for every sentence in every document, we chose to develop a difference heuristic that worked like ROUGE but was much faster. This led us to experimenting with two new approaches, which are detailed below.</p><h4>Skip-bigrams</h4><p>When learning about ROUGE, we learned of a variety of ROUGE called ROUGE-SU. Here, SU stands for Skip Bigrams and Unigrams. Skip Bigrams refer to bigrams which are formed as any subsequent pair of words in the sentence. In other words, it’s every bigram possible in a sentence such that the bigram follows sentence order. For our first approach, we decided to use the same greedy algorithm described from previous blog posts, except we try to maximize the skip bigram overlap between the reference skip bigrams and the set of sentences we choose to extract. We implemented this functionality from scratch.</p><h4>Cosine Similarity</h4><p>Cosine similarity is defined as a measure of similarity between two vectors. Essentially, it is a way of determining the cosine of the angle between two sequences of text in Euclidean space. A value tending toward 1 means that the two pieces of text are more similar, while smaller values mean there is less correlation. In NLP, this metric is used as a bag-of-words comparison, combining the words of both sequences into a master set of words, and computing the cosine similarity between each sequence’s respective frequency vector whose dimensionality is equal to the size of the set. In other words, it is the cosine of the angle between their tf-idf vectors.</p><p>Currently, we’re using spaCy’s implementation of cosine similarity.</p><h4>Example Data</h4><p>When we are sufficiently strict (ex. enforcing a skip-bigram intersection of at least 10 with a cosine similarity of at least 0.94) then we can get promising matches:</p><p>PAPER: Mechanisms of NO/cGMP-Dependent Vasorelaxation TERMs: {‘omega-Nitro-L-Arginine, N’, ‘NO2Arg’, ‘N omega Nitro L Arginine’, ‘L-NNA’, ‘Nitroarginine [Chemical/Ingredient]’, ‘NG-Nitro-L-Arginine’, ‘omega-Nitroarginine’, ‘NG-nitro-L-arginine’, ‘N(omega)-Nitroarginine’, ‘NOLA’, ‘N omega-Nitro-L-Arginine’, ‘N OMEGA NITROARGININE L’, ‘omega Nitroarginine’, ‘NOARG’, ‘NG-Nitroarginine’, ‘N(G)-Nitroarginine’, ‘NG NITROARGININE L’, ‘NG Nitro L Arginine’, ‘Nitroarginine’, ‘NG Nitroarginine’}<br />TERM FOUND: True<br />100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 145/145 [00:01&lt;00:00, 103.03it/s]<br />REFERENCE: An amino acid derivative and nitric oxide synthase (NOS) inhibitor with potential antineoplastic and antiangiogenic activities. Upon administration, NG-nitro-L-arginine inhibits the enzyme nitric oxide synthase, thereby preventing the formation of nitric oxide (NO). By preventing NO generation, the vasodilatory effects of NO are abrogated leading to vasoconstriction, reduction in vascular permeability and an inhibition of angiogenesis. As blood flow to tumors is restricted, this may result in an inhibition of tumor cell proliferation. NO plays an important role in tumor blood flow and stimulation of angiogenesis, tumor progression, survival, migration and invasiveness.<br />CHOSEN: [‘NO coordinates the blood-flow distribution between arterioles and the microvasculature by regulating the diameter of small arteries.7 The importance of NO and cGMP for the regulation of vascular tone and blood pressure has been recently strengthened by the observation that mice deficient in eNOS, ANP, the ANP receptor guanylyl cyclase A, or cGKI develop hypertension.2–6,17’]<br />MAX SKIPGRAM MATCHES: 38<br />MAX COSINE SIMILARITY: 0.9430605549205237</p><p>The ‘CHOSEN’ array contains a sentence that was extracted with our heuristics. Like the reference, it mentions nitric oxide, blood flow, and regulation of vascularity. The goal is to train model on instances such as these and were able to extract sentences of such relevance.</p><p>We should also note that definitions define multiple terms (in other words, terms may have multiple synonyms). The extracted sentence ‘NO coordinates the blood-flow distribution between arterioles …’ itself contains none of the entities explicitly, and yet seems to align well and be indicative of it’s definition. Robustness in recognizing a given term and its synonyms, along with being able to extract sentences about that term without the term actually being in it is extremely desirable for us. A model that is able to recognize sentences about a particular technical term without the term being present would be an especially helpful research tool.</p><p>Unfortunately, the heuristic is not perfect and can be lead astray:<br /> “title”: “On the influence of various physicochemical properties of the CNTs based implantable devices on the fibroblasts’ reaction in vitro”<br /> },<br /> “e_gold”: “ A record of something that is being done, has been done, can be done, or is intended or requested to be done. Examples: The kinds of acts that are common in health care are (1) a clinical observation, (2) an assessment of health condition (such as problems and diagnoses), (3) healthcare goals, (4) treatment services (such as medication, surgery, physical and psychological therapy), (5) assisting, monitoring or attending, (6) training and education services to patients and their next of kin, (7) and notary services (such as advanced directives or living will), (8) editing and maintaining documents, and many others. Discussion and Rationale: Acts are the pivot of the RIM; all domain information and processes are represented primarily in Acts. Any profession or business, including healthcare, is primarily constituted of intentional and occasionally non-intentional actions, performed and recorded by responsible actors. An Act-instance is a record of such an action. Acts connect to Entities in their Roles through Participations and connect to other Acts through ActRelationships. Participations are the authors, performers and other responsible parties as well as subjects and beneficiaries (which includes tools and material used in the performance of the act, which are also subjects). The moodCode distinguishes between Acts that are meant as factual records, vs. records of intended or ordered services, and the other modalities in which act can appear. One of the Participations that all acts have (at least implicitly) is a primary author, who is responsible of the Act and who \”owns\” the act. Responsibility for the act means responsibility for what is being stated in the Act and as what it is stated. Ownership of the act is assumed in the sense of who may operationally modify the same act. Ownership and responsibility of the Act is not the same as ownership or responsibility of what the Act-object refers to in the real world. The same real world activity can be described by two people, each being the author of their Act, describing the same real world activity. Yet one can be a witness while the other can be a principal performer. The performer has responsibilities for the physical actions; the witness only has responsibility for making a true statement to the best of his or her ability. The two Act-instances may even disagree, but because each is properly attributed to its author, such disagreements can exist side by side and left to arbitration by a recipient of these Act-instances. In this sense, an Act-instance represents a \”statement\” according to Rector and Nowlan (1991) [Foundations for an electronic medical record. Methods Inf Med. 30.] Rector and Nowlan have emphasized the importance of understanding the medical record not as a collection of facts, but \”a faithful record of what clinicians have heard, seen, thought, and done.\” Rector and Nowlan go on saying that \”the other requirements for a medical record, e.g., that it be attributable and permanent, follow naturally from this view.\” Indeed the Act class is this attributable statement, and the rules of updating acts (discussed in the state-transition model, see Act.statusCode) versus generating new Act-instances are designed according to this principle of permanent attributable statements. Rector and Nolan focus on the electronic medical record as a collection of statements, while attributed statements, these are still mostly factual statements. However, the Act class goes beyond this limitation to attributed factual statements, representing what is known as \”speech-acts\” in linguistics and philosophy. The notion of speech-act includes that there is pragmatic meaning in language utterances, aside from just factual statements; and that these utterances interact with the real world to change the state of affairs, even directly cause physical activities to happen. For example, an order is a speech act that (provided it is issued adequately) will cause the ordered action to be physically performed. The speech act theory has culminated in the seminal work by Austin (1962) [How to do things with words. Oxford University Press]. An activity in the real world may progress from defined, through planned and ordered to executed, which is represented as the mood of the Act. Even though one might think of a single activity as progressing from planned to executed, this progression is reflected by multiple Act-instances, each having one and only one mood that will not change along the Act-instance life cycle. This is because the attribution and content of speech acts along this progression of an activity may be different, and it is often critical that a permanent and faithful record be maintained of this progression. The specification of orders or promises or plans must not be overwritten by the specification of what was actually done, so as to allow comparing actions with their earlier specifications. Act-instances that describe this progression of the same real world activity are linked through the ActRelationships (of the relationship category \”sequel\”). Act as statements or speech-acts are the only representation of real world facts or processes in the HL7 RIM. The truth about the real world is constructed through a combination (and arbitration) of such attributed statements only, and there is no class in the RIM whose objects represent \”objective state of affairs\” or \”real processes\” independent from attributed statements. As such, there is no distinction between an activity and its documentation. Every Act includes both to varying degrees. For example, a factual statement made about recent (but past) activities, authored (and signed) by the performer of such activities, is commonly known as a procedure report or original documentation (e.g., surgical procedure report, clinic note etc.). Conversely, a status update on an activity that is presently in progress, authored by the performer (or a close observer) is considered to capture that activity (and is later superceded by a full procedure report). However, both status update and procedure report are acts of the same kind, only distinguished by mood and state (see statusCode) and completeness of the information. “,<br /> “entity”: “act”,<br /> “extracted”: [<br /> “Since their discovery in 1952, carbon nanotubes (CNTs) have been attracting increasing attention in being applied in various areas of materials science due to their outstanding mechanical properties, high chemical and thermal stability and, in some cases, very good conductivity via an electron transfer.”,<br /> “Thus, at that time point, differences in fibroblasts’ proliferation rate may have been governed by different chemical composition of the samples and an increased amount of COOH species in the CNT_ox [28].”<br /> ],</p><p>Note that since the script selected this example, that the cosine similarity score between the extracted sentences and the reference were above 0.93. Not only is the cosine similarity too generous as a heuristic, the fact that the reference is so large means that it will almost always overlap with more than enough skip-bigrams to reach our skip-bigram threshold.</p><p>Examples like these and others are concerning, but the hope is that helpful examples like the NO example outnumber the noise that make it past our heuristics.</p><h4>Going Forward</h4><p>Our goals for the next week include fine tuning our data collection thresholds to maximize the quality of our dataset, training the model, and hopefully producing results. As we mentioned in our previous blog post, the model is ready for training, but the real challenge might be with the way we produce our dataset. In the upcoming week, we expect to experiment with new heuristics for sentence similarity and tweak the existing heuristics in order to produce the best dataset.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ca5a7f69db85" width="1" /><hr /><p><a href="https://medium.com/nlp-capstone-blog/advanced-model-2-ca5a7f69db85">Advanced Model # 2</a> was originally published in <a href="https://medium.com/nlp-capstone-blog">NLP Capstone Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></div>







<p class="date">
<a href="https://medium.com/nlp-capstone-blog/advanced-model-2-ca5a7f69db85?source=rss----9ba3897b6688---4">by Karishma Mandyam at May 16, 2018 05:39 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>May 15, 2018</h2>

<div class="channelgroup">







<h3><a href="https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2" title="Stories by Ryan Pham on Medium">Ryan Pham <br/> Team NeuralEmpty</a></h3>


<div class="entrygroup" id="https://medium.com/p/5c8a38264cae">
<h4><a href="https://medium.com/@ryanp97/error-analysis-and-the-transformer-architecture-5c8a38264cae?source=rss-6378d85d3a9b------2">Error Analysis and the Transformer Architecture</a></h4>
<div class="entry">
<div class="content">
<p>In the past week, I’ve been tuning hyper-parameters for the LSTM based models, exploring the Transformer architecture, and looking more in-depth at the predictions the model is making for error analysis.</p><h4>Swapping LSTM with Transformer</h4><p>As suggested by Nelson, I trained a model using the Transformer architecture from “<a href="https://arxiv.org/pdf/1706.03762.pdf">Attention Is All You Need</a>” (Vaswani et al.) to explore and see if different architecture would help improve the performance of the LSTM based models.</p><p>I used the same hyper-parameters that was used to achieve the results listed in the paper. Unfortunately, the model showed a significant decrease in performance compared to the LSTM models. The main cause of this was due to ill-formed graphs. Unlike the LSTM models, the transformer was unable to learn the general requirements for a well-formed graph even after training for 50 epochs.</p><p>Every graph starts with an opening paren, (, which is the only place this token will occur (other opening parentheses are always attached to edge labels). The LSTM based model was able to correctly identify that this token only occurs at the beginning of the sequence while the transformer was unable to make this connection. Another issue that the transformer ran into was predicting a set of features after an edge label without any predicate, something that the LSTM based models also did not run into.</p><p>I believe that one of the causes of these issues is the fact that the Transformer was trained using batches of tokens rather than batches of sentences. However, even after training the transformer on batches of graphs, it still experienced issues of predicting edges without a predicate. Even more unfortunately, neither model was able to increase the SMATCH score or the surface/abstract predicate scores by any significant number.</p><pre>SMATCH (F1):<br />    Transformer (Tokens) - 0.60<br />    Transformer (Graphs) - 0.63</pre><pre>Surface Predicate F1:<br />    Transformer (Tokens) - 0.52<br />    Transformer (Graphs) - 0.54</pre><pre>Abstract Predicate F1:<br />    Transformer (Tokens) - 0.71<br />    Transformer (Graphs) - 0.73</pre><h4>Error Analysis</h4><p>This week I also trained some different models with larger hidden sizes, but unfortunately still did not see much improvement (all of them had similar performances as all the previously listed and tested models).</p><p>With the baseline and other models that did not have a coverage attention mechanism, there were around 2,200~2,300 predictions that differed in length by at least 15 tokens (around 5 predicates less than the gold-label graph). We hoped that adding a coverage mechanism would alleviate this issue, but the model with coverage actually resulted in more predictions having a large length difference. After looking into the parsed graph data more carefully, there doesn’t seem to be a clear correlation between the length of the graph in English and the graph length in Japanese. Furthermore, attending to the English predicates may not be the correct thing to do since there are pieces of grammar that may not be able to be directly related to some predicate in the input.</p><p>I also calculated which predicates were commonly mis-predicted as well as ones that were not predicted when they should have been. Surprisingly There was quite a big overlap between these two sets. Below is a small subset of the predicates for the baseline model trained with features:</p><pre>Abstract Predicates:<br />    def_q<br />    udef_q<br />    pron<br />    cop_id<br />    nominalization</pre><pre>Surface Predicates:<br />    _wa_d<br />    _ni_p<br />    _no_p<br />    _koto_n_nom<br />    _sono_q</pre><p>Something interesting to note are the surface predicates. The first three listed are called particles in the Japanese grammar. The first predicate, _wa_d, serves multiple purposes. は can be used to be a topic marker as well as being used to show contrast between subjects. The second predicate, _ni_p, also has multiple purposes with more varied usage. に can be used to mark time, destination, place, etc. So it seems that the models have trouble predicting predicates which have widely varied usage. Despite having a fairly high SMATCH score, it seems that the model is not quite learning the semantic structure of the Japanese graphs.</p><p>There are a couple reasons for this. Just like I mentioned in early posts, the sequence based models is likely not the best method of performing this semantic transfer and something like a TreeLSTM is more likely to be able to accurately capture the tree structure and the semantic meaning in the tree structure.</p><p>The second reason may be because of inconsistencies in the data. The Tanaka corpus is known to have a lot of casual speech, and despite taking some precautionary steps to avoid this (by using a modified version of Jacy to account for casual speech and slang), the data may still be too noisy for the number of examples in the training set that we have. To work around this, I can look into incorporating the Tanaka corpus as mentioned in one of my earlier posts. Michael Goodman was nice enough to link me the <a href="https://github.com/goodmami/xmt/blob/master/scripts/data-preparation/kyoto-wiki.sh">script</a> he used to grab the sentence pairs from the Kyoto corpus, so this is a reasonable goal for the up-coming week. Additionally, Michael suggested looking into Japanese WordNet for additional data on top of the Kyoto Corpus.</p><h4>Plans for the Next Week</h4><p>As mentioned above, I’ll be looking into incorporating more data from both the Kyoto Corpus and WordNet. Another thing I plan to look into is parent feeding which acts as a nice middle ground between the LSTM based models I’m currently using and a TreeLSTM. The idea behind this attention mechanism is to feed the previous decoder time step from the parent node into the current decoder time step. This allows the model to make more direct connections when it comes to long range dependencies.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=5c8a38264cae" width="1" /></div>







<p class="date">
<a href="https://medium.com/@ryanp97/error-analysis-and-the-transformer-architecture-5c8a38264cae?source=rss-6378d85d3a9b------2">by Ryan Pham at May 15, 2018 06:58 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>May 10, 2018</h2>

<div class="channelgroup">







<h3><a href="https://mathstoc.wordpress.com" title="NLP Capstone – Mathematical Distractions">Kuikui Liu, Nicholas Ruhland <br/> Team INLP</a></h3>


<div class="entrygroup" id="http://mathstoc.wordpress.com/?p=335">
<h4 lang="en"><a href="https://mathstoc.wordpress.com/2018/05/10/nlp-capstone-post-7-tsl-pipeline/">NLP Capstone Post #7: TSL Pipeline</a></h4>
<div class="entry">
<div class="content" lang="en">
<p> </p>
<h2><span style="font-weight: 400;">Modeling issues</span></h2>
<p><span style="font-weight: 400;">As seen in our results last week, the RNN architecture we have been training has not been able to produce any coherent series of tokens based on the music data provided in the clean Lakh dataset. To analyze the poor results of this model, we have considered various features of the quality of the data. To simplify the issue of timing the lyric tokens, this model attempts to predict a lyric token at every timestep. Between each token we have summed all the musical data, producing a piano roll that looks approximately like the following image.</span></p>
<p><img alt="Screen Shot 2018-05-09 at 4.31.53 PM" class="  wp-image-331 aligncenter" height="303" src="https://mathstoc.files.wordpress.com/2018/05/screen-shot-2018-05-09-at-4-31-53-pm.png?w=501&amp;h=303" width="501" /></p>
<p><span style="font-weight: 400;">In the event that two lyrics occur at exactly the same time step, we end up with a gap in the notes, here highlighted in red.</span></p>
<p><img alt="Screen Shot 2018-05-09 at 4.31.53 PM" class="  wp-image-334 aligncenter" height="302" src="https://mathstoc.files.wordpress.com/2018/05/screen-shot-2018-05-09-at-4-31-53-pm1.png?w=500&amp;h=302" width="500" /></p>
<p><span style="font-weight: 400;">At first we expected this problem to occur in only a small number of cases, but it is often the result of the newline character appearing in a message simultaneously with the first lyric of the next sentence. This processing poses several problems to the task of learning the lyrical content based on the structure of the music. First, the large number of musical gaps may be confounding the model due to the large variety in lyrics that will be seen at those time steps. Additionally, we lose all information about the song timing since all regions without lyrics are compressed into a single time step. In theory, gaps in lyrics could hint to the model that the next section should start a new verse or chorus.</span></p>
<h2><span style="font-weight: 400;">The TSL Pipeline</span></h2>
<p><span style="font-weight: 400;">As suggested in the previous blogpost, we would like to be able to augment the results of the musical model with a higher quality lyrical dataset. The Kaggle lyrics dataset has shown promising results in previous blogposts at the quality of the lyric sequences it has been able to produce.</span></p>
<p><span style="font-weight: 400;">The TSL Pipeline is a combination of three models: Timing, Seed, and Lyrics. The architecture may look something like the following diagram:</span></p>
<p><img alt="Training" class="  wp-image-333 aligncenter" height="221" src="https://mathstoc.files.wordpress.com/2018/05/training.png?w=531&amp;h=221" width="531" /></p>
<p><span style="font-weight: 400;">During training, each pianoroll will be separated into data representing the timing, notes and lyrics. These get passed into respective models to learn timing and “seed” information. Additional lyrics information from the Kaggle dataset is used to train a lyrical model.</span></p>
<p><img alt="Evaluation" class="  wp-image-332 aligncenter" height="220" src="https://mathstoc.files.wordpress.com/2018/05/evaluation.png?w=538&amp;h=220" width="538" /></p>
<p><span style="font-weight: 400;">At evaluation time, the lyrics from the original pianoroll are not passed into the Seed model. Instead, the Seed model attempts to predict some seed based on the musical content, and will pass its result into the lyrics model. The combination of these lyrics and timing information constitute the complete description of our karaoke output.</span></p>
<h2><span style="font-weight: 400;">Timing Model</span></h2>
<p><span style="font-weight: 400;">In all previous posts we ignored the issue of lyrics timing in the interest of creating a reasonable lyrical model. Our current timing model is similar to our previous model attempt, but the data is generated differently. Instead of computing a pianoroll sample at each lyrical timestep, we us a constant sampling frequency of 10 timesteps per second. We then annotate each timestep with a 1 or 0 based on if a lyric was annotated at that step. The model will then attempt to predict for each step of a given pianoroll the probability there should be a lyric at that time.</span></p>
<h2><span style="font-weight: 400;">Seed Model</span></h2>
<p><span style="font-weight: 400;">The seed model will be a simplified version of the poorly performing model from before. Instead of predicting all lyrics, it will attempt to predict a small subset of the initial lyrics. This would also allow us to create a dataset with more training examples by splitting each song into smaller samples.</span></p>
<h2><span style="font-weight: 400;">Lyrics Model</span></h2>
<p><span style="font-weight: 400;">The lyrics model will be similar to the one described in the second blog post, which is a character level RNN for generating lyrics. This will take the first few words predicted by the seed model and generate the remainder of the lyrics. Since it’s trained on the large Kaggle dataset the quality seems to be much higher than what our MIDI training has produced.</span></p>
<h2>Results</h2>
<p>As of this blog post, we are still testing various hyperparameters and waiting for models to converge.  Additional results will follow once we can examine the various output.</p></div>







<p class="date">
<a href="https://mathstoc.wordpress.com/2018/05/10/nlp-capstone-post-7-tsl-pipeline/">by Nicholas Ruhland at May 10, 2018 06:56 AM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4" title="NLP Capstone Blog - Medium">Tam Dang, Karishma Mandyam <br/> Team Illimitatum</a></h3>


<div class="entrygroup" id="https://medium.com/p/2ac19f7510f9">
<h4><a href="https://medium.com/nlp-capstone-blog/advanced-model-attempt-1-continued-2ac19f7510f9?source=rss----9ba3897b6688---4">Advanced Model Attempt #1 (Continued)</a></h4>
<div class="entry">
<div class="content">
<p>This week we continued work on the advanced version of the model which incorporates the SummaRuNNer architecture from (Nallapati et al.) and adds in a character level RNN for parsing UMLS terms. The models are complete but we ran into several challenges along the way, namely constructing our final training dataset from Semantic Scholar and UMLS terms. Without the dataset, we have not been able to train our model. In this blog post, we dissect our current challenges and our plans looking forward.</p><h4>Building the Model</h4><p>The original SummaRuNNer model fit our requirements pretty well. However, we ran into several challenges when implementing the model. First, there were no existing implementations of the architecture, so we had to implement the model from scratch. Furthermore, the time we spent building the model detracted from time that we could have spent working on gathering the data. The model used by Nallapati et al. also did not condition on a particular term in the paper. Our approach requires that we somehow incorporate the term so we spent additional time figuring out a character level RNN which encodes the term and includes it in the many affine transformations described in the SummaRuNNer paper.</p><p>Moreover, we had to consider how to optimize the model when it came to large amounts of data. One of the approaches we worked on was batching, essentially evaluating many sentences at once. This allowed us to speed up training by a significant amount. Finally, we spent time integrating our model into the existing architecture. Ultimately, the model was difficult, but completed.</p><h4>Collecting the Data</h4><p>There are no current datasets that we can use to train our model. To quickly recap the requirements for the data, each training example must comprise of one document, one entity or technical term, and a target representing the ideal summary of the document. In order to build this dataset, we had to individually collect each of these aspects and combine them.</p><p>In order to gather technical terms, we used the UMLS dataset, which contains over 150,000 medical terms. Obtaining the license to download UMLS and the actual process of downloading the data through the UMLS specialized data downloader took several days. Parsing the data was fairly straightforward however.</p><p>In order to gather documents, we are using the AI2 Semantic Scholar dataset, which contains over 7 million research papers. While the downloading process for Semantic Scholar was incredibly slow, we realized that we couldn’t simply download all the documents because some of them were not medical papers. Handling Computer Science papers becomes an issue because our entities are medical terms and we do not expect a computer science paper to have any relation to medical terms.</p><p>This brings us to the process of combining Semantic Scholar documents with UMLS terms. We use a distant supervision method which essentially applies a greedy approach to extract a group of sentences from each document with the highest ROUGE score while using the UMLS definitions as reference summaries. This is precisely where we are currently struggling. Computing ROUGE takes a very long time, considering the fact that we compute ROUGE as many times as there are sentences in each document. Though we filter out document-term pairs based on whether the term appears in the document, it seems that the ROUGE metric may not yield the best target sentences for us because our reference summaries tend to be fairly short while our documents tend to be fairly long. Currently, we have all the scripts running for this data collection process but aim to develop a better heuristic to collect data.</p><h4>Next Steps</h4><p>At this point, we have not been able to test our data because we are still building the dataset. In order to speed up this process, our immediate goal will be to develop a faster and more accurate heuristic to gather target sentences from each document. We will also explore filtering out the Semantic Scholar papers to only retain medical papers, which are more likely to correlate to the terms in UMLS. Once we build our dataset, we can test our completed models, tune hyper-parameters, and potentially utilize attention mechanisms while constructing the document level representation used by SummaRuNNer.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=2ac19f7510f9" width="1" /><hr /><p><a href="https://medium.com/nlp-capstone-blog/advanced-model-attempt-1-continued-2ac19f7510f9">Advanced Model Attempt #1 (Continued)</a> was originally published in <a href="https://medium.com/nlp-capstone-blog">NLP Capstone Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></div>







<p class="date">
<a href="https://medium.com/nlp-capstone-blog/advanced-model-attempt-1-continued-2ac19f7510f9?source=rss----9ba3897b6688---4">by Karishma Mandyam at May 10, 2018 06:40 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>May 09, 2018</h2>

<div class="channelgroup">







<h3><a href="https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2" title="Stories by Viterbi Or Not To Be on Medium">Aaron Johnston, Lynsey Liu <br/> Team Viterbi Or Not To Be</a></h3>


<div class="entrygroup" id="https://medium.com/p/d7a06e892cdd">
<h4><a href="https://medium.com/@viterbi.or.not/advanced-model-1-part-2-d7a06e892cdd?source=rss-c522ef075bb3------2">Advanced Model #1, Part 2</a></h4>
<div class="entry">
<div class="content">
<p>Welcome back to Advanced Model #1 and thanks for sticking with us! This week, we’ve gotten some promising results in our first advanced model attempt and made a lot of progress with the incorporation of a second data source, although there is still work to be done toward fully integrating the chatlog data into a single model. In this post, we’ll go over what we’ve done since last week and give some numbers as well as example summaries from this model, then start laying out what we would like to achieve for Advanced Model #2.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*AsUzi76WPSKaMji6." />Our project roadmap and where we are at now, highlighted in orange</figure><h4><strong>Preprocessing</strong></h4><p>We decided to use preprocessing instead of features for some of the attributes of our data after discovering that our feature sets failed to focus solely on the conversation in some data types and instead gave false importance to format-specific patterns such as quoted text in emails. We eventually settled on the following distinction:</p><ul><li>Attributes of the data that existed at the conversation-level should be features: that is, anything universally applicable to textual conversations in general was implemented as a feature for the model</li><li>Attributes of the data at the data source-level should be preprocessed. This allowed us to share features across different data types (for example, using tf-idf across both emails and chatlogs) while minimizing the number of “dead” features (for example, simply assigning a constant value to a feature for detecting email signatures when vectorizing the chatlog data).</li></ul><p>The preprocessing we decided to do falls under the following categories:</p><p><strong>Identifying format-specific content:</strong> Quirks of the data format can sometimes present problems for our model, for example, we noticed separator lines composed of all dashes or symbols as well as email signatures (left example below) were making it into the summaries.</p><p><strong>Removing quoted email text:</strong> The email dataset contains quoted text of previous emails in the thread when there is an email reply, causing duplication of sentences in the summaries because the model seems to want to include the important sentence as much as possible. An example of a generated summary with the problem is in the right example below.</p><p>After initially parsing the data, we do this preprocessing step to identify such sentences using simple regular expression rules and remove them before computing feature vectors.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*vUpBdbFjg5Exfd-8." />An email signature (left) and quoted text (right) in generated summaries before adding preprocessing</figure><h4><strong>Adding the Chatlog Dataset — New Pipeline</strong></h4><p>One of our major goals for the advanced model was to incorporate the chatlog dataset we identified early on in the project. Of course, having the capability to automatically generate summaries for chat conversations expands the usefulness and possible applications of our model: although email threads are incredibly common in today’s world, chat communication is also experiencing an incredible rise in popularity. Furthermore, as chat communications tend toward a large number of participants and a model of very frequent responses, our analysis is that chat data summaries have the potential to be even more useful than their email counterparts.</p><p>However, our goal with incorporating the chatlog data is ultimately to combine it with the email data in order to be able to train our model on both data types at once. To do this, we saw the need to create a common list of features that can be applied to any data input, allowing the model to train on both sources of data indiscriminately. As the Sood et. al. paper suggests, training on both sets of data has the potential to improve the resulting summaries of the model for each type of data separately, although the paper in question does not specify their results beyond the notion that they were promising in a preliminary examination.</p><p>The end goal for our system is illustrated below:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*YodqfIjCDfX5xJLfNG_JFQ.png" />Pipeline for integrating different datasets with a common feature set into our model</figure><p>The blended colors represent the notion of common features, achieved through separate pre-processing and vectorizing of each data source but used in a single shared model.</p><p>To achieve this, we needed to do a major restructuring of our codebase, and it is unfortunately the case that a huge portion of our time this week was spent improving old code to make it more modular and compatible with these new requirements. What was once a single script to parse, process, vectorize, and train on a single dataset had to be broken apart into different modules for each of those tasks that could implement a common interface. In addition, with the growing number of options and tasks that had to be supported, we discovered it was necessary to entirely separate the concerns of processing text and handling configuration: to that end, we created a new, much more robust command-line interface and broke all other components into individual directories with as much code factoring as possible.</p><p>As a result of our design process and refactor, we currently have almost all of the infrastructure necessary for incorporating the chatlog data and training our model on all of the available data before evaluating on a single source. As we mentioned above, however, there were several challenges with parsing the chatlog data, namely the messy nature of the chats and the number of possible edge cases present in such a large dataset. Therefore, we are still in the process of finishing the parser component, but once it is complete we should be able to use both types of data in Advanced Model #2 and report on the impact that it makes. See our progress so far with this pipeline structure on our <a href="https://github.com/viterbi-or-not-to-be/viterbi-or-not-to-be/tree/master/conversation">GitHub repository</a>!</p><h4><strong>Results</strong></h4><p>Through the addition of the preprocessing step, we have greatly improved our ROUGE scores and become competitive with the advanced model in the Sood et. al. paper. Here are the results of our advanced models, using all of the features we have discussed so far and with the preprocessing step:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iDsZaXOhuHshbaFWXFlPvQ.png" />Results of the three advanced model types</figure><p>These results are significantly better than our baseline, and we believe our model is generally pretty good at picking up on which sentences are important to keep! To more directly see the impact of preprocessing, we compared the results of the Naive Bayes model with and without preprocessing:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BBrr-Z2ilFTbK8xi-t2SPg.png" />Comparison between our advanced model with preprocessing and without preprocessing</figure><p>The model without preprocessing does decently, but the preprocessing definitely contributes significantly to our advanced model performance. To show our progress since the baseline model, this compares the results of the Naive Bayes baseline models with those of our current Naive Bayes model:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*M_zctk4dPmVbmVHeHmRYYQ.png" />Comparison between our advanced model and our baselines</figure><p>Both ROUGE-1 and ROUGE-2 have stepped up by several percentage points, but the most significant increase is seen in the ROUGE-L improvement. Finally, our model compared with the model in the Sood et. al. paper:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Ty7sqP2swRfdf1UGw7wb_g.png" />Comparison between our advanced model and the Sood et. al. model</figure><p>As you can see, our ROUGE-L score is slightly lower but our ROUGE-1 and ROUGE-2 scores are higher! We’ve previously discussed the drawbacks of ROUGE―there is no definitively better type of ROUGE metric and ROUGE in general is not necessarily a reliable indicator of how good the generated summaries really are, so we are wary about quantifying our model’s performance in comparison to the Sood et. al. model’s performance based just on ROUGE scores. However, we haven’t been able to find any examples of the summaries generated by their model so this is all we have to go off of for now.</p><h4><strong>Example Summary and Analysis</strong></h4><p>Because ROUGE provides relatively unreliable metrics for evaluation of our model’s summaries, we have also turned to human evaluation. One of the summaries that our model was able to generate based off an input email thread, using all of the preprocessing and extra features that we have built, is reproduced below in its original condition except for display-motivated truncation:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*BMVwYccbvULdQcwp." />Comparison between human annotated reference summary (left) and summary generated by our advanced model (right)</figure><p>This summary is fairly representative of the summaries that are being generated, and compared to the results we saw from our baseline models it is clearly doing better in terms of human evaluation. The sentences highlighted in green are those that are shared between the reference annotation and our system’s generated summary — interestingly, all but one of the sentences in the reference summary were successfully captured by our system. Therefore, reading through the summary generated by our system gives a strong impression of the topics that were discussed in the thread, and seemingly gives a human reader all the information that is needed.</p><p>However, there are certainly aspects of the current summaries produced by the model that are lacking. In the summary given above, all 6 sentences that were truncated for display purposes at the ellipsis and the four additional non-green sentences displayed were not included in the reference summary. This summary comes from a thread with only 31 sentences after preprocessing, meaning that while our model successfully captured all of the sentences marked as important by a human, it did so at the cost of incorporating an enormous percentage of unnecessary extra text that serves to make the summary less of a “summary” while adding relatively little content. To address this, we will need to figure out how to reward the model for producing more concise summaries, or to incorporate a “compression factor” that allows producing a summary with the k most relevant sentences for some value of the hyperparameter k. Another issue is highlighted in red above — while we added preprocessing to remove email signatures based on a set of heuristics, to avoid deleting important content we made the preprocessor act conservatively when uncertain, and as a result some signatures like in the example above made their way into the summaries. Although other features would ideally prevent these signatures from appearing in many cases, we will need to improve our preprocessing heuristics in order to target these kinds of medium-specific text examples before moving on to incorporate additional types of data.</p><h4><strong>Next Steps</strong></h4><p>To entirely finish Advanced Model #1, we would like to complete the process of incorporating chatlog data and then transition into work on Advanced Model #2 by continuing to explore and add conversation-specific features. We also want to address the excessive lengthiness problem we found in the generated summaries by doing something to limit the number of sentences the model is allowed to select for the extractive summary.</p><p>Beyond these immediate steps, we would love to be able to take a stab at abstractive summarization! It’s a really challenging but rewarding conversation summarization problem that we will need to put some more thought into to attempt. We’ve preliminarily determined that we can make an attempt using the extractive output from our current model along with some other contextual metadata from the conversation data (for example, authors of the chosen sentences), to get a start on an abstractive summary. In general, we think this will require more modeling of entity relationships and text generation.</p><p>Overall, we’re excited with what our model has been able to do so far and optimistic about what we’ll be able to achieve with Advanced Model #2, so stay tuned!</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d7a06e892cdd" width="1" /></div>







<p class="date">
<a href="https://medium.com/@viterbi.or.not/advanced-model-1-part-2-d7a06e892cdd?source=rss-c522ef075bb3------2">by Viterbi Or Not To Be at May 09, 2018 06:33 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>May 03, 2018</h2>

<div class="channelgroup">







<h3><a href="https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4" title="NLP Capstone Blog - Medium">Tam Dang, Karishma Mandyam <br/> Team Illimitatum</a></h3>


<div class="entrygroup" id="https://medium.com/p/d01e84c5e1da">
<h4><a href="https://medium.com/nlp-capstone-blog/advanced-model-attempt-1-neural-based-definition-extraction-d01e84c5e1da?source=rss----9ba3897b6688---4">Advanced Model Attempt #1: Neural-Based Definition Extraction</a></h4>
<div class="entry">
<div class="content">
<p>We last left off on the idea of using an FSA with a restricted vocabulary; restricted in the sense that we extract sentences coupled with a neural language model to assure semantic quality while allowing a generative RNN model a reasonable amount of improvisation to produce abstractive definitions.</p><p>Here, we discuss our approach for the extractive component of this model, and consider it our first attempt at an advanced model for the task.</p><h3>Introducing Extractive Summarization</h3><p>Recall that extractive summarization is the idea of reducing text down to a subset of its sentences that still preserves its semantic integrity. In particular, we intend to build on the work of a successful nerual-based extractive summarizer and tailor it to solve our task.</p><p><a href="https://arxiv.org/abs/1611.04230">SummaRuNNer</a> is an RNN-based extractive summarization algorithm developed by Nallapati et al. that encodes documents from the word level up to and across the sentence level before making inference. Essentially, the model is a binary classifier on sentences within a document on whether it should be included in a summary. Its decisions are conditioned on</p><ul><li>Averaged-pooled word-level hidden states of the sentence</li><li>Average-pooled sentence-level hidden states of the document</li><li>An abstract representation of the summary built so far (average-pooling of the word-level pooled hidden states of sentences selected thus far)</li></ul><p>After which, there are several affine transformations conducive to selecting and filtering sentences:</p><ul><li>Content: affine on the abstract sentence representation that measures semantic richness</li><li>Salience: bilinear affine on the abstract sentence representation and the document representation to measure cohesiveness</li><li>Novelty: bilinear affine on the abstract sentence representation and the running summary representation to address redundancy</li><li>Absolute and Relative Positioning: two separate affines on the embedded index of the sentence to allow how far we are into the document to influence inference</li></ul><p>As of now, we have built from scratch our own <a href="https://github.com/NLP-Capstone-Project/machine-dictionary/blob/development-tam/machine_dictionary_rc/models/SummaRuNNer.py">unofficial implementation of this model</a> with inspiration from another <a href="https://github.com/hpzhao/SummaRuNNer">unofficial implementation</a> and is capable of summarizing documents the way we’ve formatted them. What’s left is for us to tailor this model to fit the task.</p><h3>A Slight Twist on an Established Task</h3><p>As of now, the model summarizes documents. We’d like it so that it instead zeroes in on query terms we give it given a research paper, to intelligently extract only sentences from that paper conducive to defining that term.</p><p>Our approach for augmenting SummaRuNNer to be a definition extractor involves</p><ul><li>Encoding the query term with a character-level RNN and using its concatenated hidden states as its representation</li><li>Introducing this new query-term abstract representation when constructing the document representation through a bilinear affine</li><li>Further introducing this query term by converting many of the non-bilinear affines (content, positioning, and possibly new ones for the task) to further condition inference on the query term.</li></ul><p>Essentially, the sentences we extract from the document are being conditioned on the term we’re trying to define. Encoding technical terms using a character level RNN allows similar technical terms to have similar hidden representations. For example, if we see the term “Chronic Lymphocytic Leukemia” in the training data and encounter “Chronic Myelogenous Leukemia” in the testing data, we would have more of an idea of how to approach this new term because of its character level similarities to the term we have already seen during training time. This might help us break down more complicated novel technical terms at testing time.</p><p>Experiments have yet to be conducted on the effectiveness of this approach but will be discussed later in <strong>Advanced Model Attempt #1 (cont.):</strong> another post later in this series discussing the results of the groundwork we’ve laid out here.</p><h3>Training Methods</h3><h4>Collection Training Data with UMLS and ROUGE:</h4><p>Recall that SummaRuNNer is a model that aims to extract the sentences in a document that summarize it best. It does so by training on examples that teach the model which sentences to extract from the document.</p><p>SummaRuNNeR uses a <em>distant supervision</em> method that relies on ROUGE in order to produce training examples for the model. This portion of the architecture, which we refer to as the “extractor”, extracts the sentences out of each document which maximize the ROUGE score when compared against the gold standard definition for the term in question. The extractor in a summarization context can use a greedy approach as follows:</p><ul><li>Look at each sentence in the document one at a time and consider appending it to the extracted sentences that we have already chosen.</li><li>Calculate the ROUGE score of the old extracted sentences + this new sentence in comparison to the gold standard summarization for the document.</li><li>If the ROUGE score increases from the previous ROUGE score, keep the new sentence.</li><li>Otherwise, we don’t keep the new sentence and move on.</li></ul><p>Although this method may not produce the most optimal and compact set of sentences that are relevant, this approach will be faster and is reasonable. The output of the extractor for each document is a tensor whose length is the number of sentences in the document, and is 0 if the sentence is tagged with O or 1 if the sentence is tagged with I.</p><p>To tailor this style of data collection to our task however, we optimize on ROUGE with respect to an entity’s gold-standard definition instead of a gold-standard summarization of the document. We collect entity-definition pairs through <a href="https://www.nlm.nih.gov/research/umls/">UMLS</a> and creating training examples of the form</p><ul><li>Entity (the technical term to define)</li><li>Gold-standard definition for the entity</li><li>The target sentence IO tags found via distant supervision with ROUGE on sentences of a research paper with the gold-standard definition being the reference</li><li>A Semantic Scholar research paper in which the sentences came from (provides the sentences in which to perform inference)</li></ul><p>With this data, we can train the definition extraction model discussed earlier; we train using these &lt;entity, IO-tagged sentences, publication&gt; examples to learn a tagger that can extract sentences most relevant to a term given a publication.</p><p>While this may result in an unnecessarily large number of training data points, we can also consider pruning this dataset later on if we have irrelevant entities for a particular document. For example, if we were trying to find a training example that used the entity “dental cavity” for a document that was about blood cancers, we might not want to keep this training example because there wouldn’t be much of a correlation between the two. In order to do this, we can introduce a ROUGE threshold, where we only keep the training example if the ROUGE score of the sentences extracted by the tagger are above a particular threshold. This might be an optimization for the future.</p><p>Our previous approach was unsupervised and it relied only on the semantic scholar dataset to produce definitions. Our current approach is an extension of SummaRuNNer which requires gold standard definitions for entities that we’d like to define in each paper. We chose to focus on medical terms, and one of the most complete datasets for medical terms and their definitions happens to be the UMLS dataset. This dataset contains a <em>Metathesaurus</em> which contains, amongst many other pieces of data, medical terms and their definitions. The technical terms in the dataset serve as references for ROUGE in the tagging phase above.</p><h4>In summary</h4><p>Training is fairly straightforward; loss between predicted and target sentences is computed with log loss (each sentence in a document is IO-tagged where sentences labeled with <em>I </em>are to be included in the definition). Essentially, the definition extractor, much like SummaRuNNer, is trained as a sentence tagger.</p><h4>Attention as a Stretch Goal</h4><p>The first part of our basic SummaRuNNer-based model uses a document representation to predict tags for sentences in a document. The current document representation is constructed by averaging the hidden states from words in each sentence and averaging the hidden states from each sentence in the document. However, we believe that simply averaging the sentences may not be the best approach to constructing the latent document representation. One of our stretch goals for us to optimize the model will be to attend to the most important parts of sentences in each document. We can do this using the method proposed in Hierarchical Attention Networks for Document Classification (Yang et. al 2016).</p><p>This approach introduces a word level context vector and a sentence level context vector which allow us to calculate attention coefficients on the fly for every word in each sentence and every sentence in the document. In this manner, we can take a weighted sum of the hidden states in the sentences and will hopefully produce better document representations overall. The word level and sentence level context vectors can be initialized randomly and learned throughout training.</p><h4>Conclusion</h4><p>We are very excited to have found a supervised approach to this task per the advice of AI2 researchers. It’s a straightforward approach with measurable loss and clearer metrics.</p><p>We also hope to have enough time before the capstone is over to introduce attention!</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d01e84c5e1da" width="1" /><hr /><p><a href="https://medium.com/nlp-capstone-blog/advanced-model-attempt-1-neural-based-definition-extraction-d01e84c5e1da">Advanced Model Attempt #1: Neural-Based Definition Extraction</a> was originally published in <a href="https://medium.com/nlp-capstone-blog">NLP Capstone Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></div>







<p class="date">
<a href="https://medium.com/nlp-capstone-blog/advanced-model-attempt-1-neural-based-definition-extraction-d01e84c5e1da?source=rss----9ba3897b6688---4">by Tam Dang at May 03, 2018 03:32 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>May 02, 2018</h2>

<div class="channelgroup">







<h3><a href="https://deeplearningturingtest.wordpress.com" title="NLP Capstone Project Updates – Ananth">Ananth Gottumukkala <br/> Team Turing Test</a></h3>


<div class="entrygroup" id="http://deeplearningturingtest.wordpress.com/?p=21">
<h4 lang="en"><a href="https://deeplearningturingtest.wordpress.com/2018/05/02/advanced-model-attempt-1-part-1/">Advanced Model Attempt 1 (Part 1)</a></h4>
<div class="entry">
<div class="content" lang="en">
<p>This week I created and populated my SQL database with the birth year, birth place, industry, gender, profession, and continent information corresponding to 100 random famous people spanning across all time periods. Furthermore, I created a little over 30 questions that the model can ask as well as the corresponding SQL queries for each question. During each game for the simulation, the user will randomly pick a person for the model to guess and the model picks from a list of these questions to ask. Then, the query corresponding to this question is used to extract the truth value of the question from the database (Yes, No, Unknown). This answer is used as the response to simulate a real person giving that answer through user input. Now that the code has been written to interact with the database, the model can now fully create the observation at any point, which is the input vector to the DRQN. Next, I will hardcode the sample rewards as well as the rules of the game (maximum 20 questions, rewards for winning/losing/wrong guess, terminating game, etc.). This week I will be focusing on getting the simulation to run end-to-end, use tensorflow-gpu, and do hyperparameter tuning.</p></div>







<p class="date">
<a href="https://deeplearningturingtest.wordpress.com/2018/05/02/advanced-model-attempt-1-part-1/">by ananthgo at May 02, 2018 06:38 AM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="http://cse481n-capstone.azurewebsites.net" title="Team Watch Your Language!">Boyan Li, Dennis Orzikh, Lanhao Wu <br/> Team Watch Your Language!</a></h3>


<div class="entrygroup" id="http://cse481n-capstone.azurewebsites.net/?p=64">
<h4 lang="en-US"><a href="http://cse481n-capstone.azurewebsites.net/2018/05/01/advanced-attempt-i/">Advanced Attempt I</a></h4>
<div class="entry">
<div class="content" lang="en-US">
<h3><b>Data Collection: </b></h3>
<p><span style="font-weight: 400;">We have made a lot of progress increasing our data quality since the last blog post. We have fine-tuned our filtering parameters and experimented with a few different definitions for set similarity. On top of Jaccard Index, we tried Dice Index and Cosine Similarity. We found that depending on the threshold, these different methods gave very similar results, but Dice Index seemed to provide the highest quality sentences while being more tolerant of long sentences (unlike Jaccard, which favored short sentences). Although it’s very picky, we’re certain that due to the huge amount of raw Reddit data we have we can still get a dataset big enough to train our complex neural nets.</span></p>
<p><span style="font-weight: 400;">As an example of our improvement, consider this example from the last post:</span></p>
<pre><span style="font-weight: 400;">MeanJokes Post: “Don’t be offended but Fuck you”
</span>Similar Post: “fuck Foligno”
Similar Post: “fuck narek”
Similar Post: “fuck”
Similar Post: “Fuck me?”
Similar Post: “Fuck me”
Similar Post: “fuck me”
Similar Post: “Fuck it”
Similar Post: “Fuck”
Similar Post: “Who the fuck are you?”</pre>
<p><span style="font-weight: 400;">Now our output would look like:</span></p>
<pre><span style="font-weight: 400;">MeanJokes Post: Don't be offended but Fuck you
</span>Similar Post: why the fuck does he have to talk in a screaming voice
Similar Post 171137: "Officer, I have no idea what in the fuck you're talking about.
Similar Post 92163: Or maybe you just fuck me in public for all too see.
Similar Post 18052: "you know, I'm finally happy". UGH, fuck off.
Similar Post 2567: So reddit, that's my fuck up. Any advice if any of you are in HR?
Similar Post 160778: Now I'm questining what numbers are real and what was put down to fuck with me and what's serious.
Similar Post 210956: And when i ask him about it, he cusses me out (tells me to fuck off) and i just die/break down internally.</pre>
<p><span style="font-weight: 400;">As well, since Dice is so picky and because the MeanJokes set tends to have a very particular structure to all its posts, we are also adding in some other obviously offensive posts to use for our set similarity step. We’re using a hate speech lexicon developed by Tom Davidson (linked below) to extract hateful posts from the general Reddit set. We will concatenate this with the MeanJokes set before running Set Similarity against all of the posts again, hopefully giving us a wider range of language structure for our dataset. </span></p>
<p><span style="font-weight: 400;">Our final improvement was discovering that a handful of subreddits contribute a majority of the noise in our data. This noise is mostly of two varieties: 1. Personal ads for intimate encounters and 2. Trading requests, for both physical and virtual items. A handful of these subreddits are very activate and are surprisingly a large chunk of Reddit’s posts, although none of them ever get nearly enough upvotes to be noticed by the average user. </span></p>
<p><span style="font-weight: 400;">So in order to combat having a lot of posts of this sort in our dataset:</span></p>
<p><img alt="" class="alignnone wp-image-65" height="144" src="http://cse481n-capstone.azurewebsites.net/wp-content/uploads/2018/05/Picture1-300x110.png" width="393" /></p>
<p><span style="font-weight: 400;">We have put together a blacklist of subs and filtered them out of the posts we consider for set similarity.</span></p>
<table style="height: 620px;" width="414">
<tbody>
<tr>
<td><span style="font-weight: 400;">100k posts</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Top 10 Black List</span></td>
<td></td>
<td><span style="font-weight: 400;">Top 10 White List</span></td>
<td></td>
</tr>
<tr>
<td><span style="font-weight: 400;">RocketLeagueExchange’</span></td>
<td><span style="font-weight: 400;">1860</span></td>
<td><span style="font-weight: 400;">AskReddit’</span></td>
<td><span style="font-weight: 400;">5978</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">A5XHE’</span></td>
<td><span style="font-weight: 400;">1373</span></td>
<td><span style="font-weight: 400;">Showerthoughts’</span></td>
<td><span style="font-weight: 400;">1709</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dirtykikpals’</span></td>
<td><span style="font-weight: 400;">1128</span></td>
<td><span style="font-weight: 400;">The_Donald’</span></td>
<td><span style="font-weight: 400;">850</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dirtypenpals’</span></td>
<td><span style="font-weight: 400;">870</span></td>
<td><span style="font-weight: 400;">teenagers’</span></td>
<td><span style="font-weight: 400;">720</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">DirtySnapchat’</span></td>
<td><span style="font-weight: 400;">792</span></td>
<td><span style="font-weight: 400;">GlobalOffensiveTrade’</span></td>
<td><span style="font-weight: 400;">681</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">dirtyr4r’</span></td>
<td><span style="font-weight: 400;">438</span></td>
<td><span style="font-weight: 400;">Bitcoin’</span></td>
<td><span style="font-weight: 400;">651</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">AppNana’</span></td>
<td><span style="font-weight: 400;">372</span></td>
<td><span style="font-weight: 400;">relationships’</span></td>
<td><span style="font-weight: 400;">586</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Roleplaykik’</span></td>
<td><span style="font-weight: 400;">368</span></td>
<td><span style="font-weight: 400;">FIFA’</span></td>
<td><span style="font-weight: 400;">558</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">buildapc’</span></td>
<td><span style="font-weight: 400;">364</span></td>
<td><span style="font-weight: 400;">explainlikeimfive’</span></td>
<td><span style="font-weight: 400;">500</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">AgeplayPenPals’</span></td>
<td><span style="font-weight: 400;">329</span></td>
<td><span style="font-weight: 400;">Fireteams’</span></td>
<td><span style="font-weight: 400;">469</span></td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;"><br />
Running the filter on 100k posts, we can see that most of the most common subreddits that remained are conversational in nature, while those that were removed would not make very useful sentences.</span></p>
<p> </p>
<h3><b>Advanced Model Attempt: </b></h3>
<h4><span style="font-weight: 400;">Combining Datasets: </span></h4>
<p><span style="font-weight: 400;">In our last blog post, we mentioned our concern about the small size of </span><span style="font-weight: 400;">Waseem’s twitter dataset</span><span style="font-weight: 400;">. This week, we combined that dataset with another twitter hate speech dataset made by Thomas Davidson. The Davidson dataset contains 24,802 labeled tweets. Each tweet is coded by at least 3 CrowdFlower users. Each row contains 5 columns:</span></p>
<table style="height: 336px;" width="584">
<tbody>
<tr>
<td>count</td>
<td>number of CrowdFlower users who coded each tweet (min is 3, sometimes more users coded a tweet when judgments were determined to be unreliable by CF).</td>
</tr>
<tr>
<td>hate_speech</td>
<td>number of CF users who judged the tweet to be hate speech.</td>
</tr>
<tr>
<td>offensive_language</td>
<td>number of CF users who judged the tweet to be offensive.</td>
</tr>
<tr>
<td>neither</td>
<td>number of CF users who judged the tweet to be neither offensive nor non-offensive.</td>
</tr>
<tr>
<td>class</td>
<td>class label for majority of CF users. 0 – hate speech 1 – offensive language 2 – neither</td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;">Davidson et. al. used the following definition for hate speech: language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group. According to the paper, </span><span style="font-weight: 400;">“only 5% of tweets were coded by the majority of coders”</span><span style="font-weight: 400;">. If we directly combine Waseem Data with this we might get a even more skewed class distribution (31% ‘hate’, 69% ‘none’). Therefore, we decided to change the class labels of Davidson a little bit: if all CF users unanimously coded a tweet hate_speech or offensive_language, the tweet would be labeled ‘hate’; otherwise, the tweet would be labeled ‘none’. The modified Davidson dataset has a class distribution of 76% ‘hate’ and 24% ‘none’. Then we combined these two datasets (removed duplicate tweets if there are any). The new combined dataset has 40,509 tweets and a class distribution of 59% ‘hate’ and 41% ‘none. The combined dataset is much larger than the altered Waseem dataset (~15k tweets) and the labels are more balanced. </span></p>
<p><span style="font-weight: 400;">We do have the concern whether this more these more generously labeled ‘hate’ tweets are noisy. However, because the Waseem dataset is also more generous to ‘none’ labels (as long as the tweet is neither racist or sexist), we believe they would have some counter effect on each other. After all, data noise is very unlikely to be completely removed. </span></p>
<h4><span style="font-weight: 400;">Preprocessing: </span></h4>
<p><span style="font-weight: 400;">Since the model we tried requires each sentence to have at least 4 tokens, we decided to ignore sentences with less than 4 tokens after pre-processing.</span></p>
<h4><span style="font-weight: 400;">The effectiveness of Combined Dataset:</span></h4>
<p><span style="font-weight: 400;">To illustrate the effectiveness of the combined dataset, we chose the best NN model set up from baseline II to train on Waseem dataset and combined dataset separately and evaluated the two trained models on Waseem dev data. We decided not to evaluate on test data yet because we don’t want any leaked info from test.</span></p>
<p><span style="font-weight: 400;">Set up — embedding: 50 dimensional glove twitter embeddings, encoder: 1 layer GRU</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Trained on Waseem Dataset, epoch chosen: 13</span></li>
</ul>
<table>
<tbody>
<tr>
<td></td>
<td><span style="font-weight: 400;">Waseem-Dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy </span></td>
<td><span style="font-weight: 400;">0.8235</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8022</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7876</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.7940</span></td>
</tr>
</tbody>
</table>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Trained on Combined Dataset, epoch chosen: 16</span></li>
</ul>
<table>
<tbody>
<tr>
<td></td>
<td><span style="font-weight: 400;">Waseem-Dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy </span></td>
<td><span style="font-weight: 400;">0.8152</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.7979</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7672</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.7788</span></td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;">Although the two models had the same setup, the one trained on the combined dataset got performance close to the one trained on the original Waseem dataset despite the fact that we now have really different class distributions in the two datasets. </span></p>
<h4><span style="font-weight: 400;">Retrain Some Baseline Models on Combined Dataset:</span></h4>
<p><span style="font-weight: 400;">Here we retained some baseline models with different set ups on the combined dataset and evaluated them on both Waseem dev data and combined dev data.</span></p>
<ul>
<li>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Model1 — embedding: 50 dimensional glove twitter embeddings, encoder: 1 layer GRU, epoch chosen: 16</span><br />
<table>
<tbody>
<tr>
<td></td>
<td><span style="font-weight: 400;">Combined-dev</span></td>
<td><span style="font-weight: 400;">Waseem-dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8665</span></td>
<td><span style="font-weight: 400;">0.8152</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8614</span></td>
<td><span style="font-weight: 400;">0.7979</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.8628</span></td>
<td><span style="font-weight: 400;">0.7672</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.8621</span></td>
<td><span style="color: #ff0000;">0.7788</span></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Model2 — embedding: 50 dimensional glove twitter embeddings, encoder: 1 layer LSTM, epoch chosen: 19</span><br />
<table>
<tbody>
<tr>
<td></td>
<td><span style="font-weight: 400;">Combined-dev</span></td>
<td><span style="font-weight: 400;">Waseem-dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8625</span></td>
<td><span style="font-weight: 400;">0.8091</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8577</span></td>
<td><span style="font-weight: 400;">0.7875</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.8578</span></td>
<td><span style="font-weight: 400;">0.7648</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.8578</span></td>
<td><span style="color: #ff0000;">0.7739</span></td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;"> Model3 — embedding: 50 dimensional glove twitter embeddings, encoder: 1 layer BiGRU, epoch chosen: 16</span></p></li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li style="font-weight: 400;">
<table>
<tbody>
<tr>
<td></td>
<td><span style="font-weight: 400;">Combined-dev</span></td>
<td><span style="font-weight: 400;">Waseem-dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8618</span></td>
<td><span style="font-weight: 400;">0.8104</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8567</span></td>
<td><span style="font-weight: 400;">0.7916</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.8575</span></td>
<td><span style="font-weight: 400;">0.7620</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.8571</span></td>
<td><span style="color: #ff0000;">0.7732</span></td>
</tr>
</tbody>
</table>
<p><span style="font-weight: 400;">Model4 — embedding: 100 dimensional glove twitter embeddings, encoder: 1 layer GRU, epoch chosen: 11</span></p></li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li style="font-weight: 400;">
<table>
<tbody>
<tr>
<td></td>
<td><span style="font-weight: 400;">Combined-dev</span></td>
<td><span style="font-weight: 400;">Waseem-dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.8651</span></td>
<td><span style="font-weight: 400;">0.8194</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8605</span></td>
<td><span style="font-weight: 400;">0.7971</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.8603</span></td>
<td><span style="font-weight: 400;">0.7834</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.8604</span></td>
<td><span style="color: #ff0000;">0.7894</span></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h4><span style="font-weight: 400;">Model:</span></h4>
<p><span style="font-weight: 400;">Our first Advanced model will be a CNN model.</span></p>
<h5><span style="font-weight: 400;">The intuition of choosing this model:</span></h5>
<p><span style="font-weight: 400;">CNN provides us a convenient way to extract the most important information within the given fragment of a sentence through filters and max pooling. We found it might be a worth trying model on our task.</span></p>
<p><span style="font-weight: 400;">Our model looks like:</span></p>
<p><img alt="" class="alignnone wp-image-67" height="158" src="http://cse481n-capstone.azurewebsites.net/wp-content/uploads/2018/05/Picture2-300x116.png" width="409" /></p>
<pre><span style="font-weight: 400;">Image credit:</span><span style="font-weight: 400;">Gambäck, B., &amp; Sikdar, U.K. (2017). Using Convolutional Neural Networks to Classify Hate-Speech.</span></pre>
<ul>
<li>
<ul>
<li>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">Preprocess all words and encode them using pretrained glove embeddings.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Feed result into a convolution neural network, taking 2, 3 and 4-grams into consideration. Output dimension is 28, 26 for English alphabets, 1 for digits and 1 for all other symbols. </span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Feed result into a 2-layer feed-forward neural net, with dimension (28, 2)  and dropout (0.3, 0.3)</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Softmax on the result and pick the major class</span></li>
</ol>
</li>
</ul>
</li>
</ul>
<p><span style="font-weight: 400;">With not much tuning, here’s what our best model looks like:</span></p>
<ul>
<li>
<ul>
<li>
<ul>
<li><span style="font-weight: 400;">200 dimension embedding, filters=100, trained on Waseem twitter dataset</span></li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<tbody>
<tr>
<td></td>
<td><span style="font-weight: 400;">Waseem dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.79169</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.78274</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.80086</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400;">0.82142</span></td>
</tr>
</tbody>
</table>
<ul>
<li>
<ul>
<li>
<ul>
<li><span style="font-weight: 400;">200 dimension embedding, filters=100, trained on the combined dataset</span></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><span style="color: #ff0000;">*revised, due to an imperfection in the combined dataset, there was a mistake in numbers</span></p>
<table>
<tbody>
<tr>
<td></td>
<td><span style="font-weight: 400;">combined dev</span></td>
<td><span style="font-weight: 400;">Waseem dev</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.85983</span></td>
<td><span style="color: #ff0000;">0.77451</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.86029</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.76156</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.85937</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.78791</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.86437</span></td>
<td><span style="font-weight: 400; color: #ff0000;">0.80837</span></td>
</tr>
</tbody>
</table>
<p><del><span style="font-weight: 400;">With no doubt, our combined dataset provides a huge boost on performance on original Waseem twitter dataset.</span></del></p>
<p><span style="color: #ff0000;">From the above results, it seems CNN hasn’t show an improvement on our job. We think doing more hyper parameter tuning should give us some improvement. Furthermore, we would like to incorporate Elmo to see if that will help us our not.</span></p>
<p><del><span style="font-weight: 400;">However, we do have some concern about our models: almost all of the best models we have with a large number of filters have their best epoch generally to be the first few epochs. We are a little bit concerned about that since that may be a sign of overfitting.</span></del></p>
<p><span style="color: #ff0000;">Since our result hasn’t show any improvement, we think it’s more appropriate to do error analysis once we gain some improvement.</span></p>
<p><del><span style="font-weight: 400;">Therefore, before we start to do any error analysis, we would like to do a little bit more hyperparameters since we haven’t really try different drop out rate or other output dimension values other than the one specified in the paper we referenced.</span></del></p>
<h3><span style="font-weight: 400;">Next Step:</span></h3>
<p><span style="font-weight: 400;">First, we will dig deeper on the model we have right now. We will first play with its parameters and then conduct error analysis on it.</span></p>
<p><span style="font-weight: 400;">As suggested in previous blog post feedback, we would like to try Elmo and see how much can we improve with it. Furthermore, we would like to try things like character level embedding as well as another very interesting model which combines CNN with GRU to make prediction.</span></p>
<h3><span style="font-weight: 400;">Work Cited:</span></h3>
<p><a href="https://www.semanticscholar.org/paper/Hateful-Symbols-or-Hateful-People%3F-Predictive-for-Waseem-Hovy/df704cca917666dace4e42b4d3a50f65597b8f06">Waseem, Zeerak and Dirk Hovy. “Hateful Symbols or Hateful People? Predictive Features for Hate Speech Detection on Twitter.” SRW@HLT-NAACL (2016).</a></p>
<p><a href="https://www.semanticscholar.org/paper/Automated-Hate-Speech-Detection-and-the-Problem-of-Davidson-Warmsley/6ccfff0d7a10bf7046fbfd109b301323293b67da">Davidson, Thomas J et al. “Automated Hate Speech Detection and the Problem of Offensive Language.” ICWSM (2017).</a></p>
<p><a href="https://www.semanticscholar.org/paper/Using-Convolutional-Neural-Networks-to-Classify-Gamb%C3%A4ck-Sikdar/0dca29b6a5ea2fe2b6373aba9fe0ab829c06fd78">Gambäck, Björn and Utpal Kumar Sikdar. “Using Convolutional Neural Networks to Classify Hate-Speech.” (2017).</a></p>
<p> </p></div>







<p class="date">
<a href="http://cse481n-capstone.azurewebsites.net/2018/05/01/advanced-attempt-i/">by Team Watch Your Language! at May 02, 2018 06:17 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>April 25, 2018</h2>

<div class="channelgroup">







<h3><a href="https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2" title="Stories by Viterbi Or Not To Be on Medium">Aaron Johnston, Lynsey Liu <br/> Team Viterbi Or Not To Be</a></h3>


<div class="entrygroup" id="https://medium.com/p/a21b51cdd27c">
<h4><a href="https://medium.com/@viterbi.or.not/baseline-model-2-a21b51cdd27c?source=rss-c522ef075bb3------2">Baseline Model #2</a></h4>
<div class="entry">
<div class="content">
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*M0h3Wof_sgtxGwgnT2IncQ.png" />Bassline = Baseline?</figure><p>This week, we completed the baseline portion of our project (see the roadmap below!) by finishing the implementation of our various baseline models and evaluating their performance with the goal of providing context for the rest of the project. In last week’s blog post, we described the process of replicating the findings of a related research paper using a single model, and incorporating only features that apply to text summarization in general. This week, we expanded upon that start by adding an additional simple, single-feature baseline and by evaluating our implementation using other models as well! Finally, we built upon our codebase from last week with various bugfixes and feature additions, such as implementing k-fold cross validation for more reliable metrics.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*K0NWdjTpiYezkyqh34fdow.png" />Roadmap of our project — At this point, we’ve completed the first big block, highlighted in orange!</figure><h4>Simple Baseline</h4><p>The simplest baseline we put together used only the sentence length feature, a very basic but often reliable measure of sentence importance, with a Naive Bayes model.</p><h4>More Realistic Baselines</h4><p>The more realistic and comprehensive baseline models that we implemented use the full “basic feature set” described in our <a href="https://medium.com/@viterbi.or.not/baseline-model-1-a6690114c441">last blog post</a> with Naive Bayes, Decision Tree, and Multilayer Perceptron models. The comprehensive Naive Bayes baseline is the same as the baseline model described in our previous post — the main progress on this week’s baselines is the addition of a simple feature to catch email lines that are quoted replies (a problem we found in a lot of the summaries generated by our models) as well as experimentation with the different types of models.</p><h4>Results and Evaluation</h4><p>As expected, the simple Naive Bayes baseline performed pretty poorly. The models using all of the features in the basic set all performed similarly well, with slight fluctuations in which ROUGE metric they did better in (seen in the table below). Overall, we found that our Naive Bayes model performed competitively with the other models in ROUGE-L and the best in ROUGE-1 and ROUGE-2, though most importantly, we thought the summaries generated by Naive Bayes were the most satisfactory when actually reading them.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Hv_d7fQj-ATlUEaV79Moiw.png" />Table comparing the performances of the various baseline models we implemented, the best performing in each ROUGE metric highlighted in orange</figure><p>Our best baseline model does better than the corresponding model in <a href="http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf">Summarizing Online Conversations: A Machine Learning Approach</a> in the ROUGE-1 and ROUGE-2 metrics<strong>, </strong>but does significantly worse in the ROUGE-L metric. However, it is not clear which of the ROUGE metrics is more “important” to score well in, and it is hard to do a complete comparison between our model and theirs without a sample of the summaries generated by their model (which is not provided in the paper).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sFxZT2d-C_jKMnFxTWUHuA.png" />Table comparing the performance of the our best baseline model with the corresponding model in <a href="http://web2py.iiit.ac.in/research_centres/publications/download/inproceedings.pdf.8b32440f2dc771c4.323031325f414e445f43616d6572612e706466.pdf"><strong>Summarizing Online Conversations: A Machine Learning Approach</strong></a>, the best performing in each ROUGE metric highlighted in orange</figure><p>In an effort to better understand what these automated metrics are measuring, here are descriptions of what ROUGE-L and ROUGE-N (ROUGE-1 and ROUGE-2) measure —</p><p><strong>ROUGE-L: </strong>Based on Longest Common Subsequence statistics, identifies longest co-occurring in sequence n-grams.</p><p><strong>ROUGE-1: </strong>Unigram overlap between system and reference summaries.</p><p><strong>ROUGE-2: </strong>Bigram overlap between system and reference summaries.</p><p>ROUGE-L and ROUGE-N clearly measure summary quality very differently, and rather than increase together, the metrics vary greatly and sometimes change inversely. While performing a mini ablation study with our baselines, we noticed that removing certain features increased ROUGE-L but cause large drops in both ROUGE-1 and ROUGE-2, as well as generated less satisfactory summaries (judged by us reading the generated summaries).</p><p>Because ROUGE does not necessarily reliably measure the quality of a conversation summary, human monitoring of generated summaries and error analysis are crucial to this project.</p><h4>Error Analysis</h4><p>So, although we used the ROUGE metrics for our model in order to compare it to our baseline research paper, we put an emphasis on human evaluation due to the inability of ROUGE to capture all the elements of successful summarization. Namely, although ROUGE is capable of determining whether the words and subsequences used in a summary match the human-annotated reference, it cannot capture critical aspects of the text such as its coverage of the source document’s most important points or whether it makes logical sense when read.</p><p>Upon reading through the summaries produced by our model, we discovered an interesting mix of results. Several sentences that appeared key to establishing the email thread’s topic were included in the summary by the baseline, indicating that its features for topic identification and term similarity were contributing in a positive manner. However, although it is expected that any extractive summary will produce grammatically imperfect results, there were noticeably major issues with the formation of our baseline model’s summaries.</p><p>An excerpt of one fairly representative summary produced by our model appears below, unedited except for truncation and formatting for clarity. This is a summary of an email chain concerning accessible technology from the BC3 corpus:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JGjecxwGpwd-rxwnf_t_Cw.png" />Comparison with reference summary</figure><p>As one can see, only the first two sentences (green) of this particular summary match the human-annotated summary; the rest (red) diverge and never again are the same sentences shared. This trend is seen across most of the summaries produced by our baseline model, where early sentences tend to be shared — one hypothesis is that the first email in a thread has clear significance in establishing that thread’s topic, while subsequent emails are less certain, leading to divergence between the model and human understanding.</p><p>Beyond the matching of sentences, there are certain aspects of the summary that, through a human evaluation, can be identified as clearly not belonging in the summary:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ni7uIemzWgCsW4Yvh0jlwA.png" />Email-specific formatting leads to summarization mistakes</figure><p>In this example, there are sequences of text that are directly repeated (orange). This occurs due to emails having quoted text from previous emails in their message bodies, and as the general text summarization features attribute the same likelihood of being relevant to the summary to both versions of the text based solely on content (and not, for instance, sentence position), it makes sense that both would be included. Doing so seems not to vastly impact the ROUGE score, but provides another example of the importance of human evaluation because it seems reasonable that no human would prefer to have those repetitions in a summary. Another example of the baseline model’s errors can be found in the email signature present in the summary (blue), which a human reader would clearly not find meaningful for the summary.</p><p>Both of these mistakes can be attributed to the fact that our baseline model uses general features for text summarization, and does not factor in conversation-specific features such as recognizing an email signature as being irrelevant to the topics being discussed. Once we begin work on our minimum viable product, we expect it to perform much better in this category, because we will have the chance to add these features.</p><p>Finally, the following examples show cases in which our model makes the opposite mistake from above, failing to capture portions of the original conversation that are important to the summary through human eyes. As expected, both of the common cases of failure we identified seem to stem from the fact that the missed content is formatted in a different way than normal text.</p><p>For the same conversation as above, the following shows just the URLs that were included in a human-annotated summary. Highlighted in green are the URLs which our baseline model also included in its generated summary:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*P9C4OsXf9w3KK4ishqa9Tg.png" />Almost all important URLs are not captured by the baseline model</figure><p>As one can see, the baseline model had a 10% success rate in identifying URLs from the email thread that the human annotator deemed as important. In a thread that primarily dealt with identifying resources from the internet, having these URLs in a summary would be highly desirable, so we consider this to be a major failing of the baseline model. Because URLs are much different from typical text, using general text summarization features likely led to this absence because there are no features that can ascribe importance to URLs based purely off their general format.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Wfd7cl-8KZ36YvAWXG4wHw.png" />Structured data, such as ordered lists, are not captured</figure><p>As another example, the following is a comparison between our baseline model and a human-annotated reference summary for a different conversation that includes discussion of poll results:</p><p>Although the baseline model does relatively well in identifying sentences related to the discussion of the poll results, its summary is noticeably lacking the results themselves. We hypothesize that the general text summarization features are insufficient to detect numerical data or items that are presented in a list, such as the one above, and therefore because the actual text within each poll result item is very generic the baseline model was unable to successfully select them for the summary.</p><p>Ultimately, these few examples are not enough to capture the exact failings of our baseline model, but by analyzing them in conjunction with the other summaries generated for our validation set, we were able to get an impression of the types of improvements that will be needed. In our next step of including conversation-specific features, we plan to make our top priority addressing structured data unique to emails by creating features to target email summaries, quoted text (and repeated text in general), and certain entities such as URLs or lists.</p><h4>Steps Towards an Advanced Model</h4><p>Keeping the weaknesses of our baseline in mind, our next steps towards creating a more advanced conversation summarization model (and approaching our Minimum Viable Product!) include the following:</p><p><strong>Incorporate conversation-specific features</strong></p><ul><li>We would like to explore using topic segmentation to preprocess conversation data and potentially improve model performance.</li><li>We would also like to add features that incorporate detection of<strong> structured data</strong> (URLs, Lists, Numbers), <strong>sentiment scores</strong> of sentences, and <strong>discourse markers</strong> (defining the purpose of a sentence in the text, for example, identifying a sentence as an email signature).</li></ul><p><strong>Train the models on other datasets</strong></p><ul><li>We will need preprocess the other datasets and restructure some of our code to handle input of the other datasets.</li><li>We anticipate some challenges based on the differences of the other datasets — the chatlog data will require much more preprocessing and meeting transcripts will likely have different vocabulary (i.e. no URLs, fewer abbreviations) which may impact our feature engineering process.</li></ul><p>Check back next week to see our initial work on the most exciting part — the advanced model!</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a21b51cdd27c" width="1" /></div>







<p class="date">
<a href="https://medium.com/@viterbi.or.not/baseline-model-2-a21b51cdd27c?source=rss-c522ef075bb3------2">by Viterbi Or Not To Be at April 25, 2018 06:29 AM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="https://medium.com/@hongnin1?source=rss-c450eb982161------2" title="Stories by Ning Hong on Medium">Zichun Liu, Ning Hong, Sujie Zhou <br/> Team The Bugless</a></h3>


<div class="entrygroup" id="https://medium.com/p/fd61ae20a2f1">
<h4><a href="https://medium.com/@hongnin1/image-annotation-model-improved-baseline-fd61ae20a2f1?source=rss-c450eb982161------2">Image Annotation Model Improved Baseline</a></h4>
<div class="entry">
<div class="content">
<p>Our original baseline can be found here:</p><p><a href="https://medium.com/@hongnin1/image-annotation-model-baseline-dataset-and-evaluation-framework-d1d1b2d1f34c">Image Annotation Model Baseline, Dataset and Evaluation Framework</a></p><p>There are several major improve we have done to our baseline:</p><ol><li>We added Attention to our deep learning network to improve our decoding scheme: as can be seen in the snapshot below, we decided to change LSTM (previous baseline) to GRU due to performance reasons. We discovered that because our training corpus is extremely large, it takes way to long to train our model using LSTM, hence the switch to GRU.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/838/0*mAvISRtQGogv4cQ-." />code block we added for adding attention/GRU</figure><p>2. Now that we are more familiar with TensorFlow (we have been watching tutorials online), we improved our APIs and incorporated better TensorFlow code to make our code base more organized and efficient. More specifically, we added “tf.contrib.seq2seq.GreedyEmbeddingHelper” to help feed data into the network, as well as adding “tf.contrib.seq2seq.BasicDecoder” and “tf.contrib.seq2seq.dynamic_decode” to perform dynamic unroll of RNN when doing decoding.</p><p>3. We had some bugs with our data parsing, and we have spent a large chunk of time debugging and eventually fixed the problem.</p><p>As for evaluation, we dived deep into the code base we found online for evaluation (for more detail see our previous post for baseline) and have decided to use the same evaluation method as the baseline approach because it is pretty established and work pretty well in determining whether an annotation is valid or not by using BLEU score).</p><p>4. We kept trying different attention weights and visualized the attention weight on input graphs.</p><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=fd61ae20a2f1" width="1" /></div>







<p class="date">
<a href="https://medium.com/@hongnin1/image-annotation-model-improved-baseline-fd61ae20a2f1?source=rss-c450eb982161------2">by Ning Hong at April 25, 2018 05:48 AM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="http://cse481n-capstone.azurewebsites.net" title="Team Watch Your Language!">Boyan Li, Dennis Orzikh, Lanhao Wu <br/> Team Watch Your Language!</a></h3>


<div class="entrygroup" id="http://cse481n-capstone.azurewebsites.net/?p=51">
<h4 lang="en-US"><a href="http://cse481n-capstone.azurewebsites.net/2018/04/24/more-data-collection-and-baseline/">More Data Collection and Baseline</a></h4>
<div class="entry">
<div class="content" lang="en-US">
<h3><span style="font-weight: 400;">Data Collection: </span></h3>
<p><span style="font-weight: 400;">In the last blog we discussed the challenges of trying to find general Reddit posts that were similar to the collected MeanJokes posts. Even limiting to posts with Jaccard Similarity &gt; .3 a lot of the data looked like the following:</span></p>
<pre><span style="font-weight: 400;">MeanJokes Post: “Don’t be offended but Fuck you”
    Similar Post: “fuck Foligno”
    Similar Post: “fuck narek”
    Similar Post: “fuck"
    Similar Post: “Fuck me?”
    Similar Post: “Fuck me”
    Similar Post: “fuck me”
</span>    Similar Post: “Fuck it”
    Similar Post: “Fuck”
    Similar Post: “Who the fuck are you?”</pre>
<p><span style="font-weight: 400;">These wouldn’t be very interesting examples to eventually train a model on. We also noticed that because of the nature of Jaccard Similarity and the sparsity of language in our collected Reddit posts, most of the posts that matched our MeanJokes posts would be very short, containing one or two key phrases from the MJ post. Posts made to Reddit are typically either very long or very short, so to make use of those long posts we decided to split them up by sentence and consider every sentence individually. We would also filter out sentences that are below a certain number of tokens, so that we avoid examples like the above.</span></p>
<pre><span style="font-weight: 400;">MeanJokes Post: “How is ScizorSci like Hoss McDank? They’re both faggots!”
</span>    Similar Post: “How long was he like that?”
    Similar Post: “More like CRAPitalism (this but unironically)
    Similar Post: “Volcanoes are like earth pimples”
    Similar Post: “I cried like a bitch”
    Similar Post: “She doesn’t like jewelry”
    Similar Post: “Everyone was like daaaaayum”
    Similar Post: “Don’t speak to me like that”
    Similar Post: “Don’t like the smell of this at all”
    Similar Post: “A few others I like are”
    Similar Post: “It’s like I’m on fire”</pre>
<p><span style="font-weight: 400;">These are better than the previous examples but still the similarities are very shallow. Most of the matches are just because there were one or two content phrases that matched between them. This could be expected from having a Jaccard Index cutoff as low as .3, since usually you want one that is somewhere above .7, but the language used in these posts is too sparse to be this picky and still have enough data to train a neural network. </span></p>
<p><span style="font-weight: 400;">We could possibly try similarity on word embeddings or sentence embeddings, but we liked using Jaccard Index because we actually care about the specific words used and not just the semantic meaning. </span></p>
<p><span style="font-weight: 400;">Our main issue ended up being that we assumed most posts would be conversationally structured with short-ish text, when in reality we found that posts are either really short, some collection of tags for indexing or trading, really long posts with at least a paragraph of text about some abstract subject, or requests for sexual favors. Overall this makes general reddit posts quite different from r/meanjokes, so at the surface level jaccard index won’t really do much, and furthermore general reddit posts won’t be conversational in structure the way r/meanjokes posts are. For these reasons we will have to move on to looking at comments instead, since we believe that they will be more conversational than posts. We originally wanted to use posts instead of comments since posts are contextually self-containing while comments are typically responses to multi-person conversations. However, we ended up splitting posts into independent sentences anyway, so this reasoning for avoiding comments became moot.</span></p>
<h3><b>Baseline Model:</b></h3>
<p><span style="font-weight: 400;">This week, we developed a baseline Neural Network model using allennlp. The model architecture is simple. We used pretrained </span><a href="https://nlp.stanford.edu/projects/glove/"><span style="font-weight: 400;">glove twitter word embeddings</span></a><span style="font-weight: 400;">, encode each tweet with a recurrent neural network (e.g. RNN, LSTM, GRU) sequence to vector encoder, and finally feed the vector into a feed-forward network with softmax at the end. We experimented with glove twitter word embeddings with 50 dimensions. We also tried different flavors of 1 layer recurrent neural network sequence to vector encoders, more specifically, GRU, LSTM, BiLSTM, and RNN. By the time this blog is written, we have yet performed extensive hyperparameter tuning. </span></p>
<p><span style="font-weight: 400;">Among the 4 different model setups that we tried, one of the models (Model1) got the highest accuracy, recall, and f1 score on test data, while another model (Model2) got the highest precision on test data. Below are their performances on dev and test dataset. </span></p>
<ul>
<li><span style="font-weight: 400;">Model1 — embedding: 50-dimensional glove twitter embeddings, encoder: 1 layer GRU, epoch chosen: 20</span></li>
</ul>
<table>
<tbody>
<tr>
<td></td>
<td><span style="font-weight: 400;">Dev</span></td>
<td><span style="font-weight: 400;">Test</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy </span></td>
<td><span style="font-weight: 400;">0.8245</span></td>
<td><span style="font-weight: 400;">0.8181</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.7934</span></td>
<td><span style="font-weight: 400;">0.7896</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7995</span></td>
<td><span style="font-weight: 400;">0.7947</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.7964</span></td>
<td><span style="font-weight: 400;">0.7921</span></td>
</tr>
</tbody>
</table>
<ul>
<li><span style="font-weight: 400;">Model2: — embedding: 50 dimensional glove twitter embeddings, encoder: 1 layer BiLSTM, epoch chosen: 5</span><br />
<table>
<tbody>
<tr>
<td></td>
<td><span style="font-weight: 400;">Dev</span></td>
<td><span style="font-weight: 400;">Test</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Accuracy </span></td>
<td><span style="font-weight: 400;">0.8409</span></td>
<td><span style="font-weight: 400;">0.8175</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Precision</span></td>
<td><span style="font-weight: 400;">0.8239</span></td>
<td><span style="font-weight: 400;">0.8004</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">Recall</span></td>
<td><span style="font-weight: 400;">0.7909</span></td>
<td><span style="font-weight: 400;">0.7627</span></td>
</tr>
<tr>
<td><span style="font-weight: 400;">F1</span></td>
<td><span style="font-weight: 400;">0.8070</span></td>
<td><span style="font-weight: 400;">0.7811</span></td>
</tr>
</tbody>
</table>
</li>
</ul>
<p><span style="font-weight: 400;">These two models’ setups are almost the same except for model1 uses a GRU encoder while model2 uses an BiLSTM encoder. Surprisingly, Model1 ends up having better overall performance on test data than the ones with more complex encoders like BiLSTM. </span></p>
<h4><span style="font-weight: 400;">Error Analysis:</span></h4>
<p><span style="font-weight: 400;">We will use the Model2’s errors in our error analysis:</span></p>
<p><span style="font-weight: 400;">First we will look into sentences that are hateful but our model classified as none:</span></p>
<ol>
<li style="font-weight: 400;">@RichardDawkins @AbuelitoSerge Really, Muslims understand this. They just want to be able to use the name “racism” to shut us up.</li>
<li style="font-weight: 400;">@RTUKnews An Islamist human rights group? LOL. Now there is a contradiction in terms.</li>
</ol>
<p><span style="font-weight: 400;">From the above examples, we found that our model is not good at understanding the underlying meaning of a sentence. For example, the 2rd one implies Islamist doesn’t care about human rights, which is attacking Islam people. However, since this sentence does not have any words that are very sensitive, our model considered it as OK instead of hateful.</span></p>
<p><span style="font-weight: 400;">Here are some other sentences that are not hateful but our model classified then as hateful:</span></p>
<ol>
<li style="font-weight: 400;">@Strubbestition Name one thing that is not an opinion but is still sexist. I will wait.</li>
<li style="font-weight: 400;">@Bipartisanism @AllooCharas Terrorism involves a political or religious objective to the terror.Most mass murderers have personal objectives</li>
</ol>
<p><span style="font-weight: 400;">On the other hand, we found a trend that sentences including words like “sexist”, “crime” are classified as hateful disregarding what exactly the post means. For a concrete example, the 3rd sentence from 2nd group is not saying anything hateful but our model considered it as hateful. We suspect that because “murderers” appeared in that sentence and in our training data and most other sentences with such word is hateful, our model picked up such pattern and made a wrong decision.</span></p>
<p><span style="font-weight: 400;">Why we end up have a pretty bad result? We have two possible reasons:</span></p>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">Our dataset used is really small (15k sentences in total) and dataset itself is really noisy. For example, “@dgbattaglia Saw this this morning… http://t.co/9YUwOuZugw” is somehow labeled as hateful as true label in original dataset.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Our model is not expressive enough to recognize more complicated patterns. This also has something to do with the dataset. With such a small dataset, we cannot really train a deep or more complicated model.</span></li>
</ol>
<h4><span style="font-weight: 400;">Next Steps: </span></h4>
<p><span style="font-weight: 400;">What we are seeing in training is is this general pattern. We suspect it is because the dataset we have (around 15k tweets) is too small for a neural network model. We would want to try combine another </span><a href="https://github.com/t-davidson/hate-speech-and-offensive-language"><span style="font-weight: 400;">twitter hate speech dataset (by Thomas Davidson et. al.)</span></a><span style="font-weight: 400;"> and Waseem’s twitter dataset and train different neural net models on the combined dataset. </span><span style="font-weight: 400;"><br />
</span></p>
<p><img alt="" class="alignnone wp-image-54" height="192" src="http://cse481n-capstone.azurewebsites.net/wp-content/uploads/2018/04/P3-300x138.png" width="417" /></p>
<h4><span style="font-weight: 400;">Data Sources: </span></h4>
<p><a href="https://www.semanticscholar.org/paper/Hateful-Symbols-or-Hateful-People%3F-Predictive-for-Waseem-Hovy/df704cca917666dace4e42b4d3a50f65597b8f06">Waseem, Zeerak and Dirk Hovy. “Hateful Symbols or Hateful People? Predictive Features for Hate Speech Detection on Twitter.” SRW@HLT-NAACL (2016).</a></p>
<p><a href="https://www.semanticscholar.org/paper/Automated-Hate-Speech-Detection-and-the-Problem-of-Davidson-Warmsley/6ccfff0d7a10bf7046fbfd109b301323293b67da">Davidson, Thomas J et al. “Automated Hate Speech Detection and the Problem of Offensive Language.” ICWSM (2017).</a></p></div>







<p class="date">
<a href="http://cse481n-capstone.azurewebsites.net/2018/04/24/more-data-collection-and-baseline/">by Team Watch Your Language! at April 25, 2018 05:00 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>April 12, 2018</h2>

<div class="channelgroup">







<h3><a href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" title="Stories by Halden Lin on Medium">Halden Lin <br/> Team undef.</a></h3>


<div class="entrygroup" id="https://medium.com/p/7d8e9ec1a8e3">
<h4><a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3?source=rss-2759d54493c0------2">NLP Capstone | 03: Project Proposal</a></h4>
<div class="entry">
<div class="content">
<p><em>previous posts: </em><a href="https://medium.com/@halden.lin/nlp-capstone-01-options-ee873b6885d5"><em>01</em></a><em> </em><a href="https://medium.com/@halden.lin/nlp-capstone-02-getting-started-96fb908765f5"><em>02</em></a></p><h3>Towards a Better Understanding of Neural Networks: Visualizing Attention in Sequence-to-Sequence Models</h3><h4>A brief review of attention</h4><p>The idea of ‘attention’ was first introduced to the sphere of natural language processing by Bahdanau et al. (2014) in <em>Neural machine learning by jointly to align and translate</em>. The idea is fairly straightforward: if we have an encoder-decoder model, at each decoding time-step we generate a vector of attention weights corresponding to each of the encoding units. That is to say, when generating each output token, we pay ‘attention’ to certain parts of the input sequence. Intuitively, this is much how we as humans fixate on parts of text to perform tasks such as summarization or question answering.</p><h4>Why visualization?</h4><p>In Machine Learning, neural networks have always been a sort of black box. We know they work incredibly well in certain contexts, but its often difficult to understand why they work so well. The following quote sums up the need for interpretability quite well.</p><blockquote><strong><em>“I believe the most important direction for future research is interpretability.</em></strong><em> The attention mechanism, by revealing what the network is “looking at”, shines some precious light into the black box of neural networks, helping us to debug problems like repetition and copying. To make further advances, we need greater insight into what RNNs are learning from text and how that knowledge is represented.”</em></blockquote><blockquote>- Abigail See, PhD - Stanford University, <em>‘So, is abstractive summarization solved?’</em> from <a href="http://www.abigailsee.com/2017/04/16/taming-rnns-for-better-summarization.html">Taming Recurrent Neural Networks for Better Summarization</a></blockquote><p>Visualization provides an avenue for interpretability by mapping the behavior of the complex networks to easy-to-understand visual encodings.</p><h4>A survey of related work</h4><p>Although I am not aware of any papers dedicated to the visualization of attention, examples can be readily found in both published literature and online blogposts. For each example below, I’ll point out strengths and weaknesses. Ultimately, I hope to show that there are improvements we can make that can augment the interpretability of the workings of seq2seq attentional models.</p><p><strong>Heat-maps</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/404/0*9FCWt3AO5oGxLxtg." />Bahdanau et al. (2014). An attention visualization for a seq2seq problem (in this case, translation). Whiter cells represent higher attention.</figure><p>The encoding scheme used by Bahdanau et al. (2014) themselves, heat-maps were the most common encoding of attentional data I found. While making the task of relative correlation lookup efficient, these have a couple of weaknesses.</p><ol><li>Hard to scale. With tasks involving large input or output (e.g. a hundred or more tokens) the size of the heat-map quickly gets out of hand. Scrolling greatly decreases the effectiveness of a visualization with respect to analysis tasks.</li><li>Difficult to read. We generally don’t read in a token-per-line format. Furthermore, source text is rarely in a token-per-line format — we lose insightful information that could be drawn from analyzing the original structure of the text.</li></ol><p><strong>Flow-maps</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*I3cdFcqDAcdKEwuCpAPHTA.png" />Rikters et al (2017). The input sequence is seen on top — output on bottom. Thicker lines denote higher attention.</figure><p>Less common, but interesting nonetheless. This kind of flow-map suffers from problems similar to those of heat-maps. One could also argue that the thinness of the lines and their cross-hatch nature hinder interpretability.</p><p><strong>Interaction</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*3dTXvSI-L3X3M-MKXRraBA.gif" />See et al. (2017). Interactive visualization of attention</figure><p>Interaction solves many of the issues of the static visualizations surveyed above. We retain the structure of both the input and output text, and lookup is quick and efficient. There is a trade-off, however. We are only able to view the attention of a single word at a time, and as a result it is hard to get a sense of the overall coverage or structure of attention.</p><h4>A case study: Summarization</h4><p>In particular,<strong> abstractive summarization</strong>. Summarization is a particularly interesting use case of attention because of the requirement of the condensing of text. The hypothesis is that good abstractive models will be able to cover the majority of the original document. Here I note the difference between <strong>extractive </strong>and<strong> abstractive </strong>summarizations. The former involves selecting pieces of the original text, verbatim. The latter involves compressive paraphrasing.</p><p>Until recently, most of the work in text summarization has revolved around extractive summarization (See et al. 2017). However, the rising prevalence of recurrent neural networks has allowed for further focus in abstractive summarization. Attention has played an important role in improving results. Below is a brief list of relevant work.</p><p><a href="https://arxiv.org/pdf/1509.00685.pdf">Rush, Alexander M. et al. “A Neural Attention Model for Abstractive Sentence Summarization.” <em>EMNLP</em> (2015).</a></p><p><a href="https://arxiv.org/pdf/1602.06023.pdf">Nallapati, Ramesh et al. “Abstractive Text Summarization using Sequence-to-sequence RNNs and Beyond.” <em>CoNLL</em> (2016).</a></p><p><a href="https://arxiv.org/pdf/1712.06100.pdf">Hasselqvist, Johan et al. “Query-Based Abstractive Summarization Using Neural Networks.” <em>CoRR</em> abs/1712.06100 (2017): n. pag.</a></p><p><a href="https://arxiv.org/pdf/1705.04304.pdf">Paulus, Romain et al. “A Deep Reinforced Model for Abstractive Summarization.” <em>CoRR</em> abs/1705.04304 (2017): n. pag.</a></p><p><a href="https://arxiv.org/pdf/1704.04368.pdf">See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” <em>ACL</em> (2017).</a></p><h4>Summarization Specific Challenges</h4><p>While visualizations of attention are helpful in shedding light on the workings of seq2seq models, summarization models in particular have trouble leveraging this window.</p><ol><li>We care about <strong>where</strong> attention falls just as much as what it falls on. We hope to maximize <strong>coverage</strong>. This is not currently addressed in any interactive visualizations I am aware of.</li><li>We have large input sequences. As discussed in <strong>“A survey of related work,”</strong> this is particularly problematic for static visualizations.</li></ol><p>With this in mind, I propose areas for improvement in both interactive and static visualizations.</p><h4>Where to?</h4><p>With interactive visualizations, two things.</p><p><strong>One. Coverage </strong>is the aggregated attention over a sequence of output tokens. An example given by See et al. can be seen in the figure below. Perhaps allowing brushing to visualizing the aggregate attention over a phrase or sentence can help us understand attention in a more global context.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/956/0*vE-iXohphbWY6Nam." />See et al. (2017). Example of coverage.</figure><p><strong>Two. Extraction vs Abstraction: </strong>Ideally, we want our model to learn how to abstract rather than extract. 1:1 exact match attention is less interesting to see than seeing attention to groups of words. Perhaps emphasizing / de-emphasizing can this in visualizations can help aid understanding of models.</p><p>With static visualizations, there are two analysis tasks that we wish to optimize for.</p><ol><li><strong>Summary. </strong>What is the overall structure of the attention (e.g. coverage).</li><li><strong>Value. </strong>Which input words are attended (i.e. focused on) by each output timestep?</li></ol><p>It is difficult to design an <em>effective</em> static visualization that lends itself well to both of these tasks. Perhaps we need a set of visualizations. For example, one visualization might afford better performance for summary analysis, while another might afford better performance for value analysis. In addition, these static visualizations can incorporate ideas described in previous section.</p><p>Additionally, attention visualizations thus far have been for <strong>specific examples</strong>. Perhaps there a way we can look <strong>across examples</strong> to better understand the behavior of these neural networks. Derived metrics for attention or coverage could be useful in better understanding and diagnosing these models.</p><p>My hope is that addressing these items in both interactive and static visualizations will allow us to better reason about neural networks. In particular, I hope the result can be used as a valuable tool for error analysis, <strong>even</strong> <strong>beyond</strong> hyperparameter tuning. Insights could be gleamed that motivate additions or constraints or mechanisms to optimize coverage (e.g. See et al. (2017)) or abstraction.</p><h4>The Plan</h4><p><strong>Minimum Viable Plan</strong></p><ol><li>Develop a TensorBoard plugin that allows for the static and interactive visualizations described in <strong>Where to?</strong></li><li>Acquire feedback from students / researchers in the Allen School.</li></ol><p>I intend to leverage existing models to retrieve data. For example, that <a href="https://github.com/abisee/pointer-generator">provided publicly</a> by See et al. (2017). The dataset used by them is a <a href="https://github.com/abisee/cnn-dailymail">modified CNN/Daily Mail Dataset</a> [Hermann et al. (2015), See et al. (2017)] — a collection of articles and bullet point summaries.</p><p><strong>Stretch Goals</strong></p><ol><li>Explore and implement aggregate, cross-example visualizations as described in <strong>Where to?</strong></li><li>Release a beta of the TensorBoard plugin on github and acquire feedback there.</li></ol><h4>Works Cited</h4><ul><li><a href="https://arxiv.org/pdf/1704.04368.pdf">See, Abigail et al. “Get To The Point: Summarization with Pointer-Generator Networks.” <em>ACL</em> (2017).</a></li><li><a href="https://arxiv.org/pdf/1506.02078.pdf">Karpathy, Andrej, Justin Johnson, and Li Fei-Fei. “Visualizing and understanding recurrent networks.” <em>arXiv preprint arXiv:1506.02078</em>(2015).</a></li><li><a href="https://arxiv.org/pdf/1712.06100.pdf">Hasselqvist, Johan et al. “Query-Based Abstractive Summarization Using Neural Networks.” <em>CoRR</em> abs/1712.06100 (2017): n. pag.</a></li><li><a href="https://arxiv.org/pdf/1602.06023.pdf">Nallapati, Ramesh et al. “Abstractive Text Summarization using Sequence-to-sequence RNNs and Beyond.” <em>CoNLL</em> (2016).</a></li><li><a href="https://arxiv.org/pdf/1705.04304.pdf">Paulus, Romain et al. “A Deep Reinforced Model for Abstractive Summarization.” <em>CoRR</em> abs/1705.04304 (2017): n. pag.</a></li><li><a href="https://arxiv.org/pdf/1509.00685.pdf">Rush, Alexander M. et al. “A Neural Attention Model for Abstractive Sentence Summarization.” <em>EMNLP</em> (2015).</a></li><li><a href="https://arxiv.org/pdf/1409.0473.pdf">Bahdanau, Dzmitry, Kyunghyun Cho, and Yoshua Bengio. “Neural machine translation by jointly learning to align and translate.” <em>arXiv preprint arXiv:1409.0473</em> (2014).</a></li><li><a href="https://arxiv.org/pdf/1506.03340.pdf">Hermann, Karl Moritz et al. “Teaching Machines to Read and Comprehend.” <em>NIPS</em>(2015).</a></li></ul><img height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7d8e9ec1a8e3" width="1" /></div>







<p class="date">
<a href="https://medium.com/@halden.lin/nlp-capstone-03-project-proposal-7d8e9ec1a8e3?source=rss-2759d54493c0------2">by Halden Lin at April 12, 2018 05:46 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>April 11, 2018</h2>

<div class="channelgroup">







<h3><a href="https://mathstoc.wordpress.com" title="NLP Capstone – Mathematical Distractions">Kuikui Liu, Nicholas Ruhland <br/> Team INLP</a></h3>


<div class="entrygroup" id="http://mathstoc.wordpress.com/?p=309">
<h4 lang="en"><a href="https://mathstoc.wordpress.com/2018/04/11/nlp-capstone-post-3-proposal/">NLP Capstone Post #3: Proposal</a></h4>
<div class="entry">
<div class="content" lang="en">
<p>Here, we finally present our project proposal in full.</p>
<h3>Project Objectives:</h3>
<p>Our goal for this project is to engineer a model that, given the instrumental (“karaoke”) music for a song in English represented as MIDI data, output a coherent sequence of words corresponding to lyrics for the music. The model will produce timings along with the words to align it with the background instrumentals. Additionally, given the output of the model and the input music, we will automate their combination into a song complete with lyrics and supporting instrumentals. This combined output will be playable and we intend to do live demonstration.</p>
<h3>Proposed Methodology:</h3>
<p>Here, we outline the steps we will need to take in detail.</p>
<li>Data collection (datasets of songs, preferably with instrumentals and lyrics already separated)</li>
<li>Decide on vocabulary and how to handle uncommon words</li>
<li>Decide and implement any required preprocessing of the raw MIDI data. Strip lyrics from MIDI data if not already provided in dataset.</li>
<li>Decide and implement model (see Model Design)</li>
<li>Implement model sanity checks</li>
<li>Model tweaking (we expect this will take the majority of the time; see Model Design)</li>
<li>Implement automated combination of model output (lyrics) and model input (instrumentals)</li>
<li>Further testing</li>
<li>Assuming preceding steps are completed satisfactorily, proceed to stretch goals</li>
<li>Presentation and write-up</li>
<h3>Model Design:</h3>
<p>We will pursue a seq2seq RNN approach, taking in input MIDI data represented as a sequence, and outputting a sequence of words from a specified vocabulary. This model will be referred to as the generator. We will employ adversarial training, simultaneously training a many-to-one RNN discriminator that, given the input instrumentals and corresponding lyrics, output if the lyrics were produced by the generator or not. We will follow approaches taken in previous works such as SeqGAN [2] (and [3, 4]), namely using policy gradient ideas from reinforcement learning to obtain gradients that can be backpropagated from the discriminator network through the generator network. We note that syntactic correctness can be enforced in this manner, as malformed lyrical output can be assigned arbitrarily small reward.</p>
<h3>Stretch Goals:</h3>
<p>There are several stretch goals we will consider, time permitted. They are as follows, in no particular order.</p>
<li>Handling multiple languages, particularly those with less available data</li>
<li>Given a specific songwriter/band, produce the instrumentals along with lyrics for a new song that is in the style of that songwriter/band</li>
<li>Lyrics generation for duets, or multi-singer songs</li>
<li>Playing with phoneme-level generation</li>
<h3>Core Challenges:</h3>
<p>The core challenges we will need to overcome include alignment of lyrics with the music, and production of sensible lyrics. On the more technical side, it is well-known that ensuring convergence in adversarial training is difficult.</p>
<h3>Available Resources:</h3>
<p>Existing music datasets for machine learning tasks are made up of audio samples (such as .wav or .mp3), or MIDI data that specifies timing and notes. For karaoke, lyrics are also provided either as a separate text file (.LRC) specifying the timing of each word, or can be embedded into the MIDI file directly (.KAR). It may also be useful to train a lyric model on a larger corpus of song lyrics, since lyrics are easier to collect than fully time-annotated karaoke files.</p>
<p>The MusicNet dataset [9] provides 330 classical instrumental audio files, each of which has associated timing provided for every note. Since we are primarily interested in lyrical generation and alignment, this dataset is not going to be useful for creating a language model.</p>
<p>An existing karaoke dataset called Kara1k [1] provides many features computed from 1000 lyric-annotated songs. This provides lots of metadata about each song, including annotated chords for each timestep of the song. According to the KaraMIR website, these features are extracted from audio samples using Vamp Plugins, which estimates chords with accuracy up to 70%. </p>
<p>We propose a new dataset (name not yet determined) of MIDI karaoke data with embedded lyrics (.KAR). This dataset contains over 700 files, scraped from a karaoke content aggregator [11]. Timed lyrical data has been extracted from these files, and the precise timing of each note is already available by nature of the MIDI format.</p>
<p>Additional datasets for training a lyric model may be useful, and many are available. One such dataset is the 55000+ Song Lyrics on Kaggle [10]. This could help our model generalize its lyrical output beyond the limited set of vocabulary available within the 1000 or fewer annotated karaoke songs.</p>
<h3>Evaluation Plan:</h3>
<p>Evaluation of our model can be done several ways. The first is simply to listen to the music ourselves. This is the most direct method of evaluation but is not efficient, as likely we will need many iterations of tuning; furthermore, will likely need to listen to several songs to be confident of the model’s quality. Hence, we will also design basic “sanity check” tests for our models.</p>
<p>Recall that in our proposed methodology, we intend to use adversarial training. The discriminator network itself gives a direct evaluation of the generator. As long as the discriminator is of vetted quality, and the discriminator is run on sufficiently many examples (with roughly even number of generated and true examples mixed in), the generator will be deemed also of sufficient quality (as a “sanity check”).</p>
<p>Of course, this leaves the question of ensuring the discriminator is good. We can run the discriminator on instrumentals combined with randomly generated words (according to some distribution), or on instrumentals combined with the original lyrics, which are perturbed in some fashion. As an example, one can perturb the original lyrics temporally (making an utterance off-beat when it should be precisely on the down-beat of a bar) or replacing a few words with randomly selected ones (according to some distribution over the vocabulary). These “test inputs” to the discriminator can be generated before-hand.</p>
<h3>Literature Survey:</h3>
<p>Here are some relevant papers (most were already included in preceding posts).</p>
<p>[1] Y. Bayle, L. Marsik, M. Rusek, M. Robine, P. Hanna, K. Slaninova, J. Martinovic, J. Pokorny. “Kara1k: A Karaoke Dataset for Cover Song Identification and Singing Voice Analysis”. IEEE International Symposium on Multimedia (ISM), 2017. <a href="https://ieeexplore.ieee.org/document/8241597/" rel="nofollow">https://ieeexplore.ieee.org/document/8241597/</a></p>
<p>[2] L. Yu, W. Zhang, J. Wang, Y. Yu. “SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient”. Proceedings of the Thirty-First AAAI Conference on Artificial Intelligence, 2017. <a href="https://arxiv.org/abs/1609.05473" rel="nofollow">https://arxiv.org/abs/1609.05473</a></p>
<p>[3] S. Lee, U. Hwang, S. Min, S. Yoon. “A SeqGAN for Polyphonic Music Generation”. 2017. <a href="https://arxiv.org/abs/1710.11418" rel="nofollow">https://arxiv.org/abs/1710.11418</a></p>
<p>[4] H. W. Dong, W. Y. Hsiao, L. C. Yang, Y. H. Yang. “MuseGAN: Multi-track Sequential Generative Adversarial Networks for Symbolic Music Generation and Accompaniment”. 2017. <a href="https://arxiv.org/abs/1709.06298" rel="nofollow">https://arxiv.org/abs/1709.06298</a></p>
<p>[5] I. J. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, Y. Bengio. “Generative Adversarial Nets”. NIPS, 2014. <a href="https://papers.nips.cc/paper/5423-generative-adversarial-nets" rel="nofollow">https://papers.nips.cc/paper/5423-generative-adversarial-nets</a></p>
<p>[6] T. Salimans, I. J. Goodfellow, W. Zaremba, V. Cheung, A. Radford, X. Chen. “Improved Techniques for Training GANs”. NIPS, 2016. <a href="https://arxiv.org/abs/1606.03498" rel="nofollow">https://arxiv.org/abs/1606.03498</a></p>
<p>[7] M. Arjovsky,  S. Chintala, L. Bottou. “Wasserstein GAN”. 2017. <a href="https://arxiv.org/abs/1701.07875" rel="nofollow">https://arxiv.org/abs/1701.07875</a></p>
<p>[8] J. Faille, Y. Wang. “Using Deep Learning to Annotate Karaoke Songs”. 2016. <a href="https://www.semanticscholar.org/paper/Using-Deep-Learning-to-Annotate-Karaoke-Songs-Faille-Wang/521361762a7327f8fcc77bd9d76eaa2b503f845a" rel="nofollow">https://www.semanticscholar.org/paper/Using-Deep-Learning-to-Annotate-Karaoke-Songs-Faille-Wang/521361762a7327f8fcc77bd9d76eaa2b503f845a</a></p>
<p>[9] J. Thickstun, Z. Harchaoui, S. Kakade. “Learning Features of Music from Scratch”. 2017. <a href="https://arxiv.org/abs/1611.09827" rel="nofollow">https://arxiv.org/abs/1611.09827</a></p>
<p>[10] Additional data <a href="https://www.kaggle.com/mousehead/songlyrics">here</a></p>
<p>[11] Even more additional data <a href="http://vooch.narod.ru/midi/midi.htm">here</a></p></div>







<p class="date">
<a href="https://mathstoc.wordpress.com/2018/04/11/nlp-capstone-post-3-proposal/">by Kuikui Liu at April 11, 2018 06:45 AM</a>
</p>
</div>
</div>


</div>

</div>


<div class="sidebar">

<h2>Subscriptions</h2>
<ul>
<li>
<a href="https://medium.com/feed/@viterbi.or.not" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://medium.com/@viterbi.or.not?source=rss-c522ef075bb3------2" title="Stories by Viterbi Or Not To Be on Medium">Aaron Johnston, Lynsey Liu <br/> Team Viterbi Or Not To Be</a>
</li>
<li>
<a href="https://deeplearningturingtest.wordpress.com/feed/" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://deeplearningturingtest.wordpress.com" title="NLP Capstone Project Updates – Ananth">Ananth Gottumukkala <br/> Team Turing Test</a>
</li>
<li>
<a href="https://medium.com/feed/@be.li.nda" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://medium.com/@be.li.nda?source=rss-fad49d942bf3------2" title="Stories by Belinda Zou Li on Medium">Belinda Li <br/> Team Sentimentity</a>
</li>
<li>
<a href="http://cse481n-capstone.azurewebsites.net/feed/" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="http://cse481n-capstone.azurewebsites.net" title="Team Watch Your Language!">Boyan Li, Dennis Orzikh, Lanhao Wu <br/> Team Watch Your Language!</a>
</li>
<li>
<a href="https://medium.com/feed/@halden.lin" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://medium.com/@halden.lin?source=rss-2759d54493c0------2" title="Stories by Halden Lin on Medium">Halden Lin <br/> Team undef.</a>
</li>
<li>
<a href="https://mathstoc.wordpress.com/category/nlp-capstone/feed/" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://mathstoc.wordpress.com" title="NLP Capstone – Mathematical Distractions">Kuikui Liu, Nicholas Ruhland <br/> Team INLP</a>
</li>
<li>
<a href="https://teamoverfit.blogspot.com/feeds/posts/default?alt=rss" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://teamoverfit.blogspot.com/" title="NLP Capstone">Pinyi Wang, Dawei Shen, Xukai Liu <br/> Team Overfit</a>
</li>
<li>
<a href="https://nlpcapstonesemparse.blogspot.com/feeds/posts/default?alt=rss" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://nlpcapstonesemparse.blogspot.com/" title="NlpCapstone">Rajas Agashe <br/> Team Han Flying Solo</a>
</li>
<li>
<a href="https://cse481n.blogspot.com/feeds/posts/default?alt=rss" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://cse481n.blogspot.com/" title="PrimeapeNLP">Ron Fan, Aditya Saraf <br/> Team PrimeapeNLP</a>
</li>
<li>
<a href="https://medium.com/feed/@ryanp97" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://medium.com/@ryanp97?source=rss-6378d85d3a9b------2" title="Stories by Ryan Pham on Medium">Ryan Pham <br/> Team NeuralEmpty</a>
</li>
<li>
<a href="http://sarahyu.weebly.com/6/feed" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="http://sarahyu.weebly.com/cse-481n" title="Sarah yu - CSE 481N">Sarah Yu <br/> Team Jekyll-Hyde</a>
</li>
<li>
<a href="https://medium.com/feed/nlp-capstone-blog" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://medium.com/nlp-capstone-blog?source=rss----9ba3897b6688---4" title="NLP Capstone Blog - Medium">Tam Dang, Karishma Mandyam <br/> Team Illimitatum</a>
</li>
<li>
<a href="https://medium.com/feed/@hongnin1" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://medium.com/@hongnin1?source=rss-c450eb982161------2" title="Stories by Ning Hong on Medium">Zichun Liu, Ning Hong, Sujie Zhou <br/> Team The Bugless</a>
</li>
</ul>

<p>
<strong>Last updated:</strong><br>
August 15, 2018 12:35 AM<br>
<em>All times are UTC.</em><br>

<!--
<br>
Powered by:<br>
<a href="http://www.planetplanet.org/"><img src="images/planet.png" width="80" height="15" alt="Planet" border="0"></a>
</p>

<p>
<h2>Planetarium:</h2>
<ul>
<li><a href="http://www.planetapache.org/">Planet Apache</a></li>
<li><a href="http://planet.freedesktop.org/">Planet freedesktop.org</a></li>
<li><a href="http://planet.gnome.org/">Planet GNOME</a></li>
<li><a href="http://planet.debian.net/">Planet Debian</a></li>
<li><a href="http://planet.fedoraproject.org/">Planet Fedora</a></li>
<li><a href="http://planets.sun.com/">Planet Sun</a></li>
<li><a href="http://www.planetplanet.org/">more...</a></li>
</ul>
</p>
!-->
</div>
</body>

</html>
